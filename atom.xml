<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>测试狗</title>
  
  <subtitle>测试狗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://thinkerchan.com/"/>
  <updated>2021-03-08T09:48:44.000Z</updated>
  <id>https://thinkerchan.com/</id>
  
  <author>
    <name>测试狗</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【玩物志】Ganss GS87D-性价比最强入门双模机械键盘</title>
    <link href="https://thinkerchan.com/2020/09/01/ganss-gs87d/"/>
    <id>https://thinkerchan.com/2020/09/01/ganss-gs87d/</id>
    <published>2020-09-01T05:16:00.000Z</published>
    <updated>2021-03-08T09:48:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>19年双十一的时候我组了一台黑苹果，自然也要选一个键盘。由于从来没有用过机械键盘，我决定买一个试试，需求如下：</p><ul><li>红轴</li><li>简约高颜值</li><li>不要跑马灯</li><li>支持无线，双模更优</li><li>不要太贵</li></ul><p>实际上我淘宝收藏夹里面早就收藏了大F的87圣手和minila，心水了好久。可惜缺点是贵，贵不是它们的缺点，是我的缺点。看了看我的钱包，对收藏的大F始终下不了手。</p><p>filco 87双模圣手二代(红轴 ￥1199)<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gicbnqukyij30iw0e6q3u.jpg" alt></p><p>filco minila 奶白色(茶轴 ￥1399)<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gicbobtrfej30iw0e6758.jpg" alt></p><h2 id="购买过程"><a href="#购买过程" class="headerlink" title="购买过程"></a>购买过程</h2><p>不过Filco忍者圣手二代既然是个公模，那就找一个看起来差不多的。一开始考虑了ikbc，c87系列和w200系列，c87是有线的，w200是2.4g无线，唯独没有双模。</p><p>由于我主机是nuc8，我不太想多占一个usb口，蓝牙无线的话就更加完美了。当然我也不愿意放弃usb链接方式，我可以不用，但是它不能没有。</p><p>ikbc c87/w200外观<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gicbonu56fj30iw0argm5.jpg" alt></p><p>价格：</p><ul><li>ikbc c87白色(红轴 约￥340)</li><li>ikbc w200白色(红轴 约￥400)</li></ul><p>其实也不是没考虑过60%的键盘，毕竟放办公桌上非常简洁，也方便携带。ikbc poker系列颜值也高，但是考虑到经常用的方向键需要按键组合，还是放弃了。</p><p>图为ikbc poker2<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gicbou2l6sj30iw0cmgmn.jpg" alt></p><p>老规矩，不知道买啥，就往电商平台里面按销量筛选双模机械键盘。之前也做了一点功课，红轴适合我。于是发现了ganss（官方叫迦斯，但大家都称其为高斯） gs87d。蓝牙5.0 type-c双模，模具用的也是和大F87圣手、ikbc c87、w200一样的公模，而且只要不到400元的指导价，比起大F动辄上千的价格，那约等于白菜价，便毫不犹豫下单了。</p><p>双十一优惠价格￥319，通过朋友的渠道，返现6%，所以实际到手￥307，我估计没有多少人买的比这便宜了。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gic43pq9yuj31fa08u76j.jpg" alt></p><h2 id="伪开箱"><a href="#伪开箱" class="headerlink" title="伪开箱"></a>伪开箱</h2><p>今年初手机掉水了坏了，手机存拍的开箱图全都没了（拖延癌的后果）。所以在张大妈里面找的图来凑数，图作者分别是@<a href="https://zhiyou.smzdm.com/member/9394920444/" target="_blank" rel="noopener">望天是个饼</a>和@<a href="https://zhiyou.smzdm.com/member/9398539463/" target="_blank" rel="noopener">芒果和柚子</a></p><p>实际上去年双十一的时候，gs87d已经出了新款，而且它是新旧款同时发售（当时极有可能是随机发货）。我拿到快递的时候，还诧异怎么和网上的其他用户的包装不一样，才发现我的是最新款（即便今年在张大妈社区看gs87d的评测，还是有很多人评测的是旧款），所以我可能是最早一批新款gs87d用户。</p><p>区别于旧款，新款做了以下优化：</p><ul><li>键盘底部去除logo：更简约</li><li>锂电池换成了干电池：不用担心锂电池衰减了</li><li>背部走线优化：显然是优点</li><li>蓝牙5.0：更省电</li></ul><p>新款gs87d包装<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gicfa07q78j30iw0ciq44.jpg" alt></p><p>新款gs87d全家福<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giccc4f7irj30iw0g2n3a.jpg" alt></p><p>新款gs87d背面（走线优化）<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1giccdmwvcxj30iw0e641q.jpg" alt></p><p>旧款gs87d包装<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gicfaviz5aj30iw0e6aas.jpg" alt></p><p>旧款gs87d全家福<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gicfba6p2bj30iw0e6q4k.jpg" alt></p><p>旧款gs87d局部<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gicfbtcme5j30iw0e6zlz.jpg" alt></p><p>旧款gs87d接口位置<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gicfc6g41vj30iw0e63za.jpg" alt></p><h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>做工方面，到手的时候，感觉非常厚实，装上电池大概980g，差不多两斤的重量，所以随身携带去办公不实际。此外，做工只能说还行，肯定是对得起这个价格的。键帽水口没有毛边和倒刺。</p><p>功能方面，只有用有线模式的情况下才能使用键盘灯，灯光亮度可调节，也可使用呼吸灯模式。灯光只有白灯，因为对我来说灯可有可无，所以也是可以接受的。另外，键盘是支持diy灯光的，喜欢diy的玩家，应该会对这个感兴趣。</p><p>因为我是黑苹果用户，所以fn+alt切换成mac模式，再把win和alt按键互相调换。键盘重启之后没有记忆功能，所以只要键盘不关电源，那这个按键组合是一直作用的。mac开机完毕后，需要主动按键盘，才能触发蓝牙自动连接，时间大概花费2秒。这个比较令人不爽，有时候连续打了好几个字，键盘才刚连上。</p><p>猜测这个主动触发模式，应该是出于省电考虑的。这里有个业余用户的建议，牺牲一点续航，每隔10s发送一次信号检测，主动连上已连接的设备，体验应该更好。</p><p>延迟的话，我觉得还行，我用它来打网易的吃鸡，没感觉到延迟。</p><p>续航方面，从去年双十一到现在用了十个月，我只换过一次电池，无可挑剔。</p><p>手感方面，回车键和空间有点肉，虽然说是用cherry原厂红轴，但是和我之前体验的cherry原厂键盘的手感，还是有不小差距的。想想300出头的价格，那当然是选择原谅它啦！</p><p>总的来说，无论颜值功能手感，gs87d都属于￥300多价格上最能打的一个。追求性价比的朋友，可以考虑。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>尽管80%键盘我觉得就挺简约的了，但是久了我觉得60%的键盘更完美，前提是要带标准方向键。所以又暗暗种草了两款60%的键盘。</p><p>1.keydous nj68<br>来自珠海一个小厂的机械键盘，颜值非常高。价位在￥500左右。传说是￥500左右退烧的机械键盘。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gicbr4vizjj30iw0dwq3m.jpg" alt></p><p>2.niz atom 68<br>比较知名的国产静电容键盘，颜值高，据说手感好。不过价格稍贵，双模价格￥860左右。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gicbphku2yj30iw0cyn05.jpg" alt></p><p>等我多配一个电脑办公的时候，下次一定。</p><hr><p>谢谢你关注我的公众号: 测试狗</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g6cab5r3cgj308c08caaj.jpg" alt="二维码"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;19年双十一的时候我组了一台黑苹果，自然也要选一个键盘。由于从来没有用过机械键盘，我决定买一个试试，需求如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;红
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【快速教程】Hexo站内搜索的实现</title>
    <link href="https://thinkerchan.com/2020/08/01/hexo-site-search-mod/"/>
    <id>https://thinkerchan.com/2020/08/01/hexo-site-search-mod/</id>
    <published>2020-08-01T04:09:17.000Z</published>
    <updated>2020-09-01T04:17:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>本主题站内搜索的实现, 可从标题和内容中搜索单个或多个词条，详情看源码。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span> <span class="attr">page.title</span>  %&gt;</span> <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"entry-content wrapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"search"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入关键字"</span> <span class="attr">id</span>=<span class="string">"Jinput"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">      本次搜索结果共<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"Jcount"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span>条</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"JresList"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">    <span class="attr">let</span> <span class="attr">posts</span> = <span class="string">site.posts.data</span></span></span><br><span class="line"><span class="tag">    <span class="attr">let</span> <span class="attr">searchData</span> = <span class="string">[]</span></span></span><br><span class="line"><span class="tag">    <span class="attr">posts.forEach</span>(<span class="attr">item</span> =&gt;</span> &#123;</span><br><span class="line">      searchData.push(&#123;</span><br><span class="line">        title: trim(item.title),</span><br><span class="line">        content: trim(strip_html(item.content)).replace(/<span class="symbol">&amp;#123;</span>/g,'&#123;').replace(/<span class="symbol">&amp;#125;</span>/g,'&#125;'),</span><br><span class="line">        url:'/'+item.path,</span><br><span class="line">        link: item.link,</span><br><span class="line">        plink: item.permalink</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">    let _searchData = JSON.stringify(searchData)</span><br><span class="line">  %&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> searchData = &lt;%- _searchData %&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> searchMod = &#123;</span></span><br><span class="line"><span class="actionscript">          searchTitle: <span class="literal">true</span>, <span class="comment">//  是否在标题中搜索</span></span></span><br><span class="line"><span class="actionscript">          searchContent: <span class="number">1</span>, <span class="comment">// 是否在内容中搜索</span></span></span><br><span class="line"><span class="actionscript">          contentPieces: <span class="number">2</span>, <span class="comment">// 内容切割块数</span></span></span><br><span class="line"><span class="actionscript">          excludes: [<span class="string">'&#123;&#123;'</span>, <span class="string">'&#125;&#125;'</span>, <span class="string">'&#123;'</span>, <span class="string">'&#125;'</span>, <span class="string">'.'</span>, <span class="string">'/'</span>, <span class="string">'\\'</span>, <span class="string">'。'</span>], <span class="comment">// 粗略过滤部分字符串</span></span></span><br><span class="line"><span class="actionscript">          contentDecoration: <span class="number">50</span>, <span class="comment">// 内容命中关键字增加前后50个字</span></span></span><br><span class="line"><span class="actionscript">          roughFetch: <span class="literal">false</span>, <span class="comment">// 是否粗略提取, 仅对文本内容有效</span></span></span><br><span class="line">          trimStr(str) &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> str.trim().toLowerCase()</span></span><br><span class="line">          &#125;,</span><br><span class="line">          init(input) &#123;</span><br><span class="line"><span class="actionscript">            input.addEventListener(<span class="string">'input'</span>, (e) =&gt; &#123;</span></span><br><span class="line"><span class="javascript">              <span class="keyword">let</span> searchText = <span class="keyword">this</span>.trimStr(input.value)</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">this</span>.fetchTxtFromDB(searchText, searchData)</span></span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;,</span><br><span class="line">          fetchTxtFromDB(searchText, DB) &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> resultArr = []</span></span><br><span class="line"></span><br><span class="line">            if (searchText) &#123;</span><br><span class="line"><span class="javascript">              <span class="keyword">let</span> searchTextArr = searchText.split(<span class="regexp">/[\s\-]+/</span>); <span class="comment">// 非首尾空格分割词条</span></span></span><br><span class="line"><span class="javascript">              searchTextArr = searchTextArr.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> !<span class="keyword">this</span>.excludes.includes(item);</span></span><br><span class="line">              &#125;)</span><br><span class="line"></span><br><span class="line">              if (searchTextArr.length &gt; 1) &#123;</span><br><span class="line"><span class="actionscript">                searchTextArr.push(searchText); <span class="comment">// 保留原始词条做完全匹配</span></span></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">              resultArr = DB.filter(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> articleTitle = <span class="keyword">this</span>.trimStr(item.title);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> titleHitArr = []</span></span><br><span class="line">                item.tmpTitleArr = []</span><br><span class="line"><span class="actionscript">                item._title = <span class="string">''</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> articleContent = <span class="keyword">this</span>.trimStr(item.content);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> contentHitArr = []</span></span><br><span class="line">                item.tmpContentArr = []</span><br><span class="line"><span class="actionscript">                item.indexArr = []  <span class="comment">// 词条在内容中第一次出现的位置</span></span></span><br><span class="line"><span class="actionscript">                item._content = <span class="string">''</span> <span class="comment">// 存储已经高亮关键字的原文</span></span></span><br><span class="line"><span class="actionscript">                item._contentSliceArr = [] <span class="comment">// 存储截取后的原文碎片</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">                searchTextArr.map(<span class="function">(<span class="params">one, index</span>) =&gt;</span> &#123; <span class="comment">// 求出searchTextArr有多少个命中的词条</span></span></span><br><span class="line"><span class="actionscript">                  <span class="keyword">if</span> (<span class="keyword">this</span>.searchTitle) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> b = articleTitle.indexOf(one) &gt; <span class="number">-1</span>;</span></span><br><span class="line">                    b &amp;&amp; titleHitArr.push(one)</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">                  <span class="keyword">if</span> (<span class="keyword">this</span>.searchContent) &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> b2 = articleContent.indexOf(one) &gt; <span class="number">-1</span></span></span><br><span class="line">                    b2 &amp;&amp; contentHitArr.push(one)</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;)</span><br><span class="line"></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span> (<span class="keyword">this</span>.searchTitle &amp;&amp; titleHitArr.length) &#123;</span></span><br><span class="line"><span class="javascript">                  titleHitArr.map(<span class="function">(<span class="params">one, index</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> keyWordHtml = <span class="keyword">this</span>.keyWordTpl().replace(<span class="regexp">/&#123;&#123;searchText&#125;&#125;/</span>, one),</span></span><br><span class="line"><span class="actionscript">                      titleArrWithoutKeyWord = (!index ? articleTitle : item.tmpTitleArr[index - <span class="number">1</span>]).split(one), <span class="comment">// 用数组切割的方式把所有文本内包含的关键词替换出来, 下一次的分割依赖上一次分割结果</span></span></span><br><span class="line">                      highlightTxt = titleArrWithoutKeyWord.join(keyWordHtml);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">                    item.tmpTitleArr.push(highlightTxt); <span class="comment">// 记录前一次的结果,用于下一次计算</span></span></span><br><span class="line"><span class="actionscript">                    item._title = highlightTxt; <span class="comment">// 最后一次为最终结果</span></span></span><br><span class="line">                  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="actionscript">                  <span class="keyword">delete</span> item.tmpTitleArr</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span> (<span class="keyword">this</span>.searchContent &amp;&amp; contentHitArr.length) &#123;</span></span><br><span class="line"><span class="javascript">                  contentHitArr.map(<span class="function">(<span class="params">one, index</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">if</span> (<span class="keyword">this</span>.roughFetch) &#123; <span class="comment">// 先高亮后截取(可能造成高亮标签切割问题)</span></span></span><br><span class="line"><span class="javascript">                      <span class="keyword">let</span> keyWordHtml = <span class="keyword">this</span>.keyWordTpl().replace(<span class="regexp">/&#123;&#123;searchText&#125;&#125;/</span>, one),</span></span><br><span class="line">                        contentArrWithoutKeyWord = (!index ? articleContent : item.tmpContentArr[index - 1]).split(one),</span><br><span class="line">                        highlightTxt = contentArrWithoutKeyWord.join(keyWordHtml);</span><br><span class="line"></span><br><span class="line">                      item.tmpContentArr.push(highlightTxt);</span><br><span class="line">                      item._content = highlightTxt;</span><br><span class="line"><span class="actionscript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">                      item.indexArr.push(&#123;</span><br><span class="line"><span class="actionscript">                        start: articleContent.indexOf(one), <span class="comment">// 记录词条第一次出现的位置，和词条的长度</span></span></span><br><span class="line">                        length: one.length,</span><br><span class="line">                        str: one,</span><br><span class="line">                      &#125;)</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">                  item.indexArr.map(<span class="function">(<span class="params">one, index</span>) =&gt;</span> &#123; <span class="comment">// 有可能把&lt;b&gt;标签给切割了,造成样式异常, 需要另外处理</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> keyWordEndPosition = one.start + one.length <span class="comment">// 词条的结束位置,用于计算截取长度</span></span></span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> content = <span class="keyword">this</span>.roughFetch ? item._content : item.content;</span></span><br><span class="line"><span class="javascript">                    <span class="keyword">let</span> contentLen = content.length;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">                    <span class="keyword">if</span> (one.start &gt; <span class="keyword">this</span>.contentDecoration) &#123;</span></span><br><span class="line"><span class="javascript">                      <span class="keyword">let</span> highLightEndPosition = keyWordEndPosition + <span class="keyword">this</span>.contentDecoration</span></span><br><span class="line">                      highLightEndPosition = highLightEndPosition &gt; contentLen ? contentLen : highLightEndPosition</span><br><span class="line"><span class="actionscript">                      item._contentSliceArr.push(<span class="string">'...'</span>+content.slice(one.start - <span class="keyword">this</span>.contentDecoration, highLightEndPosition) + <span class="string">'...'</span>)</span></span><br><span class="line"><span class="actionscript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">                      <span class="keyword">let</span> highLightEndPosition = keyWordEndPosition + <span class="keyword">this</span>.contentDecoration * <span class="number">2</span></span></span><br><span class="line">                      highLightEndPosition = highLightEndPosition &gt; contentLen ? contentLen : highLightEndPosition</span><br><span class="line"><span class="actionscript">                      item._contentSliceArr.push(<span class="string">'...'</span>+content.slice(<span class="number">0</span>, highLightEndPosition) + <span class="string">'...'</span>)</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="actionscript">                  <span class="keyword">if</span> (!<span class="keyword">this</span>.roughFetch) &#123;</span></span><br><span class="line"><span class="javascript">                    contentHitArr.map(<span class="function">(<span class="params">one, index</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                      <span class="keyword">let</span> keyWordHtml = <span class="keyword">this</span>.keyWordTpl().replace(<span class="regexp">/&#123;&#123;searchText&#125;&#125;/</span>, one),</span></span><br><span class="line"><span class="handlebars"><span class="xml">                        contentArrWithoutKeyWord = (!index ? item._contentSliceArr.join('<span class="tag">&lt;<span class="name">i</span> <span class="attr">style</span>=<span class="string">"display:block;padding-top:10px"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span>') : item.tmpContentArr[index - 1]).split(one),</span></span></span><br><span class="line">                        highlightTxt = contentArrWithoutKeyWord.join(keyWordHtml);</span><br><span class="line"></span><br><span class="line">                      item.tmpContentArr.push(highlightTxt);</span><br><span class="line">                      item._content = highlightTxt</span><br><span class="line">                    &#125;)</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">                  <span class="keyword">delete</span> item.tmpContentArr</span></span><br><span class="line"><span class="actionscript">                  <span class="keyword">delete</span> item._contentSliceArr</span></span><br><span class="line"><span class="actionscript">                  <span class="keyword">delete</span> item.indexArr</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">                <span class="keyword">return</span> (<span class="keyword">this</span>.searchTitle &amp;&amp; titleHitArr.length) || (<span class="keyword">this</span>.searchContent &amp;&amp; contentHitArr.length)</span></span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.resultArr = resultArr;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.render(JresList, Jcount, resultArr)</span></span><br><span class="line">          &#125;,</span><br><span class="line">          render(ele, countEle, resultArr) &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> htmlArr = resultArr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">              <span class="keyword">return</span> <span class="keyword">this</span>.itemTpl()</span></span><br><span class="line"><span class="javascript">                .replace(<span class="regexp">/&#123;&#123;url&#125;&#125;/g</span>, item.url)</span></span><br><span class="line"><span class="javascript">                .replace(<span class="regexp">/&#123;&#123;title&#125;&#125;/g</span>, item._title || item.title)</span></span><br><span class="line"><span class="javascript">                .replace(<span class="regexp">/&#123;&#123;content&#125;&#125;/g</span>, item._content)</span></span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            ele.innerHTML = htmlArr.join(<span class="string">''</span>)</span></span><br><span class="line">            countEle.innerHTML = htmlArr.length</span><br><span class="line">          &#125;,</span><br><span class="line">          itemTpl() &#123;</span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> `</span></span><br><span class="line"><span class="javascript">            &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123;url&#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">              <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"search-result-title"</span>&gt;</span></span><span class="template-variable">&#123;&#123;title&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">              <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"search-result search-result-link"</span>&gt;</span></span><span class="template-variable">&#123;&#123;content&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">              <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span></span><br><span class="line">          `;</span><br><span class="line">          &#125;,</span><br><span class="line">          keyWordTpl() &#123;</span><br><span class="line"><span class="handlebars"><span class="xml">            return `<span class="tag">&lt;<span class="name">b</span> <span class="attr">class</span>=<span class="string">"search-keyword"</span>&gt;</span></span><span class="template-variable">&#123;&#123;searchText&#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span>`</span></span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      searchMod.init(Jinput)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;源码&quot;&gt;&lt;a href=&quot;#源码&quot; class=&quot;headerlink&quot; title=&quot;源码&quot;&gt;&lt;/a&gt;源码&lt;/h2&gt;&lt;p&gt;本主题站内搜索的实现, 可从标题和内容中搜索单个或多个词条，详情看源码。&lt;/p&gt;
&lt;figure class=&quot;highlight html
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【快速教程】120行代码理解双向数据绑定</title>
    <link href="https://thinkerchan.com/2019/04/28/minivue/"/>
    <id>https://thinkerchan.com/2019/04/28/minivue/</id>
    <published>2019-04-28T12:21:00.000Z</published>
    <updated>2020-07-20T06:05:52.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>劫持对象属性的get/set特性是双向数据绑定的实现方式. 数据改变的时候, set中触发视图更新函数. 这种思路也就是常见的观察者模式. 手写双向数据绑定, 非常适合作为一道面试题, 它考察了 原型链/变量作用域/闭包/Dom/正则/设计模式等等知识点.</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// minivue.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">miniVue</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$el = <span class="built_in">document</span>.querySelector(options.el);</span><br><span class="line">  <span class="keyword">this</span>.$data = options.data;</span><br><span class="line">  <span class="keyword">this</span>.$methods = options.methods;</span><br><span class="line">  <span class="keyword">this</span>.bindings = &#123;&#125;; <span class="comment">// data中的某个数据有可能作用到好几个地方, 所以需要存起来用于之后遍历执行更新</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.observer(<span class="keyword">this</span>.$data);</span><br><span class="line">  <span class="keyword">this</span>.compile(<span class="keyword">this</span>.$el);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">miniVue.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>:miniVue,</span><br><span class="line">  observer:function(data) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">      <span class="keyword">this</span>.bindings[key] = [];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这个数组主要用途: 存储对应数据关联的dom节点信息</span></span><br><span class="line">      <span class="keyword">var</span> arr = <span class="keyword">this</span>.bindings[key];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 抽离方法避免闭包问题</span></span><br><span class="line">      <span class="keyword">this</span>.defineReactive(data,key,data[key],arr)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  defineReactive:<span class="function"><span class="keyword">function</span>(<span class="params">data,key,value,arr</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// Object.defineProperty执行之后, configurable, enumerble为false</span></span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">      <span class="keyword">get</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">set</span>(newVal) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newVal !== value) &#123;</span><br><span class="line">          value = newVal;</span><br><span class="line">          <span class="comment">// 同步更新视图</span></span><br><span class="line">          arr.forEach(<span class="function">(<span class="params">item</span>)=&gt;</span> &#123;</span><br><span class="line">            item.updateView();</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  compile:<span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nodes = ([]).slice.call(el.children);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nodes.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> node = nodes[i];</span><br><span class="line">      <span class="comment">// if (node.children.length &gt; 0)&#123;</span></span><br><span class="line">      <span class="comment">//   this.compile(node)  //递归:防止目标元素有嵌套</span></span><br><span class="line">      <span class="comment">// &#125;;</span></span><br><span class="line">      <span class="keyword">if</span> (node.nodeType === <span class="number">1</span> &amp;&amp; !!node.childElementCount) &#123;  <span class="comment">// 换一种判断</span></span><br><span class="line">        <span class="keyword">this</span>.compile(node)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.nodeType === <span class="number">1</span> &amp;&amp; !node.childElementCount &amp;&amp; node.textContent.trim()) &#123;</span><br><span class="line">        <span class="keyword">var</span> v = <span class="keyword">this</span>.textToExp(node.textContent);</span><br><span class="line">        <span class="keyword">this</span>.recordRelativeDom(node,<span class="string">"innerText"</span>,v,<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (node.hasAttribute(<span class="string">"v-model"</span>)) &#123;</span><br><span class="line">        <span class="keyword">var</span> attrVal = node.getAttribute(<span class="string">"v-model"</span>);</span><br><span class="line">        <span class="comment">// 方法1: 优化闭包</span></span><br><span class="line">        node.addEventListener(<span class="string">"input"</span>, (<span class="function">(<span class="params">i</span>) =&gt;</span> &#123; <span class="comment">// 因为闭包原因产生索引错乱,故用IIFE来优化</span></span><br><span class="line">          <span class="keyword">this</span>.recordRelativeDom(node,<span class="string">"value"</span>,attrVal,<span class="keyword">this</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.$data[attrVal] = nodes[i].value;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)(i))</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 方法2: for循环的所有var改let</span></span><br><span class="line">        <span class="comment">// this.bindings[attrVal].push(new Notify(node, "value", this, attrVal));</span></span><br><span class="line">        <span class="comment">// node.addEventListener("input", () =&gt; &#123;</span></span><br><span class="line">        <span class="comment">//   this.$data[attrVal] = node.value;</span></span><br><span class="line">        <span class="comment">// &#125;)</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.hasAttribute(<span class="string">"v-html"</span>)) &#123;</span><br><span class="line">        <span class="keyword">var</span> attrVal = node.getAttribute(<span class="string">"v-html"</span>);</span><br><span class="line">        <span class="keyword">this</span>.recordRelativeDom(node,<span class="string">"innerHTML"</span>,attrVal,<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.hasAttribute(<span class="string">"v-text"</span>)) &#123;</span><br><span class="line">        <span class="keyword">var</span> attrVal = node.getAttribute(<span class="string">"v-text"</span>);</span><br><span class="line">        <span class="keyword">this</span>.recordRelativeDom(node,<span class="string">"innerText"</span>,attrVal,<span class="keyword">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.hasAttribute(<span class="string">"v-on:click"</span>)) &#123;</span><br><span class="line">        <span class="keyword">var</span> attrVal = node.getAttribute(<span class="string">"v-on:click"</span>);</span><br><span class="line">        node.addEventListener(<span class="string">"click"</span>, <span class="keyword">this</span>.$methods[attrVal].bind(<span class="keyword">this</span>.$data));  <span class="comment">//bind用于修正this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  recordRelativeDom:<span class="function"><span class="keyword">function</span>(<span class="params">node,attr,attrVal,vm</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> curData = <span class="keyword">this</span>.bindings[attrVal]</span><br><span class="line">    <span class="keyword">if</span>(curData)&#123;</span><br><span class="line">      curData.push(<span class="keyword">new</span> Notify(node, attr, attrVal, vm));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'变量'</span>+attrVal+<span class="string">'没有被注册!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  textToExp:<span class="function"><span class="keyword">function</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tar,</span><br><span class="line">        pieces = text.trim().split(<span class="regexp">/(&#123;&#123;.+?&#125;&#125;)/g</span>);</span><br><span class="line">    pieces = pieces.map(<span class="function"><span class="params">piece</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!!piece) &#123;</span><br><span class="line">        tar = piece.replace(<span class="regexp">/^&#123;&#123;|&#125;&#125;$/g</span>, <span class="string">''</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> tar.trim();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Notify</span>(<span class="params">el, attr, val, vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.el = el;</span><br><span class="line">  <span class="keyword">this</span>.attr = attr;</span><br><span class="line">  <span class="keyword">this</span>.val = val;</span><br><span class="line">  <span class="keyword">this</span>.vm = vm;</span><br><span class="line">  <span class="keyword">this</span>.updateView();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Notify.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>:Notify,</span><br><span class="line">  updateView:function() &#123;</span><br><span class="line">    <span class="keyword">this</span>.el[<span class="keyword">this</span>.attr] = <span class="keyword">this</span>.vm.$data[<span class="keyword">this</span>.val];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// index.html</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>120行代码理解双向绑定原理<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; ok &#125;&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; didi &#125;&#125; <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"加个！"</span> <span class="attr">v-on:click</span>=<span class="string">"click"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"msg"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"minivue.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> vm = <span class="keyword">new</span> miniVue(&#123;</span></span><br><span class="line"><span class="actionscript">      el: <span class="string">"#app"</span>,</span></span><br><span class="line">      data: &#123;</span><br><span class="line"><span class="handlebars"><span class="xml">        msg: "<span class="tag">&lt;<span class="name">span</span>&gt;</span>hello miniVue<span class="tag">&lt;/<span class="name">span</span>&gt;</span>",</span></span></span><br><span class="line"><span class="actionscript">        ok:<span class="string">'2333'</span>,</span></span><br><span class="line"><span class="actionscript">        didi:<span class="string">"滴滴一下"</span></span></span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        click() &#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.msg += <span class="string">"!"</span>;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        click1()&#123;</span><br><span class="line"><span class="actionscript">          <span class="keyword">this</span>.ok+=<span class="string">"?"</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;劫持对象属性的get/set特性是双向数据绑定的实现方式. 数据改变的时候, set中触发视图更新函数. 这种思路也就是常见的观察者模式. 手写双向数据绑定, 非常适合作为一道面试题, 它考察了 原型链/变量作用域/闭包/Dom/正则/设计模式等等
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>【快速教程】Web离线存储之indexedDB</title>
    <link href="https://thinkerchan.com/2019/04/12/indexeddb-quick/"/>
    <id>https://thinkerchan.com/2019/04/12/indexeddb-quick/</id>
    <published>2019-04-12T08:23:00.000Z</published>
    <updated>2020-07-20T06:28:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&lt;Javascript高级程序设计&gt;第23章的时候是介绍过indexedDB的, 今天单独把它重新写一遍. 后续给出的代码, 基本能够满足大部分人开发使用了.</p><p>为什么只写indexedDB? 我们可以打开chrome浏览器的控制台, 可以看到除了indexedDB实际上还有一种本地数据库方案 - Web SQL(它的语句和主流数据库操作语句没什么区别, 意味着前端还要另外学习sql语句), 但是Web SQL已经明确被放弃了, 所以indexedDB的存在是为了代替它.</p><p>indexedDB的思想是创建一套API, 方便保存和读取<strong>JS对象</strong>, 同时支持查询搜索. 这样的API设计, 能让前端开发者以更前端的方式进行对接.</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>通常我们操作传统数据库的时候是这么做的:</p><blockquote><p>创建数据库 -&gt; 创建表 -&gt; 操作数据</p></blockquote><p>而indexedDB有一点不一样的地方, 它并不是创建表, 而是创建一个叫做对象存储空间的<strong>对象</strong>(当然你也可以按照传统方式那么理解, 并无大碍).</p><p>看示例 , 你也可以点击<a href="https://test.thinkerchan.com/demo/indexeddb/index.html" target="_blank" rel="noopener">这里</a>运行下面的代码:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>indexedDB教程<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">table</span>&#123;<span class="attribute">border-collapse</span>:collapse;&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">th</span>,<span class="selector-tag">td</span>&#123;<span class="attribute">min-width</span>:<span class="number">150px</span>;<span class="attribute">text-align</span>:center;&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.red</span>&#123;<span class="attribute">color</span>:<span class="number">#FFF</span>;<span class="attribute">background-color</span>:<span class="number">#F00</span>;&#125;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>indexedDB快速教程-实现增删查改<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API"</span>&gt;</span>MDN indexedDB API<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"Juser"</span> <span class="attr">placeholder</span>=<span class="string">"姓名"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"Jphone"</span> <span class="attr">placeholder</span>=<span class="string">"电话"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"Jadd"</span>&gt;</span>增加<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"Jdel"</span>&gt;</span>删除数据库<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"JsearchTxt"</span> <span class="attr">placeholder</span>=<span class="string">"查询"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"Jsearch"</span>&gt;</span>点击查询<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>电话<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span> <span class="attr">id</span>=<span class="string">"Jtbd"</span>&gt;</span><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> index = &#123;</span></span><br><span class="line">      config:&#123;</span><br><span class="line"><span class="actionscript">        dbName:<span class="string">'demo'</span>,</span></span><br><span class="line"><span class="actionscript">        tbName:<span class="string">'tb'</span>,</span></span><br><span class="line"><span class="actionscript">        dbVersion:<span class="number">1</span>,   <span class="comment">//只有在修改数据表的字段的时候才需要更新版本</span></span></span><br><span class="line">      &#125;,</span><br><span class="line">      init()&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> C = <span class="keyword">this</span>.config;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 1.创建数据库</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> IDBRequest = <span class="built_in">window</span>.indexedDB.open(C.dbName,C.dbVersion);</span></span><br><span class="line">        /*</span><br><span class="line">          返回的IDBRequest对象有以下方法:</span><br><span class="line">          1.onblocked</span><br><span class="line">          2.onerror</span><br><span class="line">          3.onsuccess</span><br><span class="line">          4.onupgradeneeded: 优先级比 onsuccess 更高</span><br><span class="line">         */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// 2.创建对象存储空间 - 你可以理解成创建数据库的"表"</span></span></span><br><span class="line"><span class="javascript">        IDBRequest.onupgradeneeded = <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">var</span> _db = e.target.result;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// 如果不存在某个"表"就创建</span></span></span><br><span class="line">          if (!_db.objectStoreNames.contains(C.tbName)) &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> objectStore = _db.createObjectStore(C.tbName,&#123;</span></span><br><span class="line"><span class="actionscript">              keyPath:<span class="string">'id'</span>,</span></span><br><span class="line"><span class="actionscript">              autoIncrement: <span class="literal">true</span></span></span><br><span class="line">            &#125;)</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="comment">// 创建可以被索引的字段</span></span></span><br><span class="line"><span class="actionscript">            objectStore.createIndex(<span class="string">"user"</span>, <span class="string">"user"</span>, &#123; unique: <span class="literal">false</span> &#125;);</span></span><br><span class="line"><span class="actionscript">            objectStore.createIndex(<span class="string">"phone"</span>, <span class="string">"phone"</span>, &#123; unique: <span class="literal">false</span> &#125;);</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        IDBRequest.onsuccess = <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// e.target == IDBRequest; //true</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> db = e.target.result;</span></span><br><span class="line">          _this.db = db;</span><br><span class="line"><span class="actionscript">          _this.renderAll(db); <span class="comment">//展示数据库存储的数据</span></span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">        IDBRequest.onerror = <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// e.target == IDBRequest; //true</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(e.target.errorCode);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;,</span><br><span class="line">      tpl(obj)&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (!!<span class="built_in">Object</span>.keys(obj).length) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> tpl = <span class="string">`</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;<span class="name">tr</span> <span class="attr">id</span>=<span class="string">"Jtr$&#123;obj.id&#125;"</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">              <span class="tag">&lt;<span class="name">td</span> <span class="attr">data-key</span>=<span class="string">"user"</span>&gt;</span>$&#123;obj.user&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">              <span class="tag">&lt;<span class="name">td</span> <span class="attr">data-key</span>=<span class="string">"phone"</span>&gt;</span>$&#123;obj.phone&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">              &lt;td <span class="class"><span class="keyword">class</span></span>=<span class="string">"btns"</span>&gt;</span></span><br><span class="line"><span class="javascript">                &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"del"</span> data-type=<span class="string">"del"</span> data-id=<span class="string">"$&#123;obj.id&#125;"</span> &gt;删除&lt;<span class="regexp">/button&gt;</span></span></span><br><span class="line"><span class="javascript">                &lt;button <span class="class"><span class="keyword">class</span></span>=<span class="string">"modify"</span> data-type=<span class="string">"modify"</span> data-id=<span class="string">"$&#123;obj.id&#125;"</span> data-open=<span class="string">"0"</span>&gt;修改&lt;<span class="regexp">/button&gt;</span></span></span><br><span class="line"><span class="handlebars"><span class="xml">              <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span></span><br><span class="line">          `</span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> tpl;</span></span><br><span class="line"><span class="actionscript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">return</span> <span class="string">''</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      renderOne(obj)&#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> tpl = <span class="keyword">this</span>.tpl(obj);</span></span><br><span class="line"><span class="actionscript">        Jtbd.insertAdjacentHTML(<span class="string">'beforeend'</span>, tpl);</span></span><br><span class="line">      &#125;,</span><br><span class="line">      renderAll(db)&#123;</span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> C = <span class="keyword">this</span>.config;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span></span><br><span class="line">        if (db.objectStoreNames.contains(C.tbName)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">          <span class="comment">// 开始处理数据</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> transaction = db.transaction([C.tbName], <span class="string">"readwrite"</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">          <span class="comment">// transaction对象也有下面两个方法:</span></span></span><br><span class="line"><span class="actionscript">          <span class="comment">// transaction.oncomplete = (e)=&gt;&#123;</span></span></span><br><span class="line"><span class="actionscript">          <span class="comment">//   console.log('transaction.oncomplete')</span></span></span><br><span class="line"><span class="actionscript">          <span class="comment">// &#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">          <span class="comment">// transaction.onerror = (e)=&gt;&#123;</span></span></span><br><span class="line"><span class="actionscript">          <span class="comment">//   console.log('transaction.onerror')</span></span></span><br><span class="line"><span class="actionscript">          <span class="comment">// &#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">          <span class="comment">// 获取"表"里的数据</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> objectStore = transaction.objectStore(C.tbName);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> html = <span class="string">''</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">          <span class="comment">// 遍历"表"里面的数据</span></span></span><br><span class="line"><span class="javascript">          objectStore.openCursor().onsuccess = <span class="function">(<span class="params">e</span>)=&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> cursor = e.target.result;</span></span><br><span class="line">            if (cursor) &#123;</span><br><span class="line">              html = html + _this.tpl(cursor.value)</span><br><span class="line">              cursor.continue();</span><br><span class="line"><span class="actionscript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line">              Jtbd.innerHTML = html;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> handler = &#123;</span></span><br><span class="line"><span class="actionscript">      add(obj)&#123;  <span class="comment">//增</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> C = index.config;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 凡是要修改数据库, 都需要"告诉"数据库: 我要进行"transaction"(操作)了.</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> transaction = index.db.transaction([C.tbName], <span class="string">"readwrite"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> objectStore = transaction.objectStore(C.tbName);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> addRequest = objectStore.add(obj);  <span class="comment">//直接存储js对象就可以了</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        addRequest.onsuccess = <span class="function">(<span class="params">e</span>)=&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">//存进去之后, 还要获取id用于标记html元素</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> id = e.target.result;</span></span><br><span class="line">          index.renderOne(&#123;</span><br><span class="line">            id:id,</span><br><span class="line">            user:Juser.value,</span><br><span class="line">            phone:Jphone.value</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"><span class="actionscript">      del(id,cb)&#123; <span class="comment">// 删</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> C = index.config;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> transaction = index.db.transaction([C.tbName], <span class="string">"readwrite"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> objectStore = transaction.objectStore(C.tbName);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> _id = <span class="built_in">parseInt</span>(id);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> rmRequest = objectStore.delete(_id);</span></span><br><span class="line"><span class="javascript">        rmRequest.onsuccess = <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'删除完毕'</span>)</span></span><br><span class="line">          cb &amp;&amp; cb();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        rmRequest.onerror = <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'删除失败'</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"><span class="actionscript">      search(str)&#123;  <span class="comment">// 查</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> C = index.config;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> transaction = index.db.transaction([C.tbName], <span class="string">"readwrite"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> objectStore = transaction.objectStore(C.tbName);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// IDBKeyRange可以理解成一个生成查找范围的对象 有 only/bound/lowerBound/upperBound等几个方法</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> bound = IDBKeyRange.only(str);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> html = <span class="string">''</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="comment">// 前面创建了两个可以被索引的字段 user/phone, 这里我们查找user</span></span></span><br><span class="line"><span class="javascript">        objectStore.index(<span class="string">'user'</span>).openCursor(bound).onsuccess = <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> cursor = e.target.result;</span></span><br><span class="line">          if (cursor) &#123;</span><br><span class="line">            html = html + index.tpl(cursor.value)</span><br><span class="line">            cursor.continue();</span><br><span class="line"><span class="actionscript">          &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line">            Jtbd.innerHTML = html;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line"><span class="actionscript">      modify(id,obj)&#123;   <span class="comment">// 改</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> C = index.config;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> transaction = index.db.transaction([C.tbName], <span class="string">"readwrite"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> objectStore = transaction.objectStore(C.tbName);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> _id = <span class="built_in">parseInt</span>(id);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> modifyRequest = objectStore.get(_id);</span></span><br><span class="line"><span class="javascript">        modifyRequest.onsuccess = <span class="function">(<span class="params">e</span>)=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">let</span> res = e.target.result;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (<span class="keyword">typeof</span> res[key] != <span class="string">'undefined'</span>) &#123;</span></span><br><span class="line">              res[key] = obj[key];</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          objectStore.put(res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index.init();</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    Jadd.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> data = &#123;</span></span><br><span class="line">        user:Juser.value,</span><br><span class="line">        phone:Jphone.value</span><br><span class="line">      &#125;;</span><br><span class="line">      handler.add(data);</span><br><span class="line"><span class="actionscript">    &#125;, <span class="literal">false</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    Jtbd.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> curEle =  e.target</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> id = curEle.dataset.id;</span></span><br><span class="line"></span><br><span class="line">      if (!!id) &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> type = curEle.dataset.type;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">switch</span> (type) &#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">case</span> <span class="string">'del'</span>:</span></span><br><span class="line"><span class="actionscript">            handler.del(id,<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">              <span class="keyword">let</span> rmNode = <span class="built_in">document</span>.getElementById(<span class="string">'Jtr'</span>+id);</span></span><br><span class="line">              Jtbd.removeChild(rmNode);</span><br><span class="line">            &#125;)</span><br><span class="line"><span class="actionscript">            <span class="keyword">break</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">          <span class="keyword">case</span> <span class="string">'modify'</span>:</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> isOpen = curEle.dataset.open==<span class="string">'1'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> tr = <span class="built_in">document</span>.getElementById(<span class="string">'Jtr'</span>+id);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> tds = [].slice.call(tr.children);</span></span><br><span class="line"></span><br><span class="line">            if (isOpen) &#123;</span><br><span class="line"><span class="actionscript">              <span class="comment">// 更新数据</span></span></span><br><span class="line"><span class="actionscript">              curEle.innerHTML = <span class="string">'修改'</span></span></span><br><span class="line"><span class="actionscript">              curEle.dataset.open = <span class="string">'0'</span>;</span></span><br><span class="line"><span class="actionscript">              curEle.classList.remove(<span class="string">'red'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">              <span class="comment">// 声明一个变量存储修改后的数据</span></span></span><br><span class="line"><span class="javascript">              <span class="keyword">let</span> data = &#123;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">              <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>,len = tds.length<span class="number">-1</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> td = tds[i];</span></span><br><span class="line">                data[td.dataset.key] = td.innerText;</span><br><span class="line"><span class="actionscript">                td.removeAttribute(<span class="string">'contenteditable'</span>);</span></span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              handler.modify(id,data);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">              <span class="comment">//  打开编辑状态</span></span></span><br><span class="line"><span class="actionscript">              curEle.innerHTML = <span class="string">'保存'</span></span></span><br><span class="line"><span class="actionscript">              curEle.dataset.open = <span class="string">'1'</span>;</span></span><br><span class="line"><span class="actionscript">              curEle.classList.add(<span class="string">'red'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">              <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>,len = tds.length<span class="number">-1</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">let</span> td = tds[i];</span></span><br><span class="line"><span class="actionscript">                td.setAttribute(<span class="string">'contenteditable'</span>, <span class="literal">true</span>)</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">            <span class="keyword">break</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">          <span class="keyword">default</span>:</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">break</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">    &#125;, <span class="literal">false</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    Jsearch.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> str = JsearchTxt.value.trim();</span></span><br><span class="line">      if (!!str) &#123;</span><br><span class="line"><span class="actionscript">        Jtbd.innerHTML = <span class="string">''</span>;</span></span><br><span class="line">        handler.search(str);</span><br><span class="line"><span class="actionscript">      &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">        alert(<span class="string">'输入非空字符查找!'</span>);</span></span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">    &#125;, <span class="literal">false</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    Jdel.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">      index.db.close(); <span class="comment">//记得要关闭数据库才能删除, 否侧下列事件不会被触发</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> destoryRequest = <span class="built_in">window</span>.indexedDB.deleteDatabase(index.config.dbName);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">      destoryRequest.onerror = <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"Error deleting database."</span>);</span></span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">      destoryRequest.onsuccess = <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"Database deleted successfully"</span>);</span></span><br><span class="line">      &#125;;</span><br><span class="line"><span class="actionscript">    &#125;,<span class="literal">false</span>)</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&amp;lt;Javascript高级程序设计&amp;gt;第23章的时候是介绍过indexedDB的, 今天单独把它重新写一遍. 后续给出的代码, 基
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JS红皮书读书笔记-25-新兴的API</title>
    <link href="https://thinkerchan.com/2019/04/09/JSbook25/"/>
    <id>https://thinkerchan.com/2019/04/09/JSbook25/</id>
    <published>2019-04-09T08:10:00.000Z</published>
    <updated>2020-07-02T04:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a>requestAnimationFrame</h2><h3 id="早期动画循环"><a href="#早期动画循环" class="headerlink" title="早期动画循环"></a>早期动画循环</h3><p>JS的动画很长时间以来都是使用计时器setInterval来达成的。就像这样：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">updateAnimations</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        doAnimation1();</span><br><span class="line">        doAnimation2();</span><br><span class="line">    &#125;</span><br><span class="line">    setInterval(updateAnimations, <span class="number">100</span>);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p><h3 id="循环间隔的问题"><a href="#循环间隔的问题" class="headerlink" title="循环间隔的问题"></a>循环间隔的问题</h3><p>但是这样使用是有问题的，最大的问题就是时间间隔的问题。不能太长，否则看起来就会卡卡的，也不能太短，更新速度超过了屏幕的刷新速度会造成丢帧。</p><p>而且浏览器的计时器其实精度是有限的，精度最高的chrome为4ms。且在页面没有显示在屏幕上的时候，大多数浏览器会对计时器的运行频率做出限制。<br>这样的动画绘制机制就造成了绘制下一帧动画的时机我们并不能准确掌握。最好的结果应该是正好在屏幕刷新的那一刻绘制下一帧，也就是动画绘制的速度与电脑屏幕刷新速度一致。</p><p>于是Mozilla就带头提出了requestAnimationFrame这个API, 如今这个API已经被标准化:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateProgress</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"status"</span>);</span><br><span class="line">    div.style.width = (<span class="built_in">parseInt</span>(div.style.width, <span class="number">10</span>) + <span class="number">5</span>) + <span class="string">"%"</span>;</span><br><span class="line">    <span class="keyword">if</span> (div.style.width != <span class="string">"100%"</span>)&#123;</span><br><span class="line">        requestAnimationFrame(updateProgress);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(updateProgress);</span><br></pre></td></tr></table></figure></p><h2 id="Page-Visibility-API"><a href="#Page-Visibility-API" class="headerlink" title="Page Visibility API"></a>Page Visibility API</h2><p>用户是否真的正在与页面交互是我们需要知道的。如果页面最小化了或隐藏起来了，那么有些功能是可以停下来的。API由3部分组成：</p><ul><li>document.hidden：表示页面是否隐藏的布尔值</li><li>document.visibilityState：页面在后台，页面在前台，页面隐藏但正在被预览，页面在屏幕外执行预渲染处理</li><li>visibilitychange：在可见和不可见转换时触发的事件</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleVisibilityChange</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> output = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>),</span><br><span class="line">        msg;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.hidden || <span class="built_in">document</span>.msHidden || <span class="built_in">document</span>.webkitHidden)&#123;</span><br><span class="line">        msg = <span class="string">"Page is now hidden. "</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>()) + <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg = <span class="string">"Page is now visible. "</span> + (<span class="keyword">new</span> <span class="built_in">Date</span>()) + <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    output.innerHTML += msg;</span><br><span class="line">&#125;</span><br><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"msvisibilitychange"</span>, handleVisibilityChange);</span><br><span class="line">EventUtil.addHandler(<span class="built_in">document</span>, <span class="string">"webkitvisibilitychange"</span>, handleVisibilityChange);</span><br></pre></td></tr></table></figure><p>可以看到<a href="https://www.duowan.com/" target="_blank" rel="noopener">多玩官网</a> 就使用了上面相应的api, 页面没有显示的时候, title会改变.</p><h2 id="Geolocation-API"><a href="#Geolocation-API" class="headerlink" title="Geolocation API"></a>Geolocation API</h2><p>这个API让JS可以通过浏览器来获取用户的地理位置。当然，这是需要获得用户同意的。这个API在浏览器中的实现是navigator.geolocation。这个对象有3个方法：</p><ul><li>getCurrentPosition(successFn,failFn,configObj): 通常用这个API获取经纬度</li><li>watchPosition: getCurrentPosition的定时版本</li><li>clearWatch: 取消监控</li></ul><h2 id="File-API"><a href="#File-API" class="headerlink" title="File API"></a>File API</h2><p>不能直接访问用户计算机中的文件，一直都是 Web 应用开发中的一大障碍。2000 年以前，处理文件的唯一方式就是在表单中加入<input type="file">字段，仅此而已。File API（文件 API）的宗旨是为 Web 开发人员提供一种安全的方式，以便在客户端访问用户计算机中的文件，并更好地对这些文件执行操作。</p><p>File API 在表单中的文件输入字段的基础上，又添加了一些直接访问文件信息的接口。HTML5 在DOM 中为文件输入元素添加了一个 files 集合。在通过文件输入字段选择了一或多个文件时，files 集合中将包含一组 File 对象，每个 File 对象对应若一个文件。每个 File 对象都有下列只读属性。</p><ul><li>name：本地文件系统中的文件名。</li><li>size：文件的字节大小。</li><li>type：字符串，文件的 MIME 类型。</li><li>lastModifiedDate：字符串，文件上一次被修改的时间（只有 Chrome 实现了这个属性）。</li></ul><p>举个例子，通过侦听 change 事件并读取 files 集合就可以知道选择的每个文件的信息：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> filesList = <span class="built_in">document</span>.getElementById(<span class="string">"files-list"</span>);</span><br><span class="line">    EventUtil.addHandler(filesList, <span class="string">"change"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> info = <span class="string">""</span>,</span><br><span class="line">            output = <span class="built_in">document</span>.getElementById(<span class="string">"output"</span>),</span><br><span class="line">            files = EventUtil.getTarget(event).files,</span><br><span class="line">            i = <span class="number">0</span>,</span><br><span class="line">            len = files.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; len)&#123;</span><br><span class="line">            info += files[i].name + <span class="string">" ("</span> + files[i].type + <span class="string">", "</span> + files[i].size + <span class="string">" bytes)&lt;br&gt;"</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        output.innerHTML = info;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>上面的例子只是简单读取了文件的信息, 但是File API还能做得更多, FileReader能读取文件中的数据.</p><h3 id="FileReader类型"><a href="#FileReader类型" class="headerlink" title="FileReader类型"></a>FileReader类型</h3><p>FileReader 类型实现的是一种<strong>异步文件读取机制</strong>。可以把FileReader 想象成XMLHttpRequest， 区别只是它读取的是文件系统，而不是远程服务器。为了读取文件中的数据，FileReader 提供了如下几个方法。</p><ul><li>readAsText(file,encoding)：以纯文本形式读取文件，将读取到的文本保存在 result 属性中。第二个参数用于指定编码类型，是可选的。</li><li>readAsDataURL(file)：读取文件并将文件以数据 URI 的形式保存在 result 属性中。</li><li>readAsBinaryString(file)：读取文件并将一个字符串保存在 result 属性中，字符串中的每个字符表示一字节。</li><li>readAsArrayBuffer(file) ：读取文件并将一个包含文件内容的 ArrayBuffer 保存在result 属性中。</li></ul><p>我们来看这个例子:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>File API Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"EventUtil.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>This page is a demonstration of the File API. This works in the latest versions of all major browsers, but you may need to place this file on a web server to get it to work.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Select a file below.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"files-list"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> filesList = <span class="built_in">document</span>.getElementById(<span class="string">"files-list"</span>);</span></span><br><span class="line"><span class="actionscript">      EventUtil.addHandler(filesList, <span class="string">"change"</span>, <span class="function"><span class="keyword">function</span><span class="params">(event)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> info = <span class="string">""</span>,</span></span><br><span class="line"><span class="javascript">        output = <span class="built_in">document</span>.getElementById(<span class="string">"output"</span>),</span></span><br><span class="line"><span class="javascript">        progress = <span class="built_in">document</span>.getElementById(<span class="string">"progress"</span>),</span></span><br><span class="line">        files = EventUtil.getTarget(event).files,</span><br><span class="line"><span class="actionscript">        type = <span class="string">"default"</span>,</span></span><br><span class="line"><span class="actionscript">        reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="regexp">/image/</span>.test(files[<span class="number">0</span>].type))&#123;</span></span><br><span class="line">          reader.readAsDataURL(files[0]);</span><br><span class="line"><span class="actionscript">          type = <span class="string">"image"</span>;</span></span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line">          reader.readAsText(files[0]);</span><br><span class="line"><span class="actionscript">          type = <span class="string">"text"</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        reader.onerror = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">          output.innerHTML = <span class="string">"Could not read file, error code is "</span> + reader.error.code;</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        reader.onprogress = <span class="function"><span class="keyword">function</span><span class="params">(event)</span></span>&#123;</span></span><br><span class="line">          if (event.lengthComputable)&#123;</span><br><span class="line"><span class="actionscript">            progress.innerHTML = event.loaded + <span class="string">"/"</span> + event.total;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">        reader.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">          <span class="keyword">var</span> html = <span class="string">""</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">          <span class="keyword">switch</span>(type)&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">case</span> <span class="string">"image"</span>:</span></span><br><span class="line"><span class="actionscript">            html = <span class="string">"&lt;img src=\""</span> + reader.result + <span class="string">"\"&gt;"</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">case</span> <span class="string">"text"</span>:</span></span><br><span class="line">            html = reader.result;</span><br><span class="line"><span class="actionscript">            <span class="keyword">break</span>;</span></span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">          output.innerHTML = html;</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"progress"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pre</span> <span class="attr">id</span>=<span class="string">"output"</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="读取部分内容"><a href="#读取部分内容" class="headerlink" title="读取部分内容"></a>读取部分内容</h3><p>略, 使用场景比较少.</p><h3 id="对象URL"><a href="#对象URL" class="headerlink" title="对象URL"></a>对象URL</h3><p>对象 URL 也被称为 blob URL，指的是引用保存在 File 或 Blob 中数据的 URL。使用对象 URL 的好处是可以不必把文件内容读取到 JavaScript 中而直接使用文件内容。为此，只要在需要文件内容的地方提供对象 URL 即可。</p><p>使用方法:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.URL.createObjectURL(blob);<span class="comment">//传入file对象或者blob</span></span><br></pre></td></tr></table></figure><p>当我们用第三方域名的图片(绝对地址)再canvas.toDataURL导出base64的时候, 浏览器会提示canvas被污染. 虽然我们可以对图片设置<code>crossOrigin</code>属性, 但还是存在兼容问题.</p><p>此时利用window.URL.createObjectURL就能解决上述问题:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> imgsrc = <span class="string">'https://thinkerchan.com/images/avatar.jpg'</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">getBase64</span><span class="params">(img)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> can = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span></span><br><span class="line">      can.width = 200;</span><br><span class="line">      can.height = 200;</span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> ctx= can.getContext(<span class="string">'2d'</span>);</span></span><br><span class="line">      ctx.drawImage(img,0,0,200,200);</span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> base64 = can.toDataURL(<span class="string">"image/jpeg"</span>,<span class="number">0.6</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(base64)</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> base64;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">normalImg</span><span class="params">(src)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span></span><br><span class="line">      img.src =src;</span><br><span class="line"><span class="actionscript">      img.crossOrigin = <span class="string">''</span>;</span></span><br><span class="line"><span class="actionscript">      img.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">        demo.src = getBase64(img);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    normalImg(imgsrc); <span class="comment">// safari报错</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">getImageBlob</span><span class="params">(url, cb)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> xhr          = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="actionscript">      xhr.open(<span class="string">"get"</span>, url, <span class="literal">true</span>);</span></span><br><span class="line"><span class="actionscript">      xhr.responseType = <span class="string">"blob"</span>;</span></span><br><span class="line"><span class="actionscript">      xhr.onload       = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line">        if (xhr.status == 200) &#123;</span><br><span class="line">          cb &amp;&amp;cb(xhr.response);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      xhr.send();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    getImageBlob(imgsrc, <span class="function"><span class="keyword">function</span><span class="params">(res)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> src = <span class="built_in">window</span>.URL.createObjectURL(res);  <span class="comment">//利用这个能完美解决报错</span></span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span></span><br><span class="line">      img.src =src</span><br><span class="line"><span class="actionscript">      img.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">        demo.src = getBase64(img);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="读取拖放的文件"><a href="#读取拖放的文件" class="headerlink" title="读取拖放的文件"></a>读取拖放的文件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>File API Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"EventUtil.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>This page is a demonstration of the File API with Drag and Drop. This works in the latest versions of all major browsers, but you may need to place this file on a web server to get it to work.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"droptarget"</span> <span class="attr">style</span>=<span class="string">"width: 500px; height: 200px; background: silver"</span>&gt;</span></span><br><span class="line">    Drop some files here</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> droptarget = <span class="built_in">document</span>.getElementById(<span class="string">"droptarget"</span>);</span></span><br><span class="line"><span class="actionscript">      <span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span><span class="params">(event)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> info = <span class="string">""</span>,</span></span><br><span class="line"><span class="javascript">          output = <span class="built_in">document</span>.getElementById(<span class="string">"output"</span>),</span></span><br><span class="line">          files, i, len;</span><br><span class="line">        EventUtil.preventDefault(event);</span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (event.type == <span class="string">"drop"</span>)&#123;</span></span><br><span class="line">          files = event.dataTransfer.files;</span><br><span class="line">          i = 0;</span><br><span class="line">          len = files.length;</span><br><span class="line"><span class="actionscript">          <span class="keyword">while</span> (i &lt; len)&#123;</span></span><br><span class="line"><span class="actionscript">            info += files[i].name + <span class="string">" ("</span> + files[i].type + <span class="string">", "</span> + files[i].size + <span class="string">" bytes)&lt;br&gt;"</span>;</span></span><br><span class="line">            i++;</span><br><span class="line">          &#125;</span><br><span class="line">          output.innerHTML = info;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      EventUtil.addHandler(droptarget, <span class="string">"dragenter"</span>, handleEvent);</span></span><br><span class="line"><span class="actionscript">      EventUtil.addHandler(droptarget, <span class="string">"dragover"</span>, handleEvent);</span></span><br><span class="line"><span class="actionscript">      EventUtil.addHandler(droptarget, <span class="string">"drop"</span>, handleEvent);</span></span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pre</span> <span class="attr">id</span>=<span class="string">"output"</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用XHR上传文件"><a href="#使用XHR上传文件" class="headerlink" title="使用XHR上传文件"></a>使用XHR上传文件</h3><p>通过 File API 能够访问到文件内容，利用这一点就可以通过 XHR 直接把文件上传到服务器。当然啦，把文件内容放到 send()方法中，再通过 POST 请求，的确很容易就能实现上传。但这样做传递的是文件内容，因而服务器端必须收集提交的内容，然后再把它们保存到另一个文件中。</p><p>其实，更好的做法是以表单提交的方式来上传文件。这样使用 FormData 类型就很容易做到了（第 21 章介绍过 FormData）。首先，要创建一个 FormData对象，通过它调用 append()方法并传入相应的 File 对象作为参数。然后，再把 FormData 对象传递给 XHR 的 send()方法，结果与通过表单上传一模一样:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (event.type == <span class="string">"drop"</span>)&#123;</span><br><span class="line">  data = <span class="keyword">new</span> FormData();</span><br><span class="line">    files = event.dataTransfer.files;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    len = files.length;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len)&#123;</span><br><span class="line">        data.append(<span class="string">"file"</span> + i, files[i]);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">"post"</span>, <span class="string">"server.php"</span>, <span class="literal">true</span>);</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">            alert(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    xhr.send(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Web计时"><a href="#Web计时" class="headerlink" title="Web计时"></a>Web计时</h2><p>略, 性能优化的时候 再讲这个</p><h2 id="WebWorkers"><a href="#WebWorkers" class="headerlink" title="WebWorkers"></a>WebWorkers</h2><p>略, 另开一篇文章讲解</p><hr><p>本章完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;requestAnimationFrame&quot;&gt;&lt;a href=&quot;#requestAnimationFrame&quot; class=&quot;headerlink&quot; title=&quot;requestAnimationFrame&quot;&gt;&lt;/a&gt;requestAnimationFrame&lt;/
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://thinkerchan.com/categories/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS红皮书读书笔记-24-最佳实践</title>
    <link href="https://thinkerchan.com/2019/04/09/JSbook24/"/>
    <id>https://thinkerchan.com/2019/04/09/JSbook24/</id>
    <published>2019-04-09T08:09:00.000Z</published>
    <updated>2020-07-02T04:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h2><p>可维护性并不是js专有, 其他语言也有这么个说法, 可维护性最大的价值是让别人更好的在你代码的基础上维护和增减功能</p><h3 id="什么是可维护的代码"><a href="#什么是可维护的代码" class="headerlink" title="什么是可维护的代码"></a>什么是可维护的代码</h3><p>通常写入注释是为了让其他人更好地看懂自己写了啥, 不过我相信一条原则, 写的好的代码, 本身就是注释, 可维护的代码有以下几个特征: </p><ul><li>可理解: 容易被理解</li><li>直观:  直观可读</li><li>可适应: 代码以一种数据上的变化不需要完全重写原来的方法</li><li>可扩展: 在某种程度上考虑到将来要用到的功能</li><li>可调试</li></ul><h3 id="代码约定"><a href="#代码约定" class="headerlink" title="代码约定"></a>代码约定</h3><p>团队开发中通常约定代码风格, 例如缩进, 换行, 变量/函数命名大小写等, 注意不要起令人困惑或者没有意义的变量名, 也无需担心变量名过长, 因为可压缩.</p><h3 id="松散耦合"><a href="#松散耦合" class="headerlink" title="松散耦合"></a>松散耦合</h3><ol><li>解耦HTML/JS: 尽可能避免在html元素中直接写js</li><li>解耦Css/JS: 尽可能不要用js设置css</li><li>解耦JS逻辑: 每一个函数尽可能实现单一的功能(按照最小化分离原则)</li></ol><h3 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h3><ol><li>尊重对象所有权: <ul><li>不要修改默认类型的属性和方法</li><li>不要定义自己存在的方法</li></ul></li><li>避免全局对象: 前面作用域链也讲过, 全局作用域中保存的变量是最后查找的</li><li>尽量避免和null对比: 应该用更具体的类型或者实例进行对比</li><li>使用常量: 在ES5中我们用大写标识符表示常量</li></ol><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="注意作用域"><a href="#注意作用域" class="headerlink" title="注意作用域"></a>注意作用域</h3><ol><li>避免全局查找</li><li>避免with语句: with设计的目的是为了简写某个对象, 方便开发者操作属性, 但是这非常容易造成作用域混乱</li></ol><h3 id="选择正确方法"><a href="#选择正确方法" class="headerlink" title="选择正确方法"></a>选择正确方法</h3><ol><li><p>避免不必要的属性查找: 在计算机科学中，算法的复杂度是使用 O 符号来表示的。最简单、最快捷的算法是常数值即 O(1)。之后，算法变得越来越复杂并花更长时间执行。<br> 使用变量和数组要比访问对象上的属性更有效率，后者是一个 O(n)操作。对象上的任何属性查找都要比访问变量或者数组花费更长时间，因为必须在原型链中对拥有该名称的属性进行一次搜索。简而言之，属性查找越多，执行时间就越长。所以有必要, 就缓存某一个常用的值.</p><p> 下面这个表展示算法复杂度种类:</p><ul><li>O(1) : 不管有多少值，执行的时间都是恒定的。一般表示简单值和存储在变量中的值</li><li>O(log n): 总的执行时间和值的数量相关，但是要完成算法并不一定要获取每个值。例如：二分查找 </li><li>O(n) : 总执行时间和值的数量直接相关, 例如: 遍历某个数据中的所有元素</li><li>O(n^2) : 总执行时间和值的数量有关, 每个值至少获取n次, 例如:插入排序</li></ul></li><li>优化循环</li><li>展开循环</li><li>避免双重解释</li><li>其他注意事项<ul><li>原生方法最快 </li><li>switch比一系列的的if-else要快</li><li>位运算符比较快</li></ul></li></ol><h3 id="最小化语句"><a href="#最小化语句" class="headerlink" title="最小化语句"></a>最小化语句</h3><ol><li>多个变量声明: 可以使用一个var</li><li>插入迭代值 (个人认为可读性会降低)</li><li>使用数组和对象字面量: 简洁明了</li></ol><h3 id="优化DOM交互"><a href="#优化DOM交互" class="headerlink" title="优化DOM交互"></a>优化DOM交互</h3><ol><li>最小化现场更新: 优先使用document.createFragment</li><li>使用innerHTML创建元素更快</li><li>事件代理: 使用事件代理可以减少事件绑定, 提高性能</li><li>注意HTMLCollcetion: 循环的时候不要用它作为终止条件</li></ol><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>书上使用的一些工具比较旧, 所以不打算在这里讲解, 之后另开一篇文章</p><hr><p>本章完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;可维护性&quot;&gt;&lt;a href=&quot;#可维护性&quot; class=&quot;headerlink&quot; title=&quot;可维护性&quot;&gt;&lt;/a&gt;可维护性&lt;/h2&gt;&lt;p&gt;可维护性并不是js专有, 其他语言也有这么个说法, 可维护性最大的价值是让别人更好的在你代码的基础上维护和增减功能&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://thinkerchan.com/categories/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS红皮书读书笔记-23-离线应用与客户端存储</title>
    <link href="https://thinkerchan.com/2019/04/09/JSbook23/"/>
    <id>https://thinkerchan.com/2019/04/09/JSbook23/</id>
    <published>2019-04-09T08:08:00.000Z</published>
    <updated>2020-07-02T04:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>保持离线 Web 应用开发是 HTML5 的另一个重点。所谓离线 Web 应用，就是在设备不能上网的情况下仍然可以运行的应用。</p><p>开发离线 Web 应用需要几个步骤。首先是确保应用知道设备是否能上网，以便下一步执行正确的操作。然后，应用还必须能访问一定的资源（图像、JavaScript、CSS 等），只有这样才能正常工作。最后，必须有一块本地空间用于保存数据，无论能否上网都不妨碍读写。HTML5 及其相关的 API 让开发离线应用成为现实。</p><h2 id="离线检测"><a href="#离线检测" class="headerlink" title="离线检测"></a>离线检测</h2><p>HTML5提供了这个API检测设备是否离线:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isOn = navigator.onLine;<span class="comment">// true or false</span></span><br></pre></td></tr></table></figure><p>除 navigator.onLine 属性之外，为了更好地确定网络是否可用，HTML5 还定义了两个事件：<code>online</code> 和 <code>offline</code>。当网络从离线变为在线或者从在线变为离线时，分别触发这两个事件。这两个事件在 window 对象上触发。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有网络状况发生变化的时候才会触发以下事件</span></span><br><span class="line">windw.addEventListener(<span class="string">"online"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Online"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">windw.addEventListener(<span class="string">"offline"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Offline"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h2><p>看 <a href="http://www.w3school.com.cn/html5/html_5_app_cache.asp" target="_blank" rel="noopener">这篇文章</a>能够更清晰了解html5 appcache</p><h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie最初是用来在客户端储存会话信息的。该标准要求服务器对任意HTTP请求发送Set-Cookie HTTP头作为相应的一部分，其中包含会话的信息。例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: name=value</span><br><span class="line">Other-header: other-header-value</span><br></pre></td></tr></table></figure></p><p>这里就设置了一个以name为名称，value为值的一个cookie。<br>浏览器会储存这样的会话信息。并在这之后通过为每一个请求添加Cookie HTTP头部将信息发送回服务器：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /index.html HTTP/1.1</span><br><span class="line">Cookie: name=value</span><br><span class="line">Other-header: other-header-value</span><br></pre></td></tr></table></figure></p><p>这个信息对于服务器来说就可以唯一验证请求的身份</p><p><strong>限制</strong><br>cookie在性质上是绑定在特定域名下的。当设定了一个cookie，再给创建它的域名发送请求时都会包含这个cookie，而发向其他域的请求中并不会包含这个cookie。这个限制保证了cookie只能让批准的接受者访问。<br>每个域的cookie总数是有限的，各浏览器不同，最小的规定一个域有30个cookie，大小一般不超过4095B。<br>cookie的构成<br>cookie由浏览器保存的一下几块信息构成：</p><ul><li>名称：一个唯一确定cookie的名称</li><li>值：储存在cookie中的字符串值</li><li>域：这个cookie对哪个域有效，如果这个域包含子域，那对子域同样有有效。如果设定是没有明确指定，这个值会被认为是设置cookie的那个域</li><li>路径：用于指定向域中的哪个路径发送cookie，例如，你可以指定cookie只发送到<a href="http://www.baidu.com/img，那再访问www.baidu.com时就不会发送cookie。及时它们同域" target="_blank" rel="noopener">www.baidu.com/img，那再访问www.baidu.com时就不会发送cookie。及时它们同域</a></li><li>失效时间：cookie应该被删除的时间戳，默认浏览器会话结束就删除</li><li>安全标志：指定后，cookie只有在使用SSL连接时才会发送到服务器</li></ul><p>看例子:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com path=/; secure</span><br><span class="line">Other-header: other-header-value</span><br></pre></td></tr></table></figure></p><p><strong>JS中的cookie</strong><br>可以通过document.cookie返回如下格式的字符串:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.cookie;//name1=value1;name2=value2;name3=value3</span><br></pre></td></tr></table></figure></p><p>js中设置删除cookie不是很好操作, 我给出一个封装好的demo:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CookieUtil = &#123;</span><br><span class="line">  <span class="keyword">get</span>: function (name)&#123;</span><br><span class="line">    <span class="keyword">var</span> cookieName = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">"="</span>,</span><br><span class="line">      cookieStart = <span class="built_in">document</span>.cookie.indexOf(cookieName),</span><br><span class="line">      cookieValue = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (cookieStart &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="keyword">var</span> cookieEnd = <span class="built_in">document</span>.cookie.indexOf(<span class="string">";"</span>, cookieStart);</span><br><span class="line">      <span class="keyword">if</span> (cookieEnd == <span class="number">-1</span>)&#123;</span><br><span class="line">        cookieEnd = <span class="built_in">document</span>.cookie.length;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      cookieValue = <span class="built_in">decodeURIComponent</span>(<span class="built_in">document</span>.cookie.substring(cookieStart + cookieName.length, cookieEnd));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cookieValue;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: function (name, value, expires, path, domain, secure) &#123;</span><br><span class="line">    <span class="keyword">var</span> cookieText = <span class="built_in">encodeURIComponent</span>(name) + <span class="string">"="</span> +</span><br><span class="line">      <span class="built_in">encodeURIComponent</span>(value);</span><br><span class="line">    <span class="keyword">if</span> (expires <span class="keyword">instanceof</span> <span class="built_in">Date</span>) &#123;</span><br><span class="line">      cookieText += <span class="string">"; expires="</span> + expires.toGMTString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (path) &#123;</span><br><span class="line">      cookieText += <span class="string">"; path="</span> + path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (domain) &#123;</span><br><span class="line">      cookieText += <span class="string">"; domain="</span> + domain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (secure) &#123;</span><br><span class="line">      cookieText += <span class="string">"; secure"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.cookie = cookieText;</span><br><span class="line">  &#125;,</span><br><span class="line">  unset: <span class="function"><span class="keyword">function</span> (<span class="params">name, path, domain, secure</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.set(name, <span class="string">""</span>, <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">0</span>), path, domain, secure);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">CookieUtil.set(<span class="string">"book"</span>, <span class="string">"Professional JavaScript"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(CookieUtil.get(<span class="string">"book"</span>));</span><br><span class="line">CookieUtil.unset(<span class="string">"book"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(CookieUtil.get(<span class="string">"book"</span>));</span><br></pre></td></tr></table></figure></p><p><strong>子Cookie</strong><br>子Cookie方案的提出实际上是为了避免单域名对cookie个数的限制, 它的思想就是在单个cookie中存更多的名值对, 不过写这个笔记的时候, 市场上的主流是现代浏览器(谷歌内核), 没有单域名cookie个数限制, 这里不再讲解.</p><p><strong>关于Cookie的一些说明</strong></p><ul><li>cookie存储的数据不宜过多: 信息越多, 后端响应越慢</li><li>不要存敏感信息, 否则XSS泄露麻烦</li></ul><h3 id="IE用户数据"><a href="#IE用户数据" class="headerlink" title="IE用户数据"></a>IE用户数据</h3><p>略, 不要用</p><h3 id="Web存储机制"><a href="#Web存储机制" class="headerlink" title="Web存储机制"></a>Web存储机制</h3><p>目前来说主要是localStorage和sessionStorage. 书中有些内容以及不适合现在, 看 <a href="http://www.w3school.com.cn/html5/html_5_webstorage.asp" target="_blank" rel="noopener">这个例子</a>更简洁 </p><h3 id="IndexDB-WebSQL"><a href="#IndexDB-WebSQL" class="headerlink" title="IndexDB/WebSQL"></a>IndexDB/WebSQL</h3><p>书上只介绍了indexDB , 我们看 <a href="https://sdk.cn/news/7107" target="_blank" rel="noopener">这篇文章</a> , 更加直观介绍两种方案.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;保持离线 Web 应用开发是 HTML5 的另一个重点。所谓离线 Web 应用，就是在设备不能上网的情况下仍然可以运行的应用。&lt;/p&gt;
&lt;p&gt;开发离线 Web 应用需要几个步骤。首先是确保应用知道设备是否能上网，以便下一步执行正确的操作。然后，应用还必须能访问一定的资源（图
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://thinkerchan.com/categories/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS红皮书读书笔记-21-Ajax与Comet</title>
    <link href="https://thinkerchan.com/2019/04/09/JSbook21/"/>
    <id>https://thinkerchan.com/2019/04/09/JSbook21/</id>
    <published>2019-04-09T08:07:00.000Z</published>
    <updated>2020-07-02T04:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>Ajax，是对 Asynchronous JavaScript + XML 的简写。</p><p>Ajax 技术的核心是 XMLHttpRequest 对象（简称 XHR），这是由微软首先引入的一个特性，其他浏览器提供商后来都提供了相同的实现。在 XHR 出现之前，Ajax 式的通信必须借助一些 hack 手段来实现，大多数是使用隐藏的框架或内嵌框架。XHR 为向服务器发送请求和解析服务器响应提供了流畅的接口。能够以异步方式从服务器取得更多信息，意味若用户单击后，可以不必刷新页面也能取得新数据。也就是说，可以使用 XHR 对象取得新数据，然后再通过 DOM 将新数据插入到页面中。</p><p>另外，虽然名字中包含 XML 的成分，但 Ajax 通信与数据格式无关；这种技术就是无须刷新页面即可从服务器取得数据，但不一定是 XML 数据。</p><h2 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h2><p>IE5 是第一款引入 XHR 对象的浏览器。在 IE5 中，XHR 对象是通过 MSXML 库中的一个 ActiveX对象实现的。因此，在  IE 中可能会遇到三种不同版本的  XHR 对象，即  MSXML2.XMLHttp 、MSXML2.XMLHttp.3.0 和 MXSML2.XMLHttp.6.0。</p><p>针对旧版IE:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//适用于 IE7 之前的版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.activeXString != <span class="string">"string"</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> versions = [</span><br><span class="line">    <span class="string">"MSXML2.XMLHttp.6.0"</span>, </span><br><span class="line">    <span class="string">"MSXML2.XMLHttp.3.0"</span>, </span><br><span class="line">    <span class="string">"MSXML2.XMLHttp"</span></span><br><span class="line">    ], i, len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>,len=versions.length; i &lt; len; i++)&#123; </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> ActiveXObject(versions[i]); </span><br><span class="line">        <span class="built_in">arguments</span>.callee.activeXString = versions[i]; </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="built_in">arguments</span>.callee.activeXString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主流浏览器:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br></pre></td></tr></table></figure></p><p>创建好了这个xhr对象, 才能进行后续的操作.</p><h3 id="XHR的用法"><a href="#XHR的用法" class="headerlink" title="XHR的用法"></a>XHR的用法</h3><p>在使用 XHR 对象时，要调用的第一个方法是 open()，它接受 3 个参数：要发送的请求的类型（”get”、”post”等）、请求的 URL 和表示是否异步发送请求的布尔值。下面就是调用这个方法的例子。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"example.php"</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>这行代码会启动一个针对 example.php 的 GET 请求。有关这行代码，需要说明两点：一是 URL 相对于执行代码的当前页面（当然也可以使用绝对路径）；二是调用 open()方法并不会真正发送请求，而只是启动一个请求以备发送。</p><hr><p><strong>同步请求</strong></p><p>要发送特定的请求，还必须像下面这样调用 send()方法：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"example.txt"</span>, <span class="literal">false</span>); <span class="comment">//主要这个是同步请求</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);<span class="comment">//如不需要发送数据则不用传参数, 但是有些浏览器会报错, 故统一传null做兼容</span></span><br></pre></td></tr></table></figure><p>由于这次请求是同步的，JavaScript 代码会等到服务器响应之后再继续执行。在收到响应后，响应的数据会自动填充 XHR 对象的属性，相关的属性简介如下:</p><ul><li>responseText：作为响应主体被返回的文本。</li><li>responseXML：如果响应的内容类型是”text/xml”或”application/xml”，这个属性中将保存包含若响应数据的 XML DOM 文档。</li><li>status：响应的 HTTP 状态。</li><li>statusText：HTTP 状态的说明。</li></ul><p>同步请求常规用法:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr  = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">"GET"</span>,<span class="string">"api.txt"</span>,<span class="literal">false</span>);<span class="comment">// 同步请求</span></span><br><span class="line">    xhr.send(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> ( (xhr.status &gt;=<span class="number">200</span> &amp;&amp; xhr.status&lt;<span class="number">300</span>) || xhr.status == <span class="number">304</span>) &#123;<span class="comment">// 注意文明常用 xhr.status做检测, 比较靠谱</span></span><br><span class="line">      <span class="built_in">console</span>.log(xhr.statusText)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(xhr.status)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'api.txt get'</span>)<span class="comment">// 验证同步执行</span></span><br></pre></td></tr></table></figure></p><p>除非你硬要这么做, 否则开发中是几乎用不到ajax的同步请求.</p><hr><p><strong>异步请求</strong></p><p>多数情况下，我们还是要发送异步请求，才能让JavaScript 继续执行而不必等待响应。此时，可以检测 XHR 对象的 readyState 属性，该属性表示请求/响应过程的当前活动阶段。这个属性可取的值如下:</p><ul><li>0：未初始化。尚未调用 open()方法。</li><li>1：启动。已经调用 open()方法，但尚未调用 send()方法。</li><li>2：发送。已经调用 send()方法，但尚未接收到响应。</li><li>3：接收。已经接收到部分响应数据。</li><li>4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。</li></ul><p>只要 readyState 属性的值由一个值变成另一个值，都会触发一次 readystatechange 事件。可以利用这个事件来检测每次状态变化后 readyState 的值。通常，我们只对 readyState 值为 4 的阶段感兴趣，因为这时所有数据都已经就绪。</p><blockquote><p>不过，必须在调用 open()之前指定 onreadystatechange 事件处理程序才能确保跨浏览器兼容性。</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">asyncFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// xhr.onreadystatechange为异步方法, 原本放在前面或者后面影响不大, 但是因为浏览器兼容, 建议放xhr.open前面</span></span><br><span class="line">     xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//注意这里采用的是DOM0的写法, 保证最大兼容性</span></span><br><span class="line">       <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123; <span class="comment">// 没有用this代替xhr对象是因为兼容浏览器</span></span><br><span class="line">         <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">           <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">"Request was unsuccessful: "</span> + xhr.status);</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     xhr.open(<span class="string">"get"</span>, <span class="string">"api.txt"</span>, <span class="literal">true</span>);</span><br><span class="line">     xhr.send(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">//xhr.abort(); //如果有必要, 是可以再响应接受到之前取消这次异步请求.</span></span><br><span class="line">   &#125;</span><br><span class="line">   asyncFn();</span><br><span class="line"></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'api.txt get'</span>)<span class="comment">//证明它先输出,说明异步</span></span><br></pre></td></tr></table></figure><h3 id="Http头部信息"><a href="#Http头部信息" class="headerlink" title="Http头部信息"></a>Http头部信息</h3><p>每个 HTTP 请求和响应都会带有相应的头部信息，其中有的对开发人员有用，有的也没有什么用。</p><p>XHR 对象也提供了操作这两种头部（即请求头部和响应头部）信息的方法。默认情况下，在发送 XHR 请求的同时，还会发送下列头部信息。</p><ul><li>Accept：浏览器能够处理的内容类型。</li><li>Accept-Charset：浏览器能够显示的字符集。</li><li>Accept-Encoding：浏览器能够处理的压缩编码。</li><li>Accept-Language：浏览器当前设置的语言。</li><li>Connection：浏览器与服务器之间连接的类型。</li><li>Cookie：当前页面设置的任何 Cookie。</li><li>Host：发出请求的页面所在的域 。</li><li>Referer：发出请求的页面的 URI。注意，HTTP 规范将这个头部字段拼写错了，而为保证与规范一致，也只能将错就错了。（这个英文单词的正确拼法应该是 referrer。）</li><li>User-Agent：浏览器的用户代理字符串。</li></ul><p>虽然不同浏览器实际发送的头部信息会有所不同，但以上列出的基本上是所有浏览器都会发送的。使用 xhr.setRequestHeader()方法可以设置自定义的请求头部信息。这个方法接受两个参数：头部字段的名称和头部字段的值。并且这个方法要在xhr.open和xhr.send之间使用: </p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123; <span class="comment">// 没有用this代替xhr对象是因为兼容浏览器</span></span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(xhr.responseText);</span><br><span class="line"><span class="comment">// 获取响应头</span></span><br><span class="line">      <span class="keyword">var</span> hd = xhr.getResponseHeader(<span class="string">'userName'</span>);</span><br><span class="line">      <span class="keyword">var</span> hds = xhr.getAllResponseHeaders();</span><br><span class="line">      <span class="built_in">console</span>.log(hds)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Request was unsuccessful: "</span> + xhr.status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"api.txt"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">'userName'</span>, <span class="string">'testdog'</span>);  <span class="comment">//注意必须在中间, 但是建议开发者不要使用已有的字段名称, 防止后端获取失败, 因为有些浏览器禁止这么做</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get请求要注意的就是URL后面参数的问题, 保险起见, 参数值和参数名最好要用encodeURIComponent编码再传参</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"URL?v1=1&amp;v2=2"</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h3><p>与GET请求差异的是, POST请求更被期望于把数据作为请求的主体提交到后端.那么xhr.open的第一个参数自然就要改成”post”.</p><p>它可以传送任何你想发送到服务器的字符串.</p><p>默认情况下，服务器对 POST 请求和提交 Web 表单的请求并不会一视同仁。因此，服务器端必须有程序来读取发送过来的原始数据，并从中解析出有用的部分。不过，我们可以使用 XHR 来模仿表单提交：首先将 Content-Type 头部信息设置为 application/x-www-form-urlencoded，也就是表单提交时的内容类型，其次是以适当的格式创建一个字符串。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.open(<span class="string">"post"</span>,url,<span class="literal">true</span>);</span><br><span class="line">xhr.setRequestHeader(<span class="string">"Content-Type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>); </span><br><span class="line">xhr.send(formData);<span class="comment">// formData必须经过序列化</span></span><br></pre></td></tr></table></figure><p>这样就实现了ajax模拟表单提交.</p><h2 id="XMLHttpRequest2级"><a href="#XMLHttpRequest2级" class="headerlink" title="XMLHttpRequest2级"></a>XMLHttpRequest2级</h2><p>鉴于 XHR 已经得到广泛接受，成为了事实标准，W3C 也若手制定相应的标准以规范其行为。XMLHttpRequest 1 级只是把已有的 XHR 对象的实现细节描述了出来。而 XMLHttpRequest 2 级则进一步发展了 XHR。并非所有浏览器都完整地实现了 XMLHttpRequest 2 级规范，但所有浏览器都实现了它规定的部分内容。</p><h3 id="FormData"><a href="#FormData" class="headerlink" title="FormData"></a>FormData</h3><p>现代 Web 应用中频繁使用的一项功能就是表单数据的序列化，XMLHttpRequest 2 级为此定义了FormData 类型。FormData 为序列化表单以及创建与表单格式相同的数据（用于通过 XHR 传输）提供了便利。下面的代码创建了一个 FormData 对象，并向其中添加了一些数据。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData(); </span><br><span class="line">data.append(<span class="string">"name"</span>, <span class="string">"Nicholas"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以参照下面方式传参:</span></span><br><span class="line"><span class="keyword">var</span> data2 = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.forms[<span class="number">0</span>]);<span class="comment">//这样就更方便传递给xhr.send了.</span></span><br></pre></td></tr></table></figure></p><h3 id="超时设定"><a href="#超时设定" class="headerlink" title="超时设定"></a>超时设定</h3><p>虽然我们可以用xhr.status来判断是否提示请求错误, 但请求时间一旦过程, 显然有一个超时设定更为合理:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123; alert(xhr.responseText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        alert(<span class="string">"Request was unsuccessful: "</span> + xhr.status);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">    <span class="comment">//假设由 ontimeout 事件处理程序处理</span></span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"timeout.php"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.timeout = <span class="number">1000</span>; <span class="comment">//将超时设置为 1 秒钟（仅适用于 IE8+）</span></span><br><span class="line">xhr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"Request did not return in a second."</span>);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="overrideMimeType方法"><a href="#overrideMimeType方法" class="headerlink" title="overrideMimeType方法"></a>overrideMimeType方法</h3><p>Firefox 最早引入了 overrideMimeType()方法，用于重写 XHR 响应的 MIME 类型。这个方法后来也被纳入了 XMLHttpRequest 2 级规范。因为返回响应的 MIME 类型决定了 XHR 对象如何处理它，所以提供一种方法能够重写服务器返回的 MIME 类型是很有用的。</p><p>比如，服务器返回的 MIME 类型是 text/plain，但数据中实际包含的是 XML。根据 MIME 类型， 即使数据是 XML，responseXML 属性中仍然是 null。通过调用 overrideMimeType()方法，可以保证把响应当作 XML 而非纯文本来处理。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = createXHR(); </span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"text.php"</span>, <span class="literal">true</span>); </span><br><span class="line">xhr.overrideMimeType(<span class="string">"text/xml"</span>); <span class="comment">//必须在send()方法之前</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure></p><p>这个例子强迫 XHR 对象将响应当作 XML 而非纯文本来处理。</p><h2 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h2><p>Progress Events 规范是 W3C 的一个工作草案，定义了与客户端服务器通信有关的事件。这些事件最早其实只针对 XHR 操作，但目前也被其他 API 借鉴。有以下 6 个进度事件。</p><ul><li>loadstart：在接收到响应数据的第一个字节时触发。</li><li>progress：在接收响应期间持续不断地触发。</li><li>error：在请求发生错误时触发。</li><li>abort：在因为调用 abort()方法而终止连接时触发。</li><li>load：在接收到完整的响应数据时触发。</li><li>loadend：在通信完成或者触发 error、abort 或 load 事件后触发。</li></ul><p>事件触发顺序正如上面排序.</p><h3 id="load事件"><a href="#load事件" class="headerlink" title="load事件"></a>load事件</h3><p>load事件显然是用来代替readystatechange事件的, 这就意味着不用检查xhr.readyState, 也会有性能上提升.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//只要浏览器接收到服务器的响应，不管其状态如何，都会触发 load 事件。</span></span><br><span class="line">  <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">    alert(xhr.responseText);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">"Request was unsuccessful: "</span> + xhr.status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"altevents.php"</span>, <span class="literal">true</span>); </span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h3 id="progress事件"><a href="#progress事件" class="headerlink" title="progress事件"></a>progress事件</h3><p>Mozilla 对 XHR 的另一个革新是添加了 progress 事件，这个事件会在浏览器接收新数据期间周期性地触发。而 onprogress 事件处理程序会接收到一个 event 对象，其 target 属性是 XHR 对象，但包含若三个额外的属性：lengthComputable、position 和 totalSize。其中，lengthComputable 是一个表示进度信息是否可用的布尔值，position 表示已经接收的字节数，totalSize 表示根据Content-Length 响应头部确定的预期字节数。有了这些信息，我们就可以为用户创建一个进度指示器:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">    alert(xhr.responseText);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">"Request was unsuccessful: "</span> + xhr.status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 注意这个事件也要和onload事件一样写在xhr.open前面保证兼容</span></span><br><span class="line">xhr.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> divStatus = <span class="built_in">document</span>.getElementById(<span class="string">"status"</span>); </span><br><span class="line">  <span class="keyword">if</span> (event.lengthComputable)&#123;</span><br><span class="line">    divStatus.innerHTML = <span class="string">"Received "</span> + event.position + <span class="string">" of "</span> + event.totalSize +<span class="string">" bytes"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"altevents.php"</span>, <span class="literal">true</span>); </span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h2 id="跨域资源共享CORS"><a href="#跨域资源共享CORS" class="headerlink" title="跨域资源共享CORS"></a>跨域资源共享CORS</h2><p>通过 XHR 实现 Ajax 通信的一个主要限制，来源于跨域安全策略。默认情况下，XHR 对象只能访问与包含它的页面位于同一个域中的资源。</p><p>CORS（Cross-Origin Resource Sharing，跨源资源共享）是 W3C 的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想: <strong>就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败</strong>。</p><blockquote><p><strong>现代浏览器</strong>下的CORS看起来和Ajax代码没什么区别(实际也没啥区别), 它的关键点在于后端的支持. </p></blockquote><p>比如一个简单的使用 GET 或 POST 发送的请求，它没有自定义的头部，而主体内容是 text/plain。在发送该请求时，需要给它附加一个额外的 Origin 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。下面是 Origin 头部的一个示例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Origin: http://www.nczonline.net</span><br></pre></td></tr></table></figure></p><p>如果服务器认为这个请求可以接受，就在 Access-Control-Allow-Origin 头部中回发相同的源信息（如果是公共资源，可以回发”*”）。例如:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://www.nczonline.net</span><br><span class="line">Access-Control-Allow-Credentials: true;    // 是否接受用户凭据</span><br></pre></td></tr></table></figure><p>如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。注意，请求和响应都不包含 cookie 信息。</p><h3 id="IE对CORS的实现"><a href="#IE对CORS的实现" class="headerlink" title="IE对CORS的实现"></a>IE对CORS的实现</h3><p>以下是 XDR 与 XHR 的一些不同之处。</p><ul><li>cookie 不会随请求发送，也不会随响应返回。</li><li><strong>只能</strong>设置请求头部信息中的 Content-Type 字段。</li><li>不能访问响应头部信息。</li><li>只支持 GET 和 POST 请求。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xdr = <span class="keyword">new</span> XDomainRequest(); </span><br><span class="line">xdr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(xdr.responseText);</span><br><span class="line">&#125;;</span><br><span class="line">xdr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  alert(<span class="string">"An error occurred."</span>);</span><br><span class="line">&#125;;</span><br><span class="line">xdr.timeout = <span class="number">1000</span>; </span><br><span class="line">xdr.ontimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"Request took too long."</span>);</span><br><span class="line">&#125;;</span><br><span class="line">xdr.open(<span class="string">"get"</span>, <span class="string">"http://www.somewhere-else.com/page/"</span>); </span><br><span class="line">xdr.contentType = <span class="string">"application/x-www-form-urlencoded"</span>;  <span class="comment">//只能在这里设置</span></span><br><span class="line">xdr.send(<span class="string">"name1=value1&amp;name2=value2"</span>);</span><br></pre></td></tr></table></figure></li></ul><h3 id="其他浏览器对CORS的实现"><a href="#其他浏览器对CORS的实现" class="headerlink" title="其他浏览器对CORS的实现"></a>其他浏览器对CORS的实现</h3><p>现代浏览器都通过 XMLHttpRequest 对象实现了对 CORS 的原生支持。在尝试打开不同来源的资源时，无需额外编写代码就可以触发这个行为。要请求位于另一个域中的资源，使用标准的 XHR 对象并在 open()方法中传入绝对 URL 即可，例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(); </span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> ((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status == <span class="number">304</span>)&#123; </span><br><span class="line">      alert(xhr.responseText);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      alert(<span class="string">"Request was unsuccessful: "</span> + xhr.status);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;    <span class="comment">// 如果要带用户凭据则设置这个属性</span></span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"http://www.somewhere-else.com/page/"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>与 IE 中的 XDR 对象不同，通过跨域 XHR 对象可以访问 status 和 statusText 属性，而且还支持同步请求。跨域 XHR 对象也有一些限制，但为了安全这些限制是必需的。以下就是这些限制。</p><ul><li><strong>不能</strong>使用 setRequestHeader()设置自定义头部。</li><li><strong>默认情况不能</strong>发送和接收 cookie。</li><li>调用 getAllResponseHeaders()方法总会返回空字符串。</li><li>由于无论同源请求还是跨源请求都使用相同的接口，因此对于本地资源，最好使用相对 URL，在访问远程资源时再使用绝对 URL。这样做能消除歧义，避免出现限制访问头部或本地 cookie 信息等问题。</li></ul><h3 id="Preflighted-Request"><a href="#Preflighted-Request" class="headerlink" title="Preflighted Request"></a>Preflighted Request</h3><p>字面理解可以翻译成: 预检请求.  </p><p>书中讲得不是很好, 我按照自己的意思解释下:<br>浏览器的同源策略浏览器会限制从脚本发起的跨域HTTP请求，像XMLHttpRequest和Fetch都遵循同源策略。</p><p>浏览器限制跨域请求一般有两种方式：</p><ol><li>浏览器限制发起跨域请求</li><li>跨域请求可以正常发起，但是返回的结果被浏览器拦截了</li></ol><p>一般浏览器都是第二种方式限制跨域请求，那就是说请求已到达服务器，并有可能对数据库里的数据进行了操作，但是返回的结果被浏览器拦截了，那么我们就获取不到返回结果，这是一次失败的请求，但是可能对数据库里的数据产生了影响。</p><p>为了防止这种情况的发生，规范要求，对这种可能对服务器数据产生副作用的HTTP请求方法，浏览器必须先使用OPTIONS方法发起一个预检请求，从而获知服务器是否允许该跨域请求：如果允许，就发送带数据的真实请求；如果不允许，则阻止发送带数据的真实请求。</p><p> 点击此处可以查阅预检请求的触发条件: <a href="https://my.oschina.net/ososchina/blog/672556" target="_blank" rel="noopener">https://my.oschina.net/ososchina/blog/672556</a> </p><h3 id="带凭据的请求"><a href="#带凭据的请求" class="headerlink" title="带凭据的请求"></a>带凭据的请求</h3><p>参考上面的代码, 分别前后端加代码</p><ul><li>前端: xhr.withCredentials = true</li><li>后端: Access-Control-Allow-Credentials: true</li></ul><h3 id="跨浏览器的CORS"><a href="#跨浏览器的CORS" class="headerlink" title="跨浏览器的CORS"></a>跨浏览器的CORS</h3><p>做兼容处理, 代码略</p><h2 id="其他跨域技术"><a href="#其他跨域技术" class="headerlink" title="其他跨域技术"></a>其他跨域技术</h2><p>在 CORS 出现以前，要实现跨域 Ajax 通信颇费一些周折。开发人员想出了一些办法，利用 DOM 中能够执行跨域请求的功能，在不依赖 XHR 对象的情况下也能发送某种请求。虽然 CORS 技术已经无处不在，但开发人员自已发明的这些技术仍然被广泛使用，毕竟这样不需要修改服务器端代码</p><h3 id="图像ping"><a href="#图像ping" class="headerlink" title="图像ping"></a>图像ping</h3><p>上述第一种跨域请求技术是使用<img>标签。我们知道，一个网页可以从任何网页中加载图像，不用担心跨域不跨域。这也是在线广告跟踪浏览量的主要方式。正如第 13 章讨论过的，也可以动态地创建图像，使用它们的 onload 和 onerror 事件处理程序来确定是否接收到了响应。</p><p>动态创建图像经常用于图像 Ping。图像 Ping 是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或 204 响应。通过图像 Ping，浏览器得不到任何具体的数据，但通过侦听 load 和 error 事件，它能知道响应是什么时候接收到的。来看下面的例子。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.onload = img.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"Done!"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">img.src = <span class="string">"http://www.example.com/test?name=Nicholas"</span>;</span><br></pre></td></tr></table></figure></p><p>这里创建了一个 Image 的实例，然后将 onload 和 onerror 事件处理程序指定为同一个函数。这样无论是什么响应，只要请求完成，就能得到通知。请求从设置 src 属性那一刻开始，而这个例子在请求中发送了一个 name 参数。</p><p>图像 Ping 最常用于跟踪用户点击页面或动态广告曝光次数。图像 Ping 有两个主要的缺点，一是只能发送 GET 请求，二是无法访问服务器的响应文本。因此，图像 Ping 只能用于浏览器与服务器间的单向通信。</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP全称JSON with padding, 是应用 JSON 的一种新方法， 在后来的 Web 服务中非常流行。JSONP 看起来与 JSON 差不多.<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">callback(&#123;<span class="string">"name"</span>:<span class="string">"testdog"</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>原理实际上就是先在网站页面上定义好某个函数, 然后用动态创建script标签的方式把函数句给添加进来, 达到立即执行的效果.</p><p>值得注意的是你用的JSONP是从其他域请求回来的JS代码, 所以要注意安全问题.</p><h3 id="Comet"><a href="#Comet" class="headerlink" title="Comet"></a>Comet</h3><p>Comet是Dojo创始人Alex Russell提出的一种叫法, 指的是一种跟高级的Ajax技术(有人称之为服务器推送).</p><p>Ajax 是一种从页面向服务器请求数据的技术，而 Comet 则是一种服务器向页面推送数据的技术。Comet 能够让信息近乎实时地被推送到页面上，非常适合处理体育比赛的分数和股票报价。</p><p>有两种实现 Comet 的方式：</p><ul><li>长轮询: 长轮询和传统轮询(也称为短轮询: 用定时器和xhr就能实现)相反.</li><li>Http流: 就是浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据。</li></ul><p>我们依次给到长短轮询的代码</p><hr><p><strong>短轮询示例</strong>:</p><p>shortpolling.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>短轮询(传统轮询)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">ajax</span><span class="params">(configObj)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> c = configObj;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="actionscript">      xhr.open(c.method,c.url,<span class="literal">true</span>);</span></span><br><span class="line"><span class="actionscript">      xhr.send(<span class="literal">null</span>)</span></span><br><span class="line"><span class="actionscript">      xhr.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        if ((xhr.status &gt;=200 &amp;&amp; xhr.status <span class="tag">&lt;<span class="name">300)||xhr.status</span> ==<span class="string">304)</span> &#123;</span></span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">var</span> res = <span class="built_in">JSON</span>.parse(xhr.responseText)</span></span><br><span class="line">          c.sucess &amp;&amp; c.sucess(res);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    setInterval(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">      ajax(&#123;</span><br><span class="line"><span class="actionscript">        method:<span class="string">'get'</span>,</span></span><br><span class="line"><span class="actionscript">        url:<span class="string">'shortpolling.php'</span>,</span></span><br><span class="line"><span class="actionscript">        sucess:<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">'服务器响应时间:'</span>,data.res)</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,1000)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>shortpolling.php<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">  header(<span class="string">'Content-type: text/json'</span>);</span><br><span class="line">  $arr = [</span><br><span class="line">      <span class="string">'res'</span> =&gt; time()</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">echo</span> json_encode($arr);</span><br><span class="line"> <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></p><hr><p><strong>长轮询示例</strong>:<br>longpolling.html<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>长轮询<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 实现一个长轮询</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">ajax</span><span class="params">(configObj)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> c = configObj;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="actionscript">      xhr.open(c.method,c.url,<span class="literal">true</span>);</span></span><br><span class="line"><span class="actionscript">      xhr.send(<span class="literal">null</span>)</span></span><br><span class="line"><span class="actionscript">      xhr.onload = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">        if ((xhr.status &gt;=200 &amp;&amp; xhr.status <span class="tag">&lt;<span class="name">300)||xhr.status</span> ==<span class="string">304)</span> &#123;</span></span></span></span><br><span class="line"><span class="actionscript">          <span class="keyword">var</span> res = (xhr.responseText)</span></span><br><span class="line">          c.sucess &amp;&amp; c.sucess(res);</span><br><span class="line"><span class="actionscript">          xhr.onload = <span class="literal">null</span>; <span class="comment">// 性能优化</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="actionscript">      xhr.onerror = <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e)</span></span><br><span class="line">        c.fail &amp;&amp; c.fail(xhr,xhr.responseText,e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">longPolling</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> _fn = <span class="built_in">arguments</span>.callee;</span></span><br><span class="line">      ajax(&#123;</span><br><span class="line"><span class="actionscript">        method:<span class="string">'get'</span>,</span></span><br><span class="line"><span class="javascript">        url:<span class="string">'longpolling.php?time='</span>+<span class="built_in">Date</span>.parse(<span class="keyword">new</span> <span class="built_in">Date</span>())/<span class="number">1000</span>,</span></span><br><span class="line"><span class="actionscript">        sucess:<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(data)</span></span><br><span class="line">          _fn();</span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        fail:<span class="function"><span class="keyword">function</span><span class="params">(xhr,responseText,err)</span></span>&#123;</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    longPolling();</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>longpolling.php<br><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">'Content-type: application/json'</span>);</span><br><span class="line">set_time_limit(<span class="number">0</span>);<span class="comment">//无限请求超时时间</span></span><br><span class="line">$time = $_GET[<span class="string">'time'</span>];</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">  sleep(<span class="number">3</span>);</span><br><span class="line">  $i = rand(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">  <span class="keyword">if</span> ($i &gt; <span class="number">0</span> &amp;&amp; $i &lt; <span class="number">50</span>) &#123;</span><br><span class="line">    $responseTime = time();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> json_encode(<span class="keyword">array</span>(<span class="string">"resultNum"</span>=&gt;$i,<span class="string">"responseTime"</span>=&gt;$responseTime-$time));</span><br><span class="line">    <span class="keyword">exit</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 模拟没有数据变化，将休眠 hold住连接</span></span><br><span class="line">    sleep(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">echo</span> json_encode(<span class="keyword">array</span>(<span class="string">"noData"</span>=&gt;<span class="keyword">true</span>));</span><br><span class="line">    <span class="keyword">exit</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>长短轮询的差别可以通过浏览器控制点的请求面板看他们之间的差异. </p><hr><p><strong>HTTP流</strong> :<br>http流是Comet的另一种实现, 它的思路就是若不断从服务器接收数据，readyState 的值会周期性地变为 3。当 readyState 值变为 3 时，responseText 属性中就会保存接收到的所有数据。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTTP Streaming Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>This example must be run on a server to work properly and will not work in IE.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">createStreamingClient</span><span class="params">(url, progress, finished)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest(),</span></span><br><span class="line">        received = 0;</span><br><span class="line"><span class="actionscript">      xhr.open(<span class="string">"get"</span>, url, <span class="literal">true</span>);</span></span><br><span class="line"><span class="actionscript">      xhr.onreadystatechange = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> result;</span></span><br><span class="line">        if (xhr.readyState == 3)&#123;</span><br><span class="line"><span class="actionscript">          <span class="comment">//get only the new data and adjust counter</span></span></span><br><span class="line">          result = xhr.responseText.substring(received);</span><br><span class="line">          received += result.length;</span><br><span class="line"><span class="actionscript">          <span class="comment">//call the progress callback</span></span></span><br><span class="line">          progress(result);</span><br><span class="line"><span class="actionscript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123;</span></span><br><span class="line">          finished(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="actionscript">      xhr.send(<span class="literal">null</span>);</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> xhr;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> client = createStreamingClient(<span class="string">"streaming.php"</span>, <span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">      alert(<span class="string">"Received: "</span> + data);</span></span><br><span class="line"><span class="actionscript">    &#125;, <span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">      alert(<span class="string">"Done!"</span>);</span></span><br><span class="line">    &#125;);</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="服务器发送事件"><a href="#服务器发送事件" class="headerlink" title="服务器发送事件"></a>服务器发送事件</h3><p>SSE（Server-Sent Events，服务器发送事件）是围绕只读 Comet 交互推出的 API 或者模式。SSE API 用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的 MIME 类型必须是 text/event-stream，而且是浏览器中的 JavaScript API 能解析格式输出。SSE 支持短轮询、长轮询和 HTTP 流，而且能在断开连接时自动确定何时重新连接。</p><p>比起之前comet的实现, 操作自然更加简便.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> src = <span class="keyword">new</span> EventSource(<span class="string">"api.php"</span>)</span><br><span class="line">    src.onmessage=<span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> data = evt.data;</span><br><span class="line">      <span class="built_in">console</span>.log(data)</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>注意，传入的 URL 必须与创建对象的页面同源（相同的 URL 模式、域及端口）。EventSource 的实例有一个 readyState 属性，值为 0 表示正连接到服务器，值为 1 表示打开了连接，值为 2 表示关闭了连接。</p><p>相关API:</p><ul><li>open：在建立连接时触发。</li><li>message：在从服务器接收到新事件时触发。</li><li>error：在无法建立连接时触发。</li></ul><p>默认情况下，EventSource 对象会保持与服务器的活动连接。如果连接断开，还会重新连接。这就意味若 SSE 适合长轮询和 HTTP 流。如果想强制立即断开连接并且不再重新连接，可以调用 close() 方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">src.close();</span><br></pre></td></tr></table></figure><h3 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h3><p>Web Sockets 的目标是在一个单独的持久连接上提供全双工、双向通信。在 JavaScript 中创建了 Web Socket 之后，会有一个 HTTP 请求发送到浏览器以发起连接。<strong>在取得服务器响应后</strong>，建立的连接会从 HTTP 协议交换为 Web Socket 协议。(<code>ws://</code> or <code>wss://</code>)</p><p>也就是说，使用标准的 HTTP 服务器无法实现 Web Sockets，只有支持这种协议的专门服务器才能正常工作。</p><p>使用上述协议而非HTTP协议的好处是，能够在客户端和服务器之间发送非常少量的数据，而不必担心 HTTP 那样字节级的开销。由于传递的数据包很小，因此 Web Sockets 非常适合移动应用。毕竟对移动应用而言，带宽和网络延迟都是关键问题。</p><ol><li>Web Sockets API<br>要创建 Web Socket，先实例一个 WebSocket 对象并传入要连接的 URL：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://www.example.com/server.php"</span>);<span class="comment">//必须是绝对地址</span></span><br></pre></td></tr></table></figure></li></ol><p>注意，必须给 WebSocket 构造函数传入绝对 URL。同源策略对 Web Sockets 不适用，因此可以通过它打开到任何站点的连接。</p><p>实例化了 WebSocket 对象后，浏览器就会马上尝试创建连接。与 XHR 类似，WebSocket 也有一个表示当前状态的 readyState 属性。不过，这个属性的值与 XHR 并不相同，而是如下所示:</p><ul><li>WebSocket.OPENING (0)：正在建立连接。</li><li>WebSocket.OPEN (1)：已经建立连接。</li><li>WebSocket.CLOSING (2)：正在关闭连接。</li><li>WebSocket.CLOSE (3)：已经关闭连接。</li></ul><p>WebSocket 没有 readystatechange 事件；不过，它有其他事件，对应若不同的状态。readyState 的值永远从 0 开始。<br>要关闭 Web Socket 连接，可以在任何时候调用 close()方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">socket.close(); <span class="comment">//readyState 的值立即变为 2（正在关闭），而在关闭连接后就会变成 3。</span></span><br></pre></td></tr></table></figure><ol start="2"><li>发送和接收数据</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = <span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">var</span> message = &#123;</span><br><span class="line">  time: <span class="keyword">new</span> <span class="built_in">Date</span>(), </span><br><span class="line">  text: <span class="string">"Hello world!"</span>,</span><br><span class="line">  clientId: <span class="string">"asdfp8734rew"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">"ws://www.example.com/server.php"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送数据</span></span><br><span class="line">socket.send(data);  <span class="comment">//只接受纯文本数据</span></span><br><span class="line"><span class="comment">// socket.send(JSON.stringify(message)); // 复杂数据必须经过序列化 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//接受数据</span></span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">var</span> data = event.data;  <span class="comment">//返回的也是字符串</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他API</span></span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"Connection established."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  alert(<span class="string">"Connection error."</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  alert(<span class="string">"Connection closed."</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="SSE-与WebSockets"><a href="#SSE-与WebSockets" class="headerlink" title="SSE 与WebSockets"></a>SSE 与WebSockets</h3><p>面对某个具体的用例，在考虑是使用 SSE 还是使用 Web Sockets 时，可以考虑如下几个因素。首先， 你是否有自由度建立和维护 Web Sockets 服务器？因为 Web Socket 协议不同于 HTTP，所以现有服务器不能用于 Web Socket 通信。SSE 倒是通过常规 HTTP 通信，因此现有服务器就可以满足需求。</p><p>第二个要考虑的问题是到底需不需要双向通信。如果用例只需读取服务器数据（如比赛成绩），那么 SSE 比较容易实现。如果用例必须双向通信（如聊天室），那么 Web  Sockets 显然更好。别忘了，在不能选择 Web Sockets 的情况下，组合 XHR 和 SSE 也是能实现双向通信的</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p>为确保通过 XHR 访问的 URL 安全，通行的做法就是验证发送请求者是否有权限访问相应的资源。有下列几种方式可供选择。</p><ul><li>要求以 SSL 连接来访问可以通过 XHR 请求的资源。</li><li>要求每一次请求都要附带经过相应算法计算得到的验证码。请注意，下列措施对防范 CSRF 攻击不起作用。</li><li>要求发送 POST 而不是 GET 请求——很容易改变。</li><li>检查来源 URL 以确定是否可信——来源记录很容易伪造。</li><li>基于 cookie 信息进行验证——同样很容易伪造。<br>XHR 对象也提供了一些安全机制，虽然表面上看可以保证安全，但实际上却相当不可靠。实际上， 前面介绍的 open()方法还能再接收两个参数：要随请求一起发送的用户名和密码。带有这两个参数的请求可以通过 SSL 发送给服务器上的页面, 但是要禁止明文get请求发送账号密码.</li></ul><hr><p>本文完, 以下有两篇文章可以查阅</p><p> <a href="https://segmentfault.com/a/1190000011549088" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011549088</a><br> <a href="https://segmentfault.com/a/1190000000423616#articleHeader8" target="_blank" rel="noopener">https://segmentfault.com/a/1190000000423616#articleHeader8</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Ajax，是对 Asynchronous JavaScript + XML 的简写。&lt;/p&gt;
&lt;p&gt;Ajax 技术的核心是 XMLHttpRequest 对象（简称 XHR），这是由微软首先引入的一个特性，其他浏览器提供商后来都提供了相同的实现。在 XHR 出现之前，Aja
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://thinkerchan.com/categories/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS红皮书读书笔记-22-高级技巧</title>
    <link href="https://thinkerchan.com/2019/04/09/JSbook22/"/>
    <id>https://thinkerchan.com/2019/04/09/JSbook22/</id>
    <published>2019-04-09T08:07:00.000Z</published>
    <updated>2020-07-02T04:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h2><h3 id="安全类型的检测"><a href="#安全类型的检测" class="headerlink" title="安全类型的检测"></a>安全类型的检测</h3><p>JavaScript 内置的类型检测机制并非完全可靠。事实上，发生错误否定及错误肯定的情况也不在少数。比如说 typeof 操作符吧，由于它有一些无法预知的行为，经常会导致检测数据类型时得到不靠谱的结果。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isArray = value <span class="keyword">instanceof</span> <span class="built_in">Array</span>;</span><br></pre></td></tr></table></figure></p><p>这个表达式要是想返回true，value必须是个数组，且必须与Array构造函数在同一个全局作用域中，如果value是另一个全局作用域(其他frame)中定义的数组，那这个表达式返回false。</p><p>检测某个对象是原生的还是开发人员自定义的对象时也会有问题。因为浏览器开始原生支持JSON了，而有些开发人员还是在用第三方库来实现JSON，这个库里会有全局的JSON对象，这样想确定JSON对象是不是原生的就麻烦了。<br>解决这些问题的办法就是使用Object的toString方法，这个方法会返回一个[object NativeConstructorName]格式的字符串。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) == <span class="string">"[object Array]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFunction</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) == <span class="string">"[object Function]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isRegExp</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) == <span class="string">"[object RegExp]"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过要注意的是，对于在IE中任何以COM形式实现的函数，isFunction()都会返回false。<br>对于JSON是否为原生的问题可以这样：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> isNativeJSON = <span class="built_in">window</span>.JSON &amp;&amp; <span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">JSON</span>) == <span class="string">"[object JSON]"</span>;</span><br></pre></td></tr></table></figure></p><h3 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h3><p>第六章的时候我们将了构造函数, 我们来回顾一下一个例子:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure></p><p>如果不使用new运算符, 那么name, age, job三个属性会被直接挂在到window对象上, 为了防止普通调用的过程中出现这种疏忽,  我们有必要做一道保险:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.job = job;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Person(name, age, job); <span class="comment">//保险</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">alert(<span class="built_in">window</span>.name);      <span class="comment">//""</span></span><br><span class="line">alert(person1.name);     <span class="comment">//"Nicholas"</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Shelby"</span>, <span class="number">34</span>, <span class="string">"Ergonomist"</span>);</span><br><span class="line">alert(person2.name);     <span class="comment">//"Shelby"</span></span><br></pre></td></tr></table></figure></p><p>加了这个判断之后,看起来更叫稳妥.</p><p>不过又产生了新的问题, 假如Person函数调用call/apply实现继承的话, 那么结果可能不是我们想要的:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Polygon</span>(<span class="params">sides</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> Polygon) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sides = sides;</span><br><span class="line">        <span class="keyword">this</span>.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Polygon(sides);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params">width, height</span>)</span>&#123;</span><br><span class="line">    Polygon.call(<span class="keyword">this</span>, <span class="number">2</span>);<span class="comment">//这里的this传的是Rectangle的实例</span></span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">    <span class="keyword">this</span>.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">alert(rect.sides);        <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p><p>解决方式:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Rectangle.prototype = <span class="keyword">new</span> Polygon();<span class="comment">//原型链继承, 这样this就是Polygon的实例了</span></span><br><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle(<span class="number">5</span>, <span class="number">10</span>);</span><br><span class="line">alert(rect.sides);        <span class="comment">//2</span></span><br></pre></td></tr></table></figure></p><h3 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h3><p>由于浏览器差异，大量的判断浏览器能力的函数需要被使用（通常是大量的if），然而这些判断一般其实不必每次都执行，在执行一次后，浏览器的能力就确定了，以后就应该不用在判断了。比如：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest != <span class="string">"undefined"</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> ActiveXObject != <span class="string">"undefined"</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.activeXString != <span class="string">"string"</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> versions = [<span class="string">"MSXML2.XMLHttp.6.0"</span>, <span class="string">"MSXML2.XMLHttp.3.0"</span>,</span><br><span class="line">                    <span class="string">"MSXML2.XMLHttp"</span>],</span><br><span class="line">                i,len;</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>,len=versions.length; i &lt; len; i++)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">new</span> ActiveXObject(versions[i]);</span><br><span class="line">                    <span class="built_in">arguments</span>.callee.activeXString = versions[i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="built_in">arguments</span>.callee.activeXString);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"No XHR object available."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的创建XHR对象的函数，每次创建对象时都会判断一次浏览器能力，这是不必要的。</p><p>惰性载入有两种方式. 第一种就是在函数第一次被调用时，根据不同情况，用不同的新函数把这个函数覆盖掉，以后调用就不需要再判断而是直接执行该执行的操作。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXHR</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest != <span class="string">"undefined"</span>)&#123;</span><br><span class="line">        createXHR = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> ActiveXObject != <span class="string">"undefined"</span>)&#123;</span><br><span class="line">        createXHR = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.activeXString != <span class="string">"string"</span>)&#123;</span><br><span class="line">                <span class="keyword">var</span> versions = [<span class="string">"MSXML2.XMLHttp.6.0"</span>, <span class="string">"MSXML2.XMLHttp.3.0"</span>,</span><br><span class="line">                        <span class="string">"MSXML2.XMLHttp"</span>],</span><br><span class="line">                        i, len;</span><br><span class="line">                <span class="keyword">for</span> (i=<span class="number">0</span>,len=versions.length; i &lt; len; i++)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">new</span> ActiveXObject(versions[i]);</span><br><span class="line">                        <span class="built_in">arguments</span>.callee.activeXString = versions[i];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">                        <span class="comment">//skip</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="built_in">arguments</span>.callee.activeXString);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        createXHR = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"No XHR object available."</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> createXHR();</span><br><span class="line">&#125;</span><br><span class="line">createXHR();<span class="comment">//第一次调用的时候会执行if语句</span></span><br><span class="line">createXHR();<span class="comment">//第二次就不会执行if语句了</span></span><br></pre></td></tr></table></figure></p><p>第二种方法就是在声明函数时候就指定适当的函数, 实际上原理和上面的类似:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> createXHR = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest != <span class="string">"undefined"</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> ActiveXObject != <span class="string">"undefined"</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">arguments</span>.callee.activeXString != <span class="string">"string"</span>)&#123;</span><br><span class="line">                <span class="keyword">var</span> versions = [<span class="string">"MSXML2.XMLHttp.6.0"</span>, <span class="string">"MSXML2.XMLHttp.3.0"</span>,</span><br><span class="line">                    <span class="string">"MSXML2.XMLHttp"</span>],</span><br><span class="line">                    i, len;</span><br><span class="line">                <span class="keyword">for</span> (i=<span class="number">0</span>,len=versions.length; i &lt; len; i++)&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">new</span> ActiveXObject(versions[i]);</span><br><span class="line">                        <span class="built_in">arguments</span>.callee.activeXString = versions[i];</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ex)&#123;</span><br><span class="line">                        <span class="comment">//skip</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(<span class="built_in">arguments</span>.callee.activeXString);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"No XHR object available."</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();<span class="comment">//这里是一个立即执行函数, 执行完毕后createXHR就可以直接调用, 无需再检测</span></span><br></pre></td></tr></table></figure><h3 id="函数绑定"><a href="#函数绑定" class="headerlink" title="函数绑定"></a>函数绑定</h3><p>函数绑定是为了解决this的指向问题：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">      message: <span class="string">"Event handled"</span>,</span><br><span class="line">      handleClick: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.message);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myButton"</span>);</span><br><span class="line"></span><br><span class="line">    btn.addEventListener(<span class="string">'click'</span>, handler.handleClick, <span class="literal">false</span>);<span class="comment">//这里会输出 dom 和 undefined, 表面上handler.handleClick是挂载在handler上, 但是它里面的this指向会发生改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了解决上面的问题, 我们有如下两个方法:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法1: 新增匿名函数</span></span><br><span class="line">    btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>)</span>&#123;</span><br><span class="line">      handler.handleClick(evt)<span class="comment">// 通过新增一个匿名函数可以实期待的输出</span></span><br><span class="line">    &#125;, <span class="literal">false</span>); </span><br><span class="line"><span class="comment">// 方法2: 使用Es5 bind方法</span></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, handler.handleClick.bind(handler), <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果浏览器不支持bind方法, 我们可以利用apply实现一个</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">Function</span>.prototype.bind)&#123;</span><br><span class="line">  <span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">fn,context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      fn.apply(context,<span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="函数curry化"><a href="#函数curry化" class="headerlink" title="函数curry化"></a>函数curry化</h3><p>函数curry化, 中文翻译柯里化, 个人觉得在大多数情况下不是很有必要.书上讲得也不好, 请直接观看 <a href="https://www.jianshu.com/p/9b6b5c7527fc" target="_blank" rel="noopener">这篇文章</a>讲解什么是curry化 </p><h2 id="防篡改对象"><a href="#防篡改对象" class="headerlink" title="防篡改对象"></a>防篡改对象</h2><h3 id="不可扩展对象"><a href="#不可扩展对象" class="headerlink" title="不可扩展对象"></a>不可扩展对象</h3><p>JS共享的本质使任意对象都可被随意修改。这样有时很不方便。ES5增加了几个方法来设置对象的行为。一旦将对象设置为防篡改就不能撤销了。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions(person);<span class="comment">//ES5新增的Object.preventExtensions方法</span></span><br><span class="line"></span><br><span class="line">person.age = <span class="number">29</span>;</span><br><span class="line">alert(person.age); <span class="comment">//undefined</span></span><br><span class="line">alert(<span class="built_in">Object</span>.isExtensible(person)); <span class="comment">//false</span></span><br><span class="line">person.name = <span class="string">"hahah"</span>;<span class="comment">//可以对现有属性进行修改</span></span><br><span class="line">alert(person.name); <span class="comment">//hahah</span></span><br></pre></td></tr></table></figure></p><h3 id="密封的对象"><a href="#密封的对象" class="headerlink" title="密封的对象"></a>密封的对象</h3><p>密封对象比不可扩展对象更加严格, 它不可以添加或删除属性，已有成员的[[Configurable]]特性被设置为false。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.seal(person);</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">29</span>; </span><br><span class="line">alert(person.age); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name; <span class="comment">//不能删除</span></span><br><span class="line">alert(person.name); <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">Object</span>.isExtensible(person)); <span class="comment">//false ,不能扩展</span></span><br><span class="line">alert(<span class="built_in">Object</span>.isSealed(person));     <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="冻结的对象"><a href="#冻结的对象" class="headerlink" title="冻结的对象"></a>冻结的对象</h3><p>Object.freeze, 比前面两个更加严格<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.freeze(person);</span><br><span class="line">person.age = <span class="number">29</span>; </span><br><span class="line">alert(person.age); <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name; </span><br><span class="line">alert(person.name); <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line">person.name = <span class="string">"Greg"</span>; </span><br><span class="line">alert(person.name); <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line">alert(<span class="built_in">Object</span>.isExtensible(person));<span class="comment">//false</span></span><br><span class="line">alert(<span class="built_in">Object</span>.isSealed(person));<span class="comment">//true</span></span><br><span class="line">alert(<span class="built_in">Object</span>.isFrozen(person));<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h2 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h2><p>setTimeout()和setInterval()是很实用的功能，不过有些事情是要注意的。<br>JS是单线程的，这就意味着定时器实际上是很有可能被阻塞的。我们在这两个函数中所设置的定时，其实是代表将代码加入到执行队列的事件，如果在加入时恰巧JS是空闲的，那么这段代码会立即被执行，也就是说这个定时被准时的执行了。相反，如果这时JS并不空闲或队列中还有别的优先级更高的代码，那就意味着你的定时器会被延时执行。</p><blockquote><p>记住: 在JS中, 没有任何代码是立即执行的, 只有一旦进程空闲就执行.</p></blockquote><h3 id="重复的定时器"><a href="#重复的定时器" class="headerlink" title="重复的定时器"></a>重复的定时器</h3><p>使用setInterval创建定时器的目的是使代码规则的插入到队列中。这个方式的问题在于，存在这样一种可能，在上次代码还没执行完的时候代码再次被添加到队列。JS引擎会解决这个问题，在将代码添加到队列时会检查队列中有没有代码实例，如果有就不添加，这确保了定时器代码被加入队列中的最小间隔是规定间隔。但是在某些特殊情况下还是会出现两个问题，某些间隔因为JS的处理被跳过，代码之间的间隔比预期的小。<br>所以尽量使用setTimeout()模拟间隔调用。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    setTimeout(<span class="built_in">arguments</span>.callee, interval);</span><br><span class="line">&#125;, interval);</span><br></pre></td></tr></table></figure></p><h3 id="yielding-processes"><a href="#yielding-processes" class="headerlink" title="yielding processes"></a>yielding processes</h3><p>浏览器中的js被分配了一个确定数量的资源，所以会限制js脚本的运行时间，不能过长。</p><p>如果达到这个限制，会弹出一个浏览器错误的对话框，询问是否继续执行。定时器时绕开此限制的方法之一。</p><p>脚本长时间运行的原因有两个：</p><ul><li>过长的、过深嵌套的函数调用</li><li>进行大量处理的循环</li></ul><p>通常我们是处理第二个因素, 但是要记住, 如果你的循环不必<strong>同步</strong>,或者结果<strong>不必按顺序</strong>, 那么么就可以采用yielding processes思想.</p><p>我们看这例子:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chunk</span>(<span class="params">array, process, context</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> item = array.shift();</span><br><span class="line">        process.call(context, item);</span><br><span class="line">        <span class="keyword">if</span> (array.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            setTimeout(<span class="built_in">arguments</span>.callee, <span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data = [<span class="number">12</span>,<span class="number">123</span>,<span class="number">1234</span>,<span class="number">453</span>,<span class="number">436</span>,<span class="number">23</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">4123</span>,<span class="number">45</span>,<span class="number">346</span>,<span class="number">5634</span>,<span class="number">2234</span>,<span class="number">345</span>,<span class="number">342</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printValue</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line">    div.innerHTML += item + <span class="string">"&lt;br&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">chunk(data, printValue);</span><br></pre></td></tr></table></figure></p><h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><p>举个例子 , 页面有一个长度为3的轮播图, 你鼠标放到(hover)对应轮播点的时候自动显示该张图, 如果你在非常短时间(比如10ms)内快速来回hover, 那图片自然也会也会快速闪烁, 这样会操作性能的浪费. 我们就可以利用setTimeout来限制用户的hover频率</p><h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>事件是一种叫做观察者模的设计模式(也叫发布订阅模式), 这是一种创建松散耦合的代码技术.<br>观察者模式有两类对象组成: 主体和观察者, 主体发布时间, 同时观察者通过订阅这些事件来观察主体. 涉及到DOM上, DOM元素就是主体, 你的事件处理程序就是观察者.</p><p>我们来实现一个简单的观察者模式:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Pubsub = <span class="function"><span class="keyword">function</span>  (<span class="params">argument</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.hub = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Pubsub.prototype.on = <span class="function"><span class="keyword">function</span>(<span class="params">type,fn</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.hub[type]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hub[type] = [];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.hub[type].push(fn);</span><br><span class="line">    &#125;;</span><br><span class="line">    Pubsub.prototype.off = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.hub[type] = [];</span><br><span class="line">    &#125;;</span><br><span class="line">    Pubsub.prototype.fire = <span class="function"><span class="keyword">function</span>(<span class="params">type,fn</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> fns  = <span class="keyword">this</span>.hub[type];  <span class="comment">//有可能存了多个事件</span></span><br><span class="line">      <span class="keyword">if</span> (!fns.length) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'无'</span>+type+<span class="string">'订阅'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; fns.length; i++) &#123;</span><br><span class="line">        fns[i]();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> user = <span class="keyword">new</span> Pubsub;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"I'm reading"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">read2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"I'm recording"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    user.on(<span class="string">'update'</span>,read);</span><br><span class="line">    user.on(<span class="string">'update'</span>,read2);</span><br><span class="line"></span><br><span class="line">    user.fire(<span class="string">'update'</span>);</span><br><span class="line"></span><br><span class="line">    user.off(<span class="string">'update'</span>);</span><br><span class="line">    user.fire(<span class="string">'update'</span>);</span><br></pre></td></tr></table></figure></p><h2 id="拖放"><a href="#拖放" class="headerlink" title="拖放"></a>拖放</h2><blockquote><p>不太清除为何<code>拖放</code>这节内容会放在高级技巧中, 这里不再讲解.</p></blockquote><p>JS实现拖放的思路就是对一个DOM元素设置绝对定位, 然后根据鼠标的位置, 配合mouseDown/mouseUp/mouseMove事件来动态设置DOM元素的top/left值. 代码略</p><hr><p>本章完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;高级函数&quot;&gt;&lt;a href=&quot;#高级函数&quot; class=&quot;headerlink&quot; title=&quot;高级函数&quot;&gt;&lt;/a&gt;高级函数&lt;/h2&gt;&lt;h3 id=&quot;安全类型的检测&quot;&gt;&lt;a href=&quot;#安全类型的检测&quot; class=&quot;headerlink&quot; title=&quot;安全类
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://thinkerchan.com/categories/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS红皮书读书笔记-20-JSON</title>
    <link href="https://thinkerchan.com/2019/04/09/JSbook20/"/>
    <id>https://thinkerchan.com/2019/04/09/JSbook20/</id>
    <published>2019-04-09T08:06:00.000Z</published>
    <updated>2020-07-02T04:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>在很早一段时间, XML才是WEB开发首选的数据结构, 但是JSON的出现改变了这个事实, 相比XML, JSON更加简洁, 逻辑清晰, 读取信息的时候, 也不必创建DOM对象. 所以当下JSON是web开发最流行的数据格式.</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>JSON 的语法可以表示以下三种类型的值。</p><ul><li>简单值：使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null。但 JSON 不支持 JavaScript 中的特殊值 undefined。</li><li>对象：对象作为一种复杂数据类型，表示的是一组无序的键值对儿。而每个键值对儿中的值可 以是简单值，也可以是复杂数据类型的值。</li><li>数组：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中 的值。数组的值也可以是任意类型 简单值、对象或数组。</li></ul><p>JSON 不支持变量、函数或对象实例，它就是一种表示结构化数据的格式，虽然与 JavaScript 中表示数据的某些语法相同，但它并不局限于 JavaScript 的范畴。</p><h3 id="简单值"><a href="#简单值" class="headerlink" title="简单值"></a>简单值</h3><p>数值/布尔值/字符串/null 四种</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>JSON对象和JS对象字面量稍有不同, JSON对象的字段, 必须并且只能用<strong>双引号</strong>括起来.</p><p>这个是JS对象字面量:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">name: <span class="string">'testdog'</span>,</span><br><span class="line">age: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个是JSON对象:<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">"name"</span>: <span class="string">"testdog"</span>,</span><br><span class="line"><span class="attr">"age"</span>: <span class="number">18</span>,</span><br><span class="line"><span class="attr">"school"</span>:&#123;</span><br><span class="line"><span class="attr">"name"</span>:<span class="string">"ABC"</span>,</span><br><span class="line"><span class="attr">"addr"</span>:<span class="string">"China"</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>JSON是不能有注释的, 最后的字段末尾不能有逗号</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>略, 语法注意事项同上</p><h2 id="解析与序列化"><a href="#解析与序列化" class="headerlink" title="解析与序列化"></a>解析与序列化</h2><h3 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h3><p>JSON 之所以流行，拥有与 JavaScript 类似的语法并不是全部原因。更重要的一个原因是，可以把JSON 数据结构解析为有用的 JavaScript 对象。与 XML 数据结构要解析成 DOM 文档而且从中提取数据极为麻烦相比，JSON 可以解析为 JavaScript 对象的优势极其明显。<br>早期的 JSON 解析器基本上就是使用 JavaScript 的 eval()函数。由于 JSON 是 JavaScript 语法的子集，因此 eval()函数可以解析、解释并返回 JavaScript 对象和数组。对于较早版本的浏览器，可以使用一个 shim：<a href="https://github.com/douglascrockford/JSON-js。在旧版本的浏览器中，使用" target="_blank" rel="noopener">https://github.com/douglascrockford/JSON-js。在旧版本的浏览器中，使用</a> eval()对 JSON 数据结构求值存在风险，因为可能会执行一些恶意代码。对于不能原生支持 JSON 解析的浏览器，使用这个 shim 是最佳选择。</p><p>JSON 对象有两个方法：stringify()和 parse()。在最简单的情况下，这两个方法分别用于把JavaScript 对象序列化为 JSON 字符串和把 JSON 字符串解析为原生 JavaScript 值。</p><p>例如: 将js对象转化成JSON字符串<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  title: <span class="string">"Professional JavaScript"</span>, </span><br><span class="line">  authors: [</span><br><span class="line">  <span class="string">"Nicholas C. Zakas"</span></span><br><span class="line">  ],</span><br><span class="line">  edition: <span class="number">3</span>,</span><br><span class="line">  year: <span class="number">2011</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book);</span><br></pre></td></tr></table></figure></p><p>默认情况下，JSON.stringify()输出的 JSON 字符串不包含任何空格字符或缩进，因此保存在 jsonText 中的字符串如下所示：<br><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">"title"</span>:<span class="string">"Professional JavaScript"</span>,<span class="attr">"authors"</span>:[<span class="string">"Nicholas C. Zakas"</span>],<span class="attr">"edition"</span>:<span class="number">3</span>, <span class="attr">"year"</span>:<span class="number">2011</span>&#125;</span><br><span class="line">``` </span><br><span class="line">在序列化 JavaScript 对象时，所有函数及原型成员都会被有意忽略，不体现在结果中。此外，值为undefined 的任何属性也都会被跳过。结果中最终都是值为有效 JSON 数据类型的实例属性。</span><br><span class="line"></span><br><span class="line">将 JSON 字符串直接传递给 JSON.parse()就可以得到相应的 JavaScript 值。例如，使用下列代码就可以创建与 book 类似的对象：</span><br><span class="line">``` js</span><br><span class="line">var bookCopy = JSON.parse(jsonText);</span><br></pre></td></tr></table></figure></p><p>注意，虽然 book 与 bookCopy 具有相同的属性，但它们是两个独立的、没有任何关系的对象。如果传给 JSON.parse()的字符串不是有效的 JSON，该方法会抛出错误。</p><h3 id="序列化选项"><a href="#序列化选项" class="headerlink" title="序列化选项"></a>序列化选项</h3><p>JSON.stringify一共有三个参数:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"Professional JavaScript"</span>, <span class="string">"authors"</span>: [</span><br><span class="line">  <span class="string">"Nicholas C. Zakas"</span></span><br><span class="line">  ],</span><br><span class="line">  edition: <span class="number">3</span>,</span><br><span class="line">  year: <span class="number">2011</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数自然是要被序列化的对象, 第二个参数可以是一个数组或者说函数,第三个参数是一个缩进选项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book, [<span class="string">"title"</span>, <span class="string">"edition"</span>]);<span class="comment">//这里的第二个参数是一个数组, 代表一个过滤器, 返回 &#123;"title":"Professional JavaScript","edition":3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的第二个参数是一个函数</span></span><br><span class="line"><span class="keyword">var</span> jsonText2 = <span class="built_in">JSON</span>.stringify(book, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">switch</span>(key)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"authors"</span>:</span><br><span class="line">    <span class="keyword">return</span> value.join(<span class="string">","</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"year"</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"edition"</span>: </span><br><span class="line"><span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// jsonText2返回: &#123;"title":"Professional JavaScript","authors":"Nicholas C. Zakas","year":5000&#125; , 注意这里是没有"edition"这个字段, 因为它值为undefined, 被过滤了.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText3 = <span class="built_in">JSON</span>.stringify(book, <span class="literal">null</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//jsonText3返回的格式缩进就带4个空格</span></span><br></pre></td></tr></table></figure></p><p>还有一个补充JSON.stringify的方法, toJSON, 讲解略.</p><h3 id="解析选项"><a href="#解析选项" class="headerlink" title="解析选项"></a>解析选项</h3><p>JSON.parse()方法也可以接收另一个参数，该参数是一个函数，将在每个键值对儿上调用。为了区别  JSON.stringify()接收的替换（过滤）函数（replacer），这个函数被称为还原函数（reviver），但实际上这两个函数的签名是相同的    它们都接收两个参数，一个键和一个值，而且都需要返回一个值。</p><p>如果还原函数返回 undefined，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。在将H期字符串转换为 Date 对象时，经常要用到还原函数。例如：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"Professional JavaScript"</span>, <span class="string">"authors"</span>: [</span><br><span class="line">  <span class="string">"Nicholas C. Zakas"</span></span><br><span class="line">  ],</span><br><span class="line">  edition: <span class="number">3</span>,</span><br><span class="line">  year: <span class="number">2011</span>,</span><br><span class="line">  releaseDate: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">1</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> jsonText = <span class="built_in">JSON</span>.stringify(book);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bookCopy = <span class="built_in">JSON</span>.parse(jsonText, <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (key == <span class="string">"releaseDate"</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(bookCopy.releaseDate.getFullYear());</span><br></pre></td></tr></table></figure><hr><p>本章完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在很早一段时间, XML才是WEB开发首选的数据结构, 但是JSON的出现改变了这个事实, 相比XML, JSON更加简洁, 逻辑清晰, 读取信息的时候, 也不必创建DOM对象. 所以当下JSON是web开发最流行的数据格式.&lt;/p&gt;
&lt;h2 id=&quot;语法&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://thinkerchan.com/categories/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS红皮书读书笔记-18-JavaScript与XML(略)</title>
    <link href="https://thinkerchan.com/2019/04/09/JSbook18/"/>
    <id>https://thinkerchan.com/2019/04/09/JSbook18/</id>
    <published>2019-04-09T08:05:00.000Z</published>
    <updated>2020-07-06T01:06:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>JS红皮书读书笔记-18-JavaScript与XML</p><blockquote><p>本章节内容不常用，只列出大纲，有兴趣自行查阅</p></blockquote><h2 id="浏览器对XML-DOM的支持"><a href="#浏览器对XML-DOM的支持" class="headerlink" title="浏览器对XML DOM的支持"></a>浏览器对XML DOM的支持</h2><h3 id="DOM2级核心"><a href="#DOM2级核心" class="headerlink" title="DOM2级核心"></a>DOM2级核心</h3><h3 id="DOMParser类型"><a href="#DOMParser类型" class="headerlink" title="DOMParser类型"></a>DOMParser类型</h3><h3 id="XMLSerializer类型"><a href="#XMLSerializer类型" class="headerlink" title="XMLSerializer类型"></a>XMLSerializer类型</h3><h3 id="IE8及之前版本的XML"><a href="#IE8及之前版本的XML" class="headerlink" title="IE8及之前版本的XML"></a>IE8及之前版本的XML</h3><h3 id="跨浏览器处理XML"><a href="#跨浏览器处理XML" class="headerlink" title="跨浏览器处理XML"></a>跨浏览器处理XML</h3><h2 id="浏览器对XPath的支持"><a href="#浏览器对XPath的支持" class="headerlink" title="浏览器对XPath的支持"></a>浏览器对XPath的支持</h2><h3 id="DOM3级的XPath"><a href="#DOM3级的XPath" class="headerlink" title="DOM3级的XPath"></a>DOM3级的XPath</h3><h3 id="IE中的XPath"><a href="#IE中的XPath" class="headerlink" title="IE中的XPath"></a>IE中的XPath</h3><h3 id="跨浏览器使用XPath"><a href="#跨浏览器使用XPath" class="headerlink" title="跨浏览器使用XPath"></a>跨浏览器使用XPath</h3><h2 id="浏览器对XSLT的支持"><a href="#浏览器对XSLT的支持" class="headerlink" title="浏览器对XSLT的支持"></a>浏览器对XSLT的支持</h2><h3 id="IE中的XSLT"><a href="#IE中的XSLT" class="headerlink" title="IE中的XSLT"></a>IE中的XSLT</h3><h3 id="XSLTProcessor类型"><a href="#XSLTProcessor类型" class="headerlink" title="XSLTProcessor类型"></a>XSLTProcessor类型</h3><h3 id="跨浏览器使用XSLT"><a href="#跨浏览器使用XSLT" class="headerlink" title="跨浏览器使用XSLT"></a>跨浏览器使用XSLT</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JS红皮书读书笔记-18-JavaScript与XML&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本章节内容不常用，只列出大纲，有兴趣自行查阅&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;浏览器对XML-DOM的支持&quot;&gt;&lt;a href=&quot;#浏览器对XML-DOM的支持
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://thinkerchan.com/categories/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS红皮书读书笔记-19-E4X(略)</title>
    <link href="https://thinkerchan.com/2019/04/09/JSbook19/"/>
    <id>https://thinkerchan.com/2019/04/09/JSbook19/</id>
    <published>2019-04-09T08:05:00.000Z</published>
    <updated>2020-07-06T01:06:14.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本章节内容不常用，只列出大纲，有兴趣自行查阅</p></blockquote><h2 id="E4X的类型"><a href="#E4X的类型" class="headerlink" title="E4X的类型"></a>E4X的类型</h2><h3 id="XML类型"><a href="#XML类型" class="headerlink" title="XML类型"></a>XML类型</h3><h3 id="XMLList类型"><a href="#XMLList类型" class="headerlink" title="XMLList类型"></a>XMLList类型</h3><h3 id="Namespace类型"><a href="#Namespace类型" class="headerlink" title="Namespace类型"></a>Namespace类型</h3><h3 id="Qname类型"><a href="#Qname类型" class="headerlink" title="Qname类型"></a>Qname类型</h3><h2 id="一般用法"><a href="#一般用法" class="headerlink" title="一般用法"></a>一般用法</h2><h3 id="访问特性"><a href="#访问特性" class="headerlink" title="访问特性"></a>访问特性</h3><h3 id="其他节点类型"><a href="#其他节点类型" class="headerlink" title="其他节点类型"></a>其他节点类型</h3><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h3 id="构建和操作XML"><a href="#构建和操作XML" class="headerlink" title="构建和操作XML"></a>构建和操作XML</h3><h3 id="解析和序列化"><a href="#解析和序列化" class="headerlink" title="解析和序列化"></a>解析和序列化</h3><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><h2 id="其他变化"><a href="#其他变化" class="headerlink" title="其他变化"></a>其他变化</h2><h2 id="全面启用E4X"><a href="#全面启用E4X" class="headerlink" title="全面启用E4X"></a>全面启用E4X</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本章节内容不常用，只列出大纲，有兴趣自行查阅&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;E4X的类型&quot;&gt;&lt;a href=&quot;#E4X的类型&quot; class=&quot;headerlink&quot; title=&quot;E4X的类型&quot;&gt;&lt;/a&gt;E4X的类型&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://thinkerchan.com/categories/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS红皮书读书笔记-16-HTML5脚本编程</title>
    <link href="https://thinkerchan.com/2019/04/09/JSbook16/"/>
    <id>https://thinkerchan.com/2019/04/09/JSbook16/</id>
    <published>2019-04-09T08:04:00.000Z</published>
    <updated>2020-07-02T04:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="跨文档消息传递-XDM"><a href="#跨文档消息传递-XDM" class="headerlink" title="跨文档消息传递(XDM)"></a>跨文档消息传递(XDM)</h2><p>跨文档消息传递(cross-document messaging)指的是在来自不同域的页面间传递消息。例如，<a href="http://www.wrox.com域中的页面与位于一个内嵌框架中的p2p.wrox.com域中的页面通信。" target="_blank" rel="noopener">www.wrox.com域中的页面与位于一个内嵌框架中的p2p.wrox.com域中的页面通信。</a> </p><p>XDM的核心是postMessage()方法。对于XDM而言，就是将信息发送至包含在当前页面中的iframe元素，或者由当前页面弹出的窗口。<br>这个方法接受两个参数，一个消息字符串和一个表示消息接受方来自哪个域的字符串。如果内嵌框架的来源不符合参数，则什么也不做，传递“＊”代表匹配所有文档。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iframeWindow = <span class="built_in">document</span>.getElementById(<span class="string">"myframe"</span>).contentWindow; </span><br><span class="line">iframeWindow.postMessage(<span class="string">"A secret"</span>, <span class="string">"http://www.wrox.com"</span>);</span><br></pre></td></tr></table></figure><h2 id="原生拖放"><a href="#原生拖放" class="headerlink" title="原生拖放"></a>原生拖放</h2><h3 id="拖放事件"><a href="#拖放事件" class="headerlink" title="拖放事件"></a>拖放事件</h3><p>通过拖放事件，可以控制拖放相关的各个方面，其中最关键的地方在于确定那里发生了拖放事件，有些事件是在被拖动的元素上产生的，有些是在放置目标上触发的。<br>拖动某元素时将依次在被拖动的元素上触发下列事件：</p><ul><li>dragstart：按下鼠标且鼠标移动开始时</li><li>drag：在元素被拖动的过程中持续触发</li><li>dragend：当拖动停止时，无论把元素放到有效的放置目标上还是无效的上，都会触发dragend事件。</li></ul><p>在拖动的过程中，被拖动的元素的外观是可以改变的，一般浏览器会默认创建一个半透明的副本，这个副本始终跟随光标移动。<br>当某个元素被放置到有效的放置目标的时候，下列事件会在放置目标会依次发生：</p><ul><li>dragenter：元素被拖动到放置目标上，就回触发一次dragenter</li><li>dragover：元素在放置目标上继续被拖动时，会持续触发这个事件</li><li>dragleave或drop：如果元素又被拖离了目标范围，触发dragleave，dragover事件不再触发，如果直接放置在了目标中，会触发drop事件。</li></ul><h3 id="自定义放置目标"><a href="#自定义放置目标" class="headerlink" title="自定义放置目标"></a>自定义放置目标</h3><p>所有元素都支持放置目标事件，但有些元素是默认不允许放置的，如果拖动元素经过不允许放置的的元素，是不会触发drop事件的，重写其dragenter和dragover事件可以使其变为可放置的：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">EventUtil.addHandler(dropDiv, <span class="string">"dragover"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    EventUtil.preventDefault(event);</span><br><span class="line">&#125;);</span><br><span class="line">EventUtil.addHandler(dropDiv, <span class="string">"dragenter"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    EventUtil.preventDefault(event);</span><br><span class="line">&#125;);</span><br><span class="line">EventUtil.addHandler(dropDiv, <span class="string">"drop"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"droped"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="dataTransfer对象"><a href="#dataTransfer对象" class="headerlink" title="dataTransfer对象"></a>dataTransfer对象</h3><p>为了在拖放操作时实现数据的交换，引入了dataTransfer对象(25章也有这个示例)，这是事件对象的一个属性，这个对象有两个方法：getData()和 setData()。这两个方法都需要一个代表数据类型的参数，在HTML5中，这个是MIME类型，为了向后兼容，还可以是”text”和”URL”，只不过他们其实是被映射为MIME类型”text/plain”和”text/uri-list”。setData还需要一个对应的数据作为参数。在这个对象中，对不同的MIME可以同时存储多个值。<br>这个对象只在drop事件中读取。<br>setData在拖动开始时设置，拖动文本，链接或图像时，浏览器会自动调用这个方法保存文字或URL。我们自己也可以在dragstart事件中调用来保存我们自己的数据。<br>getData在drop事件中调用，获取相关数据。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">event.dataTransfer.setData(<span class="string">"URL"</span>, <span class="string">"http://www.wrox.com/"</span>);</span><br><span class="line"><span class="keyword">var</span> url = dataTransfer.getData(<span class="string">"url"</span>)||dataTransfer.getData(<span class="string">"text/uri-list"</span>);</span><br></pre></td></tr></table></figure></p><h3 id="dropEffect与effectAllowed"><a href="#dropEffect与effectAllowed" class="headerlink" title="dropEffect与effectAllowed"></a>dropEffect与effectAllowed</h3><p>利用dataTransfer对象，不光能传送数据，还能确定被拖动元素以及作为放置目标的元素能够接收什么操作。<br>dropEffect属性可以知道被拖动元素能执行哪种放置行为：</p><ul><li>none</li><li>move</li><li>copy</li><li>link<br>这个属性要在开始拖动ondragstart时设置 </li></ul><p>effectAllowed表示允许拖动元素的哪种dropEffect。</p><ul><li>uninitialized</li><li>none</li><li>copy</li><li>link</li><li>move</li><li>copyLink</li><li>copyMove</li><li>linkMove</li><li>all</li></ul><p>这个也要在ondragstart时设置</p><h3 id="可拖动"><a href="#可拖动" class="headerlink" title="可拖动"></a>可拖动</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">"true"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="其他成员"><a href="#其他成员" class="headerlink" title="其他成员"></a>其他成员</h3><p>HTML5规范规定dataTransfer对象还有下列方法和属性:</p><ul><li>addElement(element)</li><li>clearData(format)</li><li>setDragImage(element, x, y)</li><li>types</li></ul><h2 id="媒体元素"><a href="#媒体元素" class="headerlink" title="媒体元素"></a>媒体元素</h2><p>新增audio /video标签</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>略</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>略</p><h3 id="自定义媒体播放器"><a href="#自定义媒体播放器" class="headerlink" title="自定义媒体播放器"></a>自定义媒体播放器</h3><p>其实就是利用pause/play/currentTime等相关属性方法来封装一个播放器</p><h3 id="检测编解码器的支持情况"><a href="#检测编解码器的支持情况" class="headerlink" title="检测编解码器的支持情况"></a>检测编解码器的支持情况</h3><p>利用canPlayType方法来检测是否支持某种MIME类型的媒体:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(audio.canPlayType(<span class="string">'audio/mpeg'</span>))&#123; <span class="comment">//返回'probably'/'maybe'、'' 三个值之一</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Audio类型"><a href="#Audio类型" class="headerlink" title="Audio类型"></a>Audio类型</h3><p>audio类型有一个元素JS的构造函数Audio,可以在任何时候播放音频, 并且: <strong>通过 new Audio创建的实例不必插入到文档中就可以播放</strong>.</p><h2 id="历史状态管理"><a href="#历史状态管理" class="headerlink" title="历史状态管理"></a>历史状态管理</h2><p>在现在的Web应用中，用户的每次操作并不一定会打开一个新的页面，前进和后退按钮在这里也就失去了作用。HTML5通过更新history对象为管理历史状态提供了方便。 </p><p>hashchange事件可以知道URL的参数什么时候发生了变化，这时使用history.pushState()可以在不加载新页面的情况下改变浏览器的URL，该方法接收3个参数：状态对象，新状态的标题和可选的相对URL。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.pushState(&#123;<span class="attr">name</span>:<span class="string">"Nicholas"</span>&#125;, <span class="string">"Nicholas' page"</span>, <span class="string">"nicholas.html"</span>);</span><br></pre></td></tr></table></figure><p>这个方法执行后，新的状态会被加入历史状态栈，浏览器的地址栏也会变成新的相对URL。但其实并没有像服务器发送数据。其中的第一个参数是用来初始化这个页面的数据用的。 </p><p>这时后退按钮就能使用了，这时点击后退按钮会触发window对象的popstate事件，这个事件有个属性叫state，就是pushState的第一个参数。回到上一个页面，读取上一个页面的state来初始化上一个页面。比如你回到的是nicholas.html，那你读到的state的name就是Nicholas。<br>浏览器加载的第一个页面木有状态，其state是null。<br>还有个方法是replaceState()这个方法接收pushState的前两个参数，重写当前状态，不在历史栈中创建新状态。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">history.replaceState(&#123;<span class="attr">name</span>:<span class="string">"Greg"</span>&#125;, <span class="string">"Greg's page"</span>);</span><br></pre></td></tr></table></figure></p><p>这时以后再返回这个页面读到的state.name就是Greg了。<br>要注意，push进去的每个状态服务器上都要有个真的页面，要不一刷新就404了。<br>按照逻辑这个pushState应该是在每个web页面刚加载时就push进去，把初始化这个页面的每个数据一起push进去。在当前页面如果有什么即时的修改在下次进入这个页面也该体现的，就使用replaceState。</p><hr><p>本章完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;跨文档消息传递-XDM&quot;&gt;&lt;a href=&quot;#跨文档消息传递-XDM&quot; class=&quot;headerlink&quot; title=&quot;跨文档消息传递(XDM)&quot;&gt;&lt;/a&gt;跨文档消息传递(XDM)&lt;/h2&gt;&lt;p&gt;跨文档消息传递(cross-document messaging
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://thinkerchan.com/categories/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS红皮书读书笔记-17-错误处理与程序</title>
    <link href="https://thinkerchan.com/2019/04/09/JSbook17/"/>
    <id>https://thinkerchan.com/2019/04/09/JSbook17/</id>
    <published>2019-04-09T08:04:00.000Z</published>
    <updated>2020-07-02T04:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="浏览器报告的错误"><a href="#浏览器报告的错误" class="headerlink" title="浏览器报告的错误"></a>浏览器报告的错误</h2><p>写此文时chrome已经成了市场主流浏览器(可见百度浏览器统计数据), 书中讲的浏览器版本比较旧也比较多, 这里不再讲解, 大家以chrome为标准即可.</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(error)&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(error);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抛出错误"><a href="#抛出错误" class="headerlink" title="抛出错误"></a>抛出错误</h3><p>与 try-catch 语旬相配的还有一个 throw 操作符，用于随时抛出自定义错误。抛出错误时，必须要给 throw 操作符指定一个值，这个值是什么类型，没有要求。下列代码都是有效的。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="number">12345</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"Hello world!"</span>; <span class="keyword">throw</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">throw</span> &#123; <span class="attr">name</span>: <span class="string">"JavaScript"</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>在遇到 throw 操作符时，代码会立即停止执行。仅当有 try-catch 语旬捕获到被抛出的值时，代码才会继续执行</p><h3 id="错误事件"><a href="#错误事件" class="headerlink" title="错误事件"></a>错误事件</h3><p>任何没有通过 try-catch 处理的错误都会触发 window 对象的 error 事件。在任何 Web 浏览器中，onerror 事件处理程序都不会创建 event 对象， 但它可以接收三个参数：错误消息、错误所在的 URL 和行号。多数情况下，只有错误消息有用，因为URL 只是给出了文档的位置，而行号所指的代码行既可能出自嵌入的 JavaScript 代码，也可能出自外部的文件。要指定 onerror 事件处理程序，必须使用如下所示的 DOM0 级技术，它没有遵循“DOM2 级事件＂的标准格式。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, url, line</span>)</span>&#123; </span><br><span class="line">  alert(message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="常见错误类型"><a href="#常见错误类型" class="headerlink" title="常见错误类型"></a>常见错误类型</h3><p>错误处理的核心，是首先要知道代码里会发生什么错误。由于 JavaScript 是松散类型的，而且也不会验证函数的参数，因此错误只会在代码运行期间出现。一般来说，需要关注三种错误：</p><ul><li>类型转换错误</li><li>数据类型错误</li><li>通信错误</li></ul><hr><p>本章完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;浏览器报告的错误&quot;&gt;&lt;a href=&quot;#浏览器报告的错误&quot; class=&quot;headerlink&quot; title=&quot;浏览器报告的错误&quot;&gt;&lt;/a&gt;浏览器报告的错误&lt;/h2&gt;&lt;p&gt;写此文时chrome已经成了市场主流浏览器(可见百度浏览器统计数据), 书中讲的浏览器版本比
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://thinkerchan.com/categories/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS红皮书读书笔记-15-Canvas</title>
    <link href="https://thinkerchan.com/2019/04/09/JSbook15/"/>
    <id>https://thinkerchan.com/2019/04/09/JSbook15/</id>
    <published>2019-04-09T08:03:00.000Z</published>
    <updated>2020-07-02T04:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>本章书关于Canvas的都是一些api用法, 这部分内容查阅<a href="http://www.w3school.com.cn/html5/html_5_canvas.asp" target="_blank" rel="noopener">W3school</a> 更为直观.</p><h2 id="WebGL"><a href="#WebGL" class="headerlink" title="WebGL"></a>WebGL</h2><p>WebGL也就是Canvas 3d的情况, 请查阅 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Tutorial" target="_blank" rel="noopener">WebGL教程</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本用法&quot;&gt;&lt;a href=&quot;#基本用法&quot; class=&quot;headerlink&quot; title=&quot;基本用法&quot;&gt;&lt;/a&gt;基本用法&lt;/h2&gt;&lt;p&gt;本章书关于Canvas的都是一些api用法, 这部分内容查阅&lt;a href=&quot;http://www.w3school.com
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://thinkerchan.com/categories/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS红皮书读书笔记-14-表单脚本(待更新)</title>
    <link href="https://thinkerchan.com/2019/04/09/JSbook14/"/>
    <id>https://thinkerchan.com/2019/04/09/JSbook14/</id>
    <published>2019-04-09T08:02:00.000Z</published>
    <updated>2020-07-02T04:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="表单的基础知识"><a href="#表单的基础知识" class="headerlink" title="表单的基础知识"></a>表单的基础知识</h2><h3 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h3><h3 id="重置表单"><a href="#重置表单" class="headerlink" title="重置表单"></a>重置表单</h3><h3 id="表单字段"><a href="#表单字段" class="headerlink" title="表单字段"></a>表单字段</h3><h2 id="文本框脚本"><a href="#文本框脚本" class="headerlink" title="文本框脚本"></a>文本框脚本</h2><h3 id="选择文本"><a href="#选择文本" class="headerlink" title="选择文本"></a>选择文本</h3><h3 id="过滤输入"><a href="#过滤输入" class="headerlink" title="过滤输入"></a>过滤输入</h3><h3 id="自动切换焦点"><a href="#自动切换焦点" class="headerlink" title="自动切换焦点"></a>自动切换焦点</h3><h3 id="HTML5约束验证API"><a href="#HTML5约束验证API" class="headerlink" title="HTML5约束验证API"></a>HTML5约束验证API</h3><h2 id="选择框脚本"><a href="#选择框脚本" class="headerlink" title="选择框脚本"></a>选择框脚本</h2><h3 id="选择选项"><a href="#选择选项" class="headerlink" title="选择选项"></a>选择选项</h3><h3 id="添加选项"><a href="#添加选项" class="headerlink" title="添加选项"></a>添加选项</h3><h3 id="移除选项"><a href="#移除选项" class="headerlink" title="移除选项"></a>移除选项</h3><h3 id="移动和重排列"><a href="#移动和重排列" class="headerlink" title="移动和重排列"></a>移动和重排列</h3><h2 id="表单序列化"><a href="#表单序列化" class="headerlink" title="表单序列化"></a>表单序列化</h2><h2 id="富文本编辑"><a href="#富文本编辑" class="headerlink" title="富文本编辑"></a>富文本编辑</h2><h3 id="contentEditable"><a href="#contentEditable" class="headerlink" title="contentEditable"></a>contentEditable</h3><h3 id="操作富文本"><a href="#操作富文本" class="headerlink" title="操作富文本"></a>操作富文本</h3><h3 id="富文本选区"><a href="#富文本选区" class="headerlink" title="富文本选区"></a>富文本选区</h3><h3 id="表单与富文本"><a href="#表单与富文本" class="headerlink" title="表单与富文本"></a>表单与富文本</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;表单的基础知识&quot;&gt;&lt;a href=&quot;#表单的基础知识&quot; class=&quot;headerlink&quot; title=&quot;表单的基础知识&quot;&gt;&lt;/a&gt;表单的基础知识&lt;/h2&gt;&lt;h3 id=&quot;提交表单&quot;&gt;&lt;a href=&quot;#提交表单&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://thinkerchan.com/categories/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS红皮书读书笔记-13-事件</title>
    <link href="https://thinkerchan.com/2019/04/09/JSbook13/"/>
    <id>https://thinkerchan.com/2019/04/09/JSbook13/</id>
    <published>2019-04-09T07:59:00.000Z</published>
    <updated>2020-07-02T04:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>HTML和JS之间的交互, 就是通过事件实现的.</p><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流描述的是从页面中接收事件的顺序.  有冒泡和捕获两种事件处理方式, 提出者为微软和网景.</p><h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>IE 的事件流叫做事件冒泡（event  bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。</p><p>我们看这个例子:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Event Bubbling Example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"myDiv"</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按照IE的逻辑, 你点击#myDive会经过一下历程:</p><blockquote><p>div#myDiv -&gt; body -&gt; html -&gt; document</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/006tKfTcgy1g1ogrw8hsjj30io0bimx8.jpg" alt="冒泡"></p><p>此图形象地描述了什么是冒泡</p><h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>与冒泡相反的就是事件捕获, 还是用上面那个HTML页面做例子:</p><p>按照事件捕获的逻辑, 你点击#myDive会经过一下历程:</p><blockquote><p>document -&gt; html -&gt; body -&gt; div#myDiv</p></blockquote><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1ogv23wsoj30fg09qt8s.jpg" alt="捕获"></p><p>此图形象地描述了什么是捕获</p><h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>“DOM2级事件＂规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。</p><blockquote><p>一句话总结: DOM事件流会先触发捕获,再触发冒泡</p></blockquote><p>我们看一个例子:</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">id</span>=<span class="string">"html"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">id</span>=<span class="string">"body"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mydiv"</span>&gt;</span>click me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    html.addEventListener(<span class="string">'click'</span>, ()=&gt;&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'html.capture'</span>)</span></span><br><span class="line"><span class="actionscript">    &#125;, <span class="literal">true</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    html.addEventListener(<span class="string">'click'</span>, ()=&gt;&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'html.bubble'</span>)</span></span><br><span class="line"><span class="actionscript">    &#125;, <span class="literal">false</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    body.addEventListener(<span class="string">'click'</span>, ()=&gt;&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'body.capture'</span>)</span></span><br><span class="line"><span class="actionscript">    &#125;, <span class="literal">true</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    body.addEventListener(<span class="string">'click'</span>, ()=&gt;&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'body.bubble'</span>)</span></span><br><span class="line"><span class="actionscript">    &#125;, <span class="literal">false</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    mydiv.addEventListener(<span class="string">'click'</span>, ()=&gt;&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'mydiv.capture'</span>)</span></span><br><span class="line"><span class="actionscript">    &#125;, <span class="literal">true</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    mydiv.addEventListener(<span class="string">'click'</span>, ()=&gt;&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'mydiv.bubble'</span>)</span></span><br><span class="line"><span class="actionscript">    &#125;, <span class="literal">false</span>)</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结果如下:<br><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1g1oh4bbzn6j30dy07ua9y.jpg" alt="DOM事件流处理结果"></p><h2 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h2><p>可以理解成响应某种动作的函数, 比如说click事件自然对应onClick. 等等</p><h3 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h3><p>即在HTML里面直接使用诸如onClick之类的事件, 现在已经不推荐使用, 主要原因如下:</p><ul><li>代码耦合</li><li>未加载完所有资源就激活了事件导致报错</li></ul><h3 id="DOM0事件处理程序"><a href="#DOM0事件处理程序" class="headerlink" title="DOM0事件处理程序"></a>DOM0事件处理程序</h3><p>我们来看一个例子:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>); </span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.id); <span class="comment">//"myBtn", 注意这里的this</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//btn.onclick = function()&#123;</span></span><br><span class="line">  <span class="comment">// console.log('dom02次绑定会覆盖')</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br></pre></td></tr></table></figure></p><p>这就是通常见到的DOM0事件处理程序, 它的优势在于兼容IE浏览器, 缺点在于不能对同一个元素绑定相同的事件, 否则后面的会覆盖前面的事件处理程序</p><h3 id="DOM2事件处理程序"><a href="#DOM2事件处理程序" class="headerlink" title="DOM2事件处理程序"></a>DOM2事件处理程序</h3><p>“DOM2 级事件＂定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和 removeEventListener()。所有 DOM 节点中都包含这两个方法，并且它们都接受 3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。</p><p>那么DOM0那个例子可以改写成:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  alert(<span class="keyword">this</span>.id);<span class="comment">//注意这里的this</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  alert(<span class="string">'repeat'</span>);<span class="comment">// 'repeat'</span></span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p><p>DOM2能按顺序正常触发绑定的重复事件处理程序.</p><p>我们知道函数是引用类型的实例, 即使是匿名函数也不等于另一个匿名函数, 所以使用removeEventListener的时候, 第二个参数必须是一个函数名才有意义, 否则无效.</p><h3 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h3><p>IE也实现了和DOM2类似的两个方法, 分别是attachEvent和detachEvent.但只支持冒泡.所以只有两个参数, 我们看下面的例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 注意第一个参数是有on前缀的</span></span><br><span class="line">  alert(<span class="keyword">this</span> === <span class="built_in">window</span>);<span class="comment">//注意这里的this不是某个html元素的引用</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">btn.attachEvent(<span class="string">"onclick"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">'btn.attachEvent2'</span>); <span class="comment">// 它也是可以重复添加相同事件处理程序的</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>值得注意的是, attachEvent添加多个同类事件处理程序, 是<strong>逆序</strong>执行的. 同样, detachEvent的第二个参数也是要一个函数名才有意义.</p></blockquote><h3 id="跨浏览器的事件处理程序"><a href="#跨浏览器的事件处理程序" class="headerlink" title="跨浏览器的事件处理程序"></a>跨浏览器的事件处理程序</h3><p>既然要兼容IE和标准浏览器:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventUtil = &#123;</span><br><span class="line">  addHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (element.addEventListener)&#123;</span><br><span class="line">      element.addEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent)&#123; </span><br><span class="line">      element.attachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = handler;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  removeHandler: <span class="function"><span class="keyword">function</span>(<span class="params">element, type, handler</span>)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (element.removeEventListener)&#123;</span><br><span class="line">      element.removeEventListener(type, handler, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent)&#123; </span><br><span class="line">      element.detachEvent(<span class="string">"on"</span> + type, handler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      element[<span class="string">"on"</span> + type] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>兼容思路: </p><blockquote><p>DOM2 -&gt; IE -&gt; DOM0</p></blockquote><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含若所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如，鼠标操作导致的事件对象中，会包含鼠标位置的信息，而键盘操作导致的事件对象中，会包含与按下的键有关的信息。所有浏览器都支持 event 对象，但支持方式不同</p><h3 id="DOM中的事件对象"><a href="#DOM中的事件对象" class="headerlink" title="DOM中的事件对象"></a>DOM中的事件对象</h3><p>兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法（DOM0 级或 DOM2 级），都会传入 event 对象。来看下面的例子:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123; </span><br><span class="line">  alert(event); </span><br><span class="line">&#125;;</span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123; </span><br><span class="line">  alert(event.type);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>可以用for-in循环枚举出事件对象的熟悉和方法,这里只列几个常用的属性和方法:</p><ul><li>preventDefault(): 阻止默认行为, 例如禁止a标签跳转href</li><li>currentTarget: 略</li><li>stopPropagation(): 阻止事件继续捕获或者冒泡 </li><li>type: 事件类型</li></ul><h3 id="IE中的事件对象"><a href="#IE中的事件对象" class="headerlink" title="IE中的事件对象"></a>IE中的事件对象</h3><p>IE中DOM0事件的话, 则用window.event访问<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"myBtn"</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">// DOM0事件</span></span><br><span class="line">  <span class="keyword">var</span> event = <span class="built_in">window</span>.event; </span><br><span class="line">alert(event.type);  <span class="comment">//"click"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>IE中DOM2事件则与标准浏览器相同</p><h3 id="跨浏览器的事件对象"><a href="#跨浏览器的事件对象" class="headerlink" title="跨浏览器的事件对象"></a>跨浏览器的事件对象</h3><p>主要兼容思路:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> event =  event ? event : <span class="built_in">window</span>.event</span><br></pre></td></tr></table></figure></p><h2 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h2><h3 id="UI事件"><a href="#UI事件" class="headerlink" title="UI事件"></a>UI事件</h3><p>常见UI事件如下:</p><ul><li>load</li><li>unload</li><li>abort</li><li>error</li><li>select</li><li>resize</li><li>scroll</li></ul><h3 id="焦点事件"><a href="#焦点事件" class="headerlink" title="焦点事件"></a>焦点事件</h3><p>常见焦点事件如下:</p><ul><li>blur</li><li>focus</li></ul><h3 id="鼠标滚轮事件"><a href="#鼠标滚轮事件" class="headerlink" title="鼠标滚轮事件"></a>鼠标滚轮事件</h3><p>常见鼠标滚轮事件如下:</p><ul><li>click</li><li>dblclick</li><li>mousedown</li><li>mouseenter</li><li>mouseleave</li><li>mousemove</li><li>mousemout</li><li>mousemover</li><li>mouseup</li><li>mousewheel</li></ul><h3 id="键盘文本事件"><a href="#键盘文本事件" class="headerlink" title="键盘文本事件"></a>键盘文本事件</h3><p>常见键盘文本事件如下:</p><ul><li>keydown</li><li>keypress</li><li>keyup</li><li>textInput</li></ul><h3 id="复合事件"><a href="#复合事件" class="headerlink" title="复合事件"></a>复合事件</h3><p>这个符合事件的存在主要解决输入法输入的时候”有效输入”的问题, 可以看这篇文章, 会更好理解:<br> <a href="https://github.com/julytian/issues-blog/issues/15" target="_blank" rel="noopener">https://github.com/julytian/issues-blog/issues/15</a> </p><ul><li>compositionstart</li><li>compositionupdate</li><li>compositionend</li></ul><h3 id="变动事件"><a href="#变动事件" class="headerlink" title="变动事件"></a>变动事件</h3><p>通常指页面的某个节点在以下集中情况触发的事件:</p><ul><li>删除节点</li><li>插入节点</li></ul><p>对应的事件:</p><ul><li>DOMSubtreeModified</li><li>DOMNodeInserted</li><li>DOMNodeRemove</li><li>DOMNodeInsertedIntoDoucmnet</li><li>DOMNodeRemovedFromDoucmnet</li><li>DOMAttrModified</li><li>DOMCharacterDataModified</li></ul><p>由于在日常开发中用得少, 这部份的讲解略过</p><h3 id="HTML5事件"><a href="#HTML5事件" class="headerlink" title="HTML5事件"></a>HTML5事件</h3><ul><li>contextmenu</li><li>beforeunload</li><li>DOMContentLoaded</li><li>readystatechange: 它存在四种状态<ul><li>loading</li><li>loaded</li><li>interactive</li><li>complete</li></ul></li><li>pageshow/pagehide</li><li>hashchange: 挂载在window对象上, 主要用于URL变化检测</li></ul><h3 id="设备事件"><a href="#设备事件" class="headerlink" title="设备事件"></a>设备事件</h3><p>主要设备事件如下:</p><ul><li>orientationchange</li><li>deviceorientation: </li><li>devicemotion: 包含以下属性<ul><li>acceleration: 这个属性可以实现”摇一摇”的功能</li><li>accelerationIncludingGravity</li><li>interval</li><li>rotationRate</li></ul></li></ul><p>有关这部分的知识可以参考 <a href="https://imweb.io/topic/56ab279be39ca21162ae6c75" target="_blank" rel="noopener">https://imweb.io/topic/56ab279be39ca21162ae6c75</a> , 会更为清晰.</p><h3 id="触摸和手势事件"><a href="#触摸和手势事件" class="headerlink" title="触摸和手势事件"></a>触摸和手势事件</h3><p>常用触摸事件:</p><ul><li>touchstat</li><li>touchend</li><li>touchmove</li><li>touchcancel</li></ul><p>常用手势事件:<br>略</p><p>此节内容可以查看 <a href="https://segmentfault.com/a/1190000004332409" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004332409</a> </p><h2 id="内存和性能"><a href="#内存和性能" class="headerlink" title="内存和性能"></a>内存和性能</h2><p>假如你要对某个ul下的2个li添加点击事件 , 正常的思路自然会先获取一个li, 再添加事件处理程序, 同理再对第二个li进行类似处理. 这看起来也没什么问题.</p><p>假如ul下有100个li呢? 逐一对li添加事件处理程序可不显示, 而且非常耗费内存和性能.</p><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>针对上面描述的情况, 我们对li的父元素做一次绑定即可:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'ul'</span>);</span><br><span class="line">ul.addeventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>  (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (event.target.id) &#123; <span class="comment">//传入li的id</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'id1'</span>:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'id2'</span>:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p><p>这样性能会提高, 可维护性也会更好</p><h3 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h3><blockquote><p>如果事件用完之后不需要再用了, 最好手动移除事件处理程序</p></blockquote><h2 id="模拟事件"><a href="#模拟事件" class="headerlink" title="模拟事件"></a>模拟事件</h2><h3 id="DOM中的事件模拟"><a href="#DOM中的事件模拟" class="headerlink" title="DOM中的事件模拟"></a>DOM中的事件模拟</h3><p>略</p><h3 id="IE中的事件模拟"><a href="#IE中的事件模拟" class="headerlink" title="IE中的事件模拟"></a>IE中的事件模拟</h3><p>略</p><p>如需学习, 请查阅此处 <a href="https://segmentfault.com/a/1190000004339133" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004339133</a> </p><hr><p>本章完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HTML和JS之间的交互, 就是通过事件实现的.&lt;/p&gt;
&lt;h2 id=&quot;事件流&quot;&gt;&lt;a href=&quot;#事件流&quot; class=&quot;headerlink&quot; title=&quot;事件流&quot;&gt;&lt;/a&gt;事件流&lt;/h2&gt;&lt;p&gt;事件流描述的是从页面中接收事件的顺序.  有冒泡和捕获两种事件处理方
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://thinkerchan.com/categories/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS红皮书读书笔记-12-DOM2和DOM3(待更新)</title>
    <link href="https://thinkerchan.com/2019/04/02/JSbook12/"/>
    <id>https://thinkerchan.com/2019/04/02/JSbook12/</id>
    <published>2019-04-02T13:47:00.000Z</published>
    <updated>2020-07-02T04:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DOM变化"><a href="#DOM变化" class="headerlink" title="DOM变化"></a>DOM变化</h2><h3 id="针对XML命名空间的优化"><a href="#针对XML命名空间的优化" class="headerlink" title="针对XML命名空间的优化"></a>针对XML命名空间的优化</h3><h3 id="其他方面的优化"><a href="#其他方面的优化" class="headerlink" title="其他方面的优化"></a>其他方面的优化</h3><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><h3 id="访问元素的样式"><a href="#访问元素的样式" class="headerlink" title="访问元素的样式"></a>访问元素的样式</h3><h3 id="操作表样式"><a href="#操作表样式" class="headerlink" title="操作表样式"></a>操作表样式</h3><h3 id="元素大小"><a href="#元素大小" class="headerlink" title="元素大小"></a>元素大小</h3><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="NodeIterator"><a href="#NodeIterator" class="headerlink" title="NodeIterator"></a>NodeIterator</h3><h3 id="TreeWalker"><a href="#TreeWalker" class="headerlink" title="TreeWalker"></a>TreeWalker</h3><h2 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h2><h3 id="DOM中的范围"><a href="#DOM中的范围" class="headerlink" title="DOM中的范围"></a>DOM中的范围</h3><h3 id="IE8及更早版本的范围"><a href="#IE8及更早版本的范围" class="headerlink" title="IE8及更早版本的范围"></a>IE8及更早版本的范围</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DOM变化&quot;&gt;&lt;a href=&quot;#DOM变化&quot; class=&quot;headerlink&quot; title=&quot;DOM变化&quot;&gt;&lt;/a&gt;DOM变化&lt;/h2&gt;&lt;h3 id=&quot;针对XML命名空间的优化&quot;&gt;&lt;a href=&quot;#针对XML命名空间的优化&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://thinkerchan.com/categories/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS红皮书读书笔记-11-DOM扩展</title>
    <link href="https://thinkerchan.com/2019/03/28/JSbook11/"/>
    <id>https://thinkerchan.com/2019/03/28/JSbook11/</id>
    <published>2019-03-28T15:46:00.000Z</published>
    <updated>2020-07-02T04:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一章讲了DOM相关的知识, 对此, DOM相关的API已经能满足绝大部分开发者的使用了. 但是jQuery实在是太强大,  以至于W3C对其选择器进行了参考, 而后进行了扩展.</p><h2 id="选择符API"><a href="#选择符API" class="headerlink" title="选择符API"></a>选择符API</h2><h3 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector"></a>querySelector</h3><p>用法:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>);</span><br><span class="line"><span class="keyword">var</span> id_body = <span class="built_in">document</span>.querySelector(<span class="string">'#body'</span>);</span><br><span class="line"><span class="keyword">var</span> class_body = <span class="built_in">document</span>.querySelector(<span class="string">'.body'</span>);</span><br></pre></td></tr></table></figure></p><h3 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll"></a>querySelectorAll</h3><p>用法:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">var</span> class_divs = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.div'</span>);</span><br></pre></td></tr></table></figure></p><h3 id="matchesSelector"><a href="#matchesSelector" class="headerlink" title="matchesSelector"></a><del>matchesSelector</del></h3><blockquote><p>笔者写此文的时候(2019年),此API已作废, 正确的API为 <code>matches</code></p></blockquote><p>此API用得比较少:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.body;<span class="comment">// 假设body.id="Jbody"</span></span><br><span class="line">body.matches(<span class="string">'#Jbody'</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="元素遍历"><a href="#元素遍历" class="headerlink" title="元素遍历"></a>元素遍历</h2><p>略, 此处的API有点鸡肋</p><h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><p>这里只讲HTML5中与DOM相关的新扩展.</p><h3 id="扩展与Class相关的操作"><a href="#扩展与Class相关的操作" class="headerlink" title="扩展与Class相关的操作"></a>扩展与Class相关的操作</h3><ol><li><p>新增getElementByClassName<br>显然这个方法受到了jQuery的启发.</p></li><li><p>新增classList的操作<br>它又以下几个方法:</p></li></ol><ul><li>add(value)</li><li>remove(value)</li><li>contains(value)</li><li>toggle(value)</li></ul><p>以往我们<strong>删除</strong>(注意这里说的是删除)一个元素中的class中的某个值会比较麻烦,现在有了classList, 我们可以:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">div.classList.remove(<span class="string">'test'</span>);</span><br></pre></td></tr></table></figure><h3 id="焦点管理"><a href="#焦点管理" class="headerlink" title="焦点管理"></a>焦点管理</h3><p>新增: </p><ul><li>document.activeElement: 当前焦点元素</li><li>document.hasFocus() : 检测文档是否获得焦点</li></ul><h3 id="HTMLDocument的变化"><a href="#HTMLDocument的变化" class="headerlink" title="HTMLDocument的变化"></a>HTMLDocument的变化</h3><ol><li>引入readyState: document. readyState 只有两种值: ‘loading’||’complete’</li><li>兼容模式: document.compatMode , 标准模式下它的值是 “CSS1Compat”,通常我们用不到这个属性</li><li>head属性: 类似document.body</li></ol><h3 id="字符集属性"><a href="#字符集属性" class="headerlink" title="字符集属性"></a>字符集属性</h3><p>document.charset, 略</p><h3 id="自定义数据属性"><a href="#自定义数据属性" class="headerlink" title="自定义数据属性"></a>自定义数据属性</h3><p>为了规范DOM元素中的自定义属性行为, HTML为开发者提供了自定义数据的属性, 看示例:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> div = Jdiv; <span class="comment">//假设存在一个这样的元素: &lt;div id="Jdiv" data-id="testDiv"&gt;&lt;/div&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取自定义属性的值</span></span><br><span class="line"><span class="keyword">var</span> _id = div.dataset.id;<span class="comment">// "testDiv"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置</span></span><br><span class="line">div.dataset.name = <span class="string">"testdog"</span>;<span class="comment">// "testdog"</span></span><br></pre></td></tr></table></figure></p><h3 id="插入标记"><a href="#插入标记" class="headerlink" title="插入标记"></a>插入标记</h3><ol><li>innerHTML</li></ol><p>HTML5对这个属性做了一次加强, 比如:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在现代浏览器下, script标签会被忽略, 但是旧版本的IE依旧需要注意</span></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">'&lt;script&gt;alert(1)&lt;/script&gt;'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另外, 使用innerHTML一定要注意XSS的问题</span></span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = <span class="string">'&lt;img src="不存在的地址" onerror="alert(1)"&gt;'</span>;</span><br></pre></td></tr></table></figure></p><blockquote><p>书上说: “并不是所有元素都支持innerHTML属性”, 这句话已经过时, 谨慎参考.</p></blockquote><ol start="2"><li>outerHTML: 略</li><li>insertAdjacentHTML(插入位置, html字符串)<br>实际上这个方法早在IE就实现了(IE6都能用), 看下列示例很容易明白:</li></ol><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- beforebegin --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"one"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- afterbegin --&gt;</span></span><br><span class="line">    foo</span><br><span class="line">    <span class="comment">&lt;!-- beforeend --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- afterend --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> d1 = <span class="built_in">document</span>.getElementById(<span class="string">'one'</span>);</span></span><br><span class="line"><span class="handlebars"><span class="xml">    d1.insertAdjacentHTML('afterend', '<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span>');</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">4. 内存和性能问题:</span><br><span class="line">使用innerHTML意味着性能的开销, 如非必要, 尽量少用innerHTML</span><br><span class="line"></span><br><span class="line">### scrollIntoView方法</span><br><span class="line">ele. scrollIntoView()即可让元素滚动到与浏览器窗口顶部.</span><br><span class="line"></span><br><span class="line">## 专有扩展</span><br><span class="line">### 文档模式</span><br><span class="line">略, 现在都用HTML5文档</span><br><span class="line"></span><br><span class="line">### children属性</span><br><span class="line">还记得之前的ele.childNodes吗? 虽然它返回的是nodeList对象, 但是nodeList中的元素节点, 其实就和ele.children是类似的, 只不过children返回的是HTMLcollection.</span><br><span class="line"></span><br><span class="line">### contains方法</span><br><span class="line">要检查一个元素是不是某一个节点的后代:</span><br><span class="line">``` js</span><br><span class="line">ele.contains(oneNode);// bool</span><br></pre></td></tr></table></figure><p>当然DOM3也提供了一个方法:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ele1.compareDocumentPosition(ele2);</span><br></pre></td></tr></table></figure></p><p>这有一个参考: <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/compareDocumentPosition" target="_blank" rel="noopener">MDN-compareDocumentPosition</a> , 但是因为这个API返回的结果还要进行位运算, 操作相对麻烦, 故不流行.</p><h3 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h3><p>innerText, outerText , 只操作文本内容. </p><h3 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h3><p>略, 目前ele. scrollIntoView()最常用.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一章讲了DOM相关的知识, 对此, DOM相关的API已经能满足绝大部分开发者的使用了. 但是jQuery实在是太强大,  以至于W3C对其选择器进行了参考, 而后进行了扩展.&lt;/p&gt;
&lt;h2 id=&quot;选择符API&quot;&gt;&lt;a href=&quot;#选择符API&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://thinkerchan.com/categories/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>JS红皮书读书笔记-10-DOM</title>
    <link href="https://thinkerchan.com/2019/03/28/JSbook10/"/>
    <id>https://thinkerchan.com/2019/03/28/JSbook10/</id>
    <published>2019-03-28T11:47:00.000Z</published>
    <updated>2020-07-02T04:21:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>DOM即文档对象模型, 是针对HTML和XML的一个编程API, 主要功能是允许开发人员添加、移除和修改页面的某一部分。</p><h2 id="节点层次"><a href="#节点层次" class="headerlink" title="节点层次"></a>节点层次</h2><p>DOM以节点树的形式反映:<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Sample Page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>以上就是一个最简单的DOM树结构.</p><p>文档节点是每个文档的根节点。 在这个例子中，文档节点只有一个子节点，即<html>元素. 称之为文档元素。文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。在 HTML 页面中，文档元素始终都是<html>元素。在 XML 中，没有预定义的元素，因此任何元素都可能成为文档元素。</html></html></p><p>每一段标记都可以通过树中的一个节点来表示：HTML 元素通过元素节点表示，特性（attribute） 通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有 12 种节点类型，这些类型都继承自一个基类型。</p><h3 id="Node类型"><a href="#Node类型" class="headerlink" title="Node类型"></a>Node类型</h3><p>DOM1 级定义了一个 Node 接口，该接口将由 DOM 中的所有节点类型实现。这个 Node 接口在JavaScript 中是作为 Node 类型实现的；除了 IE 之外，在其他所有浏览器中都可以访问到这个类型。JavaScript 中的所有节点类型都继承自 Node 类型，因此所有节点类型都共享若相同的基本属性和方法。每个节点都有一个 nodeType 属性，用于表明节点的类型。节点类型由在 Node 类型中定义的下列12 个数值常量来表示，任何节点类型必居其一：</p><ul><li>Node.ELEMENT_NODE(1)；</li><li>Node.ATTRIBUTE_NODE(2)；</li><li>Node.TEXT_NODE(3)；</li><li>Node.CDATA_SECTION_NODE(4)；</li><li>Node.ENTITY_REFERENCE_NODE(5)；</li><li>Node.ENTITY_NODE(6)；</li><li>Node.PROCESSING_INSTRUCTION_NODE(7)；</li><li>Node.COMMENT_NODE(8)；</li><li>Node.DOCUMENT_NODE(9)；</li><li>Node.DOCUMENT_TYPE_NODE(10)；</li><li>Node.DOCUMENT_FRAGMENT_NODE(11)；</li><li>Node.NOTATION_NODE(12)。</li></ul><p>通过比较上面这些常量，可以很容易地确定节点的类型，例如：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nodeType == Node.ELEMENT_NODE)&#123;  <span class="comment">//在 IE 中无效</span></span><br><span class="line">  alert(<span class="string">"Node is an element."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子比较了 someNode.nodeType 与 Node.ELEMENT_NODE 常量。如果二者相等，则意味若someNode 确实是一个元素。然而，由于 IE 没有公开 Node 类型的构造函数，因此上面的代码在 IE 中会导致错误。为了确保跨浏览器兼容，最好还是将 nodeType 属性与数字值进行比较，如下所示：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (someNode.nodeType == <span class="number">1</span>)&#123;  <span class="comment">//适用于所有浏览器</span></span><br><span class="line">  alert(<span class="string">"Node is an element."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并不是所有节点类型都受到 Web 浏览器的支持。开发人员最常用的就是元素和文本节点。</p><ol><li><p>nodeName和nodeValue<br>对于元素节点, nodeName保存的是元素的标签名, 如”DIV”,对于元素节点它们的nodeValue始终是null</p></li><li><p>节点关系<br>每个节点都有一个childNodes属性.其中保存若一个 NodeList 对象。NodeList 是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。请注意，虽然可以通过方括号语法来访问 NodeList 的值，而且这个对象也有 length 属性，但它并不是 Array 的实例。NodeList 对象的独特之处在于，它实际上是基于 DOM 结构动态执行查询的结果，因此 DOM 结构的变化能够自动反映在 NodeList 对象中。</p></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.body;</span><br><span class="line">body.childNodes <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> firstChild = body.childNodes[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> secondChild = body.childNodes.item(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">var</span> count = body.childNodes.length;</span><br></pre></td></tr></table></figure><p>前面我们讲了引用类型中数组, 有几个方法是可以操作数组实例并返回数组的, 比如slice, 如果要把类数组对象转换成熟组, 我们可以:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 推荐方式</span></span><br><span class="line"><span class="keyword">var</span> arr = ([]).slice.call(arrayLikeObj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者新建一个空数组, 循环arrayLikeObj把其中的项添加进空数组</span></span><br></pre></td></tr></table></figure><p>每个节点都有一个 parentNode 属性，该属性指向文档树中的父节点。包含在 childNodes 列表中的所有节点都具有相同的父节点，因此它们的 parentNode 属性都指向同一个节点。此外，包含在childNodes 列表中的每个节点相互之间都是同胞节点。通过使用列表中每个节点的 previousSibling 和 nextSibling 属性，可以访问同一列表中的其他节点。列表中第一个节点的 previousSibling 属性值为 null，而列表中最后一个节点的 nextSibling 属性的值同样也为 null .</p><p>如果列表中只有一个节点，那么该节点的 nextSibling 和 previousSibling 都为 null。</p><p>someNode.firstChild == someNode.childNodes[0]<br>someNode.lastChild == someNode.childNodes[someNode.childNodes.length-1]</p><p>如果没有子节点，那么 firstChild 和 lastChild 的值均为 null.</p><p>另外，someNode.hasChildNodes()可以查询是否包含子节点. 所有节点都包含一个属性ownerDocument, 指向当前文档对象.</p><ol start="3"><li>操作节点<br>前面的关系指针都是只读的, DOM还提供了一些列操作节点的方法:</li></ol><ul><li>appendChild<ul><li>向childNodes里面添加最后一个节点, 如果要被添加的节点本身已经存在于文档当中, 那就会将原本的位置转移到新的位置 . 要记住, DOM树可以看做是一些列指针链接起来的文档模型. <strong>只不过特殊的地方在于DOM节点不能出现在多个位置上</strong></li></ul></li><li>insertBefore<ul><li>用法: someNode.insertBefore(newNode, 参照节点)</li></ul></li><li>replaceChild<ul><li>用法: someNode.replaceChild(newNode, 被替换的节点)</li></ul></li><li>removeChild<ul><li>删除某个节点, 被删除的节点仍为文档所有, 只不过没有了位置</li></ul></li></ul><ol start="4"><li>其他操作</li></ol><ul><li>cloneNode(bool)<ul><li>参数为非true的时候, 执行浅复制,反之深复制, 此方法返回一个新生成的副本, 如果不插入DOM树, 它相当于一个’孤儿’, 没有自己的位置, 但仍属于文档.</li></ul></li><li>normalize<ul><li>可查阅 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/normalize" target="_blank" rel="noopener">MDN- node.normalize</a> </li></ul></li></ul><h3 id="Document类型"><a href="#Document类型" class="headerlink" title="Document类型"></a>Document类型</h3><p>JavaScript 通过 Document 类型表示文档。在浏览器中，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 HTML 页面。而且，document 对象是 window 对象的一个属性，因此可以将其作为全局对象来访问。</p><ol><li>文档的子节点<br>虽然 DOM 标准规定 Document 节点的子节点可以是 DocumentType、Element、ProcessingIn-<br>struction 或 Comment，但还有两个内置的访问其子节点的快捷方式。第一个就是 documentElement 属性，该属性始终指向 HTML 页面中的<html>元素。另一个就是通过 childNodes 列表访问文档元素， 但通过 documentElement 属性则能更快捷、更直接地访问该元素。</html></li></ol><p>基本上最常用到:</p><ul><li>document.documentElement</li><li>document.body</li></ul><ol start="2"><li>文档信息</li></ol><ul><li>document.title</li><li>document.URL</li><li>document.domain: 跨域方面能用到</li><li>document.referrer</li></ul><ol start="3"><li>查找元素<br>由于HTML的容错性, 与标准不同, 实际上元素的签名是忽略大小写的, 但是我们依然要按照区别大小写的方式来开发.</li></ol><ul><li>document.getElementById</li><li>document.getElementsByTagName</li><li>document.getElementsByName</li><li>document.getElementsByClassName</li></ul><ol start="4"><li>特殊集合</li></ol><ul><li>document.anchors: 遍历带有name属性的a标签</li><li>document.applets: 已废弃</li><li>document.forms: 页面所有表单</li><li>document.links: 所有带href的标签</li></ul><ol start="5"><li><p>DOM一致性检测<br>document.hasFeature用于检测DOM是否支持某些功能, 但是实际开发上我们很少用这个API(直接用特征检测更好),故不再讲解.</p></li><li><p>文档写入<br>有以下几个方法:</p></li></ol><ul><li>document.wirte: 这个方法通常用来写入外部脚本, 不建议使用这个API, 会阻塞网页和带来性能问题</li><li>document.wirteLn: 和wirte类似, 但行末会添加换行符(\n)</li><li>document.open: 使用document.wirte的时候会自动执行这个方法</li><li>document.close: 如果不使用这个方法, document.wirte能继续在原有文档上添加内容, 否侧document.wirte会重新清空文档</li></ul><h3 id="Element类型"><a href="#Element类型" class="headerlink" title="Element类型"></a>Element类型</h3><p>除了document类型, element类型就是开放人员最常用的了.</p><ol><li>HTML元素<br>HTML元素基本具备以下属性:</li></ol><ul><li>id</li><li>title</li><li>lang</li><li>dir</li><li>class</li><li>align</li></ul><ol start="2"><li>读写属性(特性)<br>主要是以下三个方法:</li></ol><ul><li>ele.getAttribute(属性名): 通常开发者用点运算符访问或者方括号访问</li><li>ele.setAttribute(属性名, 值)</li><li>ele.removeAttribute(属性名)</li></ul><ol start="3"><li><p>attributes属性<br>ele. attributes返回一个类数组对象, 罗列该元素有的属性, 但是也能使用ele. attributes[属性名]代替ele.getAttribute(‘属性名’)</p></li><li><p>创建元素<br>document.createElement</p></li><li><p>元素的子节点<br>略</p></li></ol><h3 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h3><p>略, 通常开发者用innerHTML或者innerText代替这个功能</p><h3 id="Comment类型"><a href="#Comment类型" class="headerlink" title="Comment类型"></a>Comment类型</h3><p>注释类型, 略</p><h3 id="CDATASection类型"><a href="#CDATASection类型" class="headerlink" title="CDATASection类型"></a>CDATASection类型</h3><p>此类型针对XML, 略</p><h3 id="DocumentType类型"><a href="#DocumentType类型" class="headerlink" title="DocumentType类型"></a>DocumentType类型</h3><p>几乎不用, 略</p><h3 id="DocumentFragment类型"><a href="#DocumentFragment类型" class="headerlink" title="DocumentFragment类型"></a>DocumentFragment类型</h3><p>documentFragment类型在文档中没有对应的标记, 你可以理解成它是文档之外的一个”独立仓库”, 不占用额外的资源.</p><p>假如我们要给一个ul元素插入多个li元素, 按照正常思路:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildLi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">  li.innerText = <span class="string">'new li'</span>;</span><br><span class="line">  <span class="keyword">return</span> li;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  Jul.appendChild(buildLi())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然上面的代码功能上没有问题, 但是导致浏览器的反复渲染. 为了尽可能地减少这种渲染开销, 我们可以利用documentFragment来实现:</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildLi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">  li.innerText = <span class="string">'new li'</span>;</span><br><span class="line">  <span class="keyword">return</span> li;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> frag = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  frag.appendChild(buildLi())</span><br><span class="line">&#125;</span><br><span class="line">Jul.appendChild(frag);<span class="comment">//只渲染了一次</span></span><br></pre></td></tr></table></figure><h3 id="Attr类型"><a href="#Attr类型" class="headerlink" title="Attr类型"></a>Attr类型</h3><p>略, 它不被认为是DOM文档树的一部分</p><h2 id="DOM操作技术"><a href="#DOM操作技术" class="headerlink" title="DOM操作技术"></a>DOM操作技术</h2><h3 id="动态脚本"><a href="#动态脚本" class="headerlink" title="动态脚本"></a>动态脚本</h3><p>即动态创建script元素, 再将script元素插到html中, 此为异步加载</p><h3 id="动态样式"><a href="#动态样式" class="headerlink" title="动态样式"></a>动态样式</h3><p>即动态创建link元素, 再将link元素插到html中,此为异步加载</p><h3 id="操作表格"><a href="#操作表格" class="headerlink" title="操作表格"></a>操作表格</h3><p>操作表格的API不十分常用, 略</p><h3 id="使用NodeList"><a href="#使用NodeList" class="headerlink" title="使用NodeList"></a>使用NodeList</h3><p>除了nodeList(childNodes产生), 还有nodeNameMap(例如document.links产生), HTMLCollection(例如获取dom元素产生), 使用它们的时候尽可能缓存起来, 因为它们都是动态的, 实时更新. 这意味着开销的变大.</p><p>如果你将nodeList长度作为循环判断的截止条件, 那有可能会陷入无限循环.</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>),</span><br><span class="line">  i,</span><br><span class="line">  div;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; divs.length; i++)&#123;</span><br><span class="line">  div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>); </span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>本章完</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;DOM即文档对象模型, 是针对HTML和XML的一个编程API, 主要功能是允许开发人员添加、移除和修改页面的某一部分。&lt;/p&gt;
&lt;h2 id=&quot;节点层次&quot;&gt;&lt;a href=&quot;#节点层次&quot; class=&quot;headerlink&quot; title=&quot;节点层次&quot;&gt;&lt;/a&gt;节点层次&lt;/
      
    
    </summary>
    
    
      <category term="Javascript" scheme="https://thinkerchan.com/categories/Javascript/"/>
    
    
  </entry>
  
</feed>
