<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta name="google-site-verification" content="eGNFdt2ztR4hEzEBjDkGQUWo0r_iPHpw1hoLqy-UUb0" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1" />
  <meta name="renderer" content="webkit">
  
  <title>红皮书第七章学习心得 | 测试狗</title>
  <meta name="description" content="变量变量类型 , 当一个值赋给变量时, 解析器必须确定这个值是基本类型还是引用类型  基本类型: 简单的数据段,按值访问:  有Undefined / null / boolean / number / string引用类型: 多个值构成的对象 , 不能直接访问对象的内存空间. 实际操作的是它的引用(指针)  区别这两个类型的区别:  (1)属性: 只有引用类型才能添加属性 , 基本类型无法添加.">
<meta name="keywords" content="学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="红皮书第七章学习心得">
<meta property="og:url" content="http://thinkerchan.com/2015/02/05/chapter-7/index.html">
<meta property="og:site_name" content="测试狗">
<meta property="og:description" content="变量变量类型 , 当一个值赋给变量时, 解析器必须确定这个值是基本类型还是引用类型  基本类型: 简单的数据段,按值访问:  有Undefined / null / boolean / number / string引用类型: 多个值构成的对象 , 不能直接访问对象的内存空间. 实际操作的是它的引用(指针)  区别这两个类型的区别:  (1)属性: 只有引用类型才能添加属性 , 基本类型无法添加.">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-05-23T10:06:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="红皮书第七章学习心得">
<meta name="twitter:description" content="变量变量类型 , 当一个值赋给变量时, 解析器必须确定这个值是基本类型还是引用类型  基本类型: 简单的数据段,按值访问:  有Undefined / null / boolean / number / string引用类型: 多个值构成的对象 , 不能直接访问对象的内存空间. 实际操作的是它的引用(指针)  区别这两个类型的区别:  (1)属性: 只有引用类型才能添加属性 , 基本类型无法添加.">
<meta name="twitter:creator" content="@thinkerchan">
<meta property="fb:admins" content="thinkerchan">
  
  <link rel="alternate" href="/atom.xml" title="测试狗" type="application/rss+xml">
  

  <link rel="stylesheet" href="/css/style.css" >
  <link rel="shortcut icon" href="/images/favicon.png"/>
  <script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='https://unpkg.com/valine@1.3.4/dist/Valine.min.js'></script>
  <script data-main="/js/build" src="/js/require.js"></script>
  <!--[if lt IE 7]>
  <style>
    .section{
      width: 780px;
    }
    .post-content img{
      width: 100%;
    }
    .jupe pre{
      width: 100%;
    }
  </style>
  <![endif]-->
</head>
<body id="normal" >

<div class="section-wrap section-main">
	<div class="section">
		<div class="header">
	<h1 class="logo">
		<a href="/">测试狗</a>
	</h1>
	<p class="social-links hide">
		<a href="http://weibo.com/thinkerchank/" target="_blank">Weibo</a>
		/
		<a href="https://www.zhihu.com/people/fattychan/activities" target="_blank">Zhihu</a>
		/
		<a href="https://github.com/thinkerchan" target="_blank">Github</a>
	</p>
</div>
		<div class="main">
						<div class="jupe main-body">
				<div class="post-content">
					<h1 class="post-title">红皮书第七章学习心得</h1>
					<div class="post-meta">
						<span class="post-time">2015.02.05</span>
						<div class="post-cats">
							<a class="post-cats-item-link" href="/categories/Javascript/">Javascript</a>
						</div>
					</div>
					<div class="post-toc">
						<div class="toc-title">TOC</div>
						<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#变量"><span class="toc-number">1.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#区别"><span class="toc-number">1.1.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本类型"><span class="toc-number">1.2.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引用类型"><span class="toc-number">1.3.</span> <span class="toc-text">引用类型:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#例子1"><span class="toc-number">1.3.1.</span> <span class="toc-text">例子1:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子2"><span class="toc-number">1.3.2.</span> <span class="toc-text">例子2:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#例子3"><span class="toc-number">1.3.3.</span> <span class="toc-text">例子3:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#检测方式"><span class="toc-number">1.4.</span> <span class="toc-text">检测方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本类型检测方式"><span class="toc-number">1.4.1.</span> <span class="toc-text">基本类型检测方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引用类型检测方式"><span class="toc-number">1.4.2.</span> <span class="toc-text">引用类型检测方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注意事项"><span class="toc-number">1.4.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#执行环境和作用域"><span class="toc-number">2.</span> <span class="toc-text">执行环境和作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#函数声明方式"><span class="toc-number">2.1.</span> <span class="toc-text">函数声明方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#函数声明"><span class="toc-number">2.1.1.</span> <span class="toc-text">函数声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数表达式-匿名函数"><span class="toc-number">2.1.2.</span> <span class="toc-text">函数表达式(匿名函数)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#递归"><span class="toc-number">2.1.3.</span> <span class="toc-text">递归</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包和匿名函数"><span class="toc-number">2.2.</span> <span class="toc-text">闭包和匿名函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包与变量"><span class="toc-number">2.3.</span> <span class="toc-text">闭包与变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#闭包与内存泄露"><span class="toc-number">2.4.</span> <span class="toc-text">闭包与内存泄露</span></a></li></ol></li></ol>
					</div>
					<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量类型 , 当一个值赋给变量时, 解析器必须确定这个值是基本类型还是引用类型</p>
<blockquote>
<p>基本类型: 简单的数据段,按值访问:  有Undefined / null / boolean / number / string<br>引用类型: 多个值构成的对象 , 不能直接访问对象的内存空间. 实际操作的是它的引用(指针)</p>
</blockquote>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>这两个类型的区别:</p>
<blockquote>
<p>(1)属性: 只有引用类型才能添加属性 , 基本类型无法添加.<br>(2)复制:</p>
<blockquote>
<p>基本类型: 复制一个数据副本.  新创建的变量完全是独立的.<br>引用类型: 只是新建一个引用(指针) , 两个变量依然指向同一个内存空间.</p>
</blockquote>
</blockquote>
<blockquote>
<p>(3)传递参数:(参数都是按值传递,且只能按值传递)</p>
</blockquote>
<h3 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h3><p>这个好理解,略</p>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型:"></a>引用类型:</h3><p>关键:<b>按值传递</b>(非常重要)</p>
<h4 id="例子1"><a href="#例子1" class="headerlink" title="例子1:"></a>例子1:</h4><pre><code>function setName(obj){
obj.name=&apos;k&apos;; //即使这个对象是按值传递, obj也会按引用来访问同一个对象. 造成了 按引用传递 的假象.
}
var person = new Object();
setName(person);
alert(person.name) //k
</code></pre><h4 id="例子2"><a href="#例子2" class="headerlink" title="例子2:"></a>例子2:</h4><pre><code>function setName(obj){
   obj.name=&quot;k&quot;;
   obj = new Object();
   //如果是按引用传递,那么obj将被重写了, 输出的应该是x; 在这里,即使是在函数内部改变了参数的值,原始引用依然会保持不变.
   obj.name=&quot;x&quot;; //并且这个新的obj将引用一个局部对象, 这个局部对象在函数执行完之后立即销毁.
}
   var person = new Object();
   setName(person);
   alert(person.name);              //k
</code></pre><h4 id="例子3"><a href="#例子3" class="headerlink" title="例子3:"></a>例子3:</h4><pre><code>function setName(obj){
   // obj.name=&quot;k&quot;;
   obj = new Object();            //证明了这个是局部对象. 函数执行后被销毁.
   obj.name=&quot;x&quot;;
 }
 var person = new Object();
 setName(person);
 alert(person.name);              //undefined
</code></pre><h3 id="检测方式"><a href="#检测方式" class="headerlink" title="检测方式"></a>检测方式</h3><h4 id="基本类型检测方式"><a href="#基本类型检测方式" class="headerlink" title="基本类型检测方式"></a>基本类型检测方式</h4><p><b>typeof</b></p>
<h4 id="引用类型检测方式"><a href="#引用类型检测方式" class="headerlink" title="引用类型检测方式"></a>引用类型检测方式</h4><p><b>instanceof</b></p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>仅仅用<code>typeof</code>或者<code>instanceof</code>来检测引用类型都可能是不靠谱的,为什么不靠谱呢?</p>
<p>以下解释引自红皮书第22章:</p>
<pre><code>Safari（直至第 4 版）在对正则表达式应用typeof操作符时会返回&quot;function&quot;，因此很难确定某个值到底是不是函数。
instanceof操作符在存在多个全局作用域（像一个页面包含多个frame）的情况下，也是问题多多。

如:
 var isArray = value instanceof Array;

以上代码要返回true，value必须是一个数组，而且还必须与Array构造函数在同个全局作用域中。
（别忘了， Array 是 window 的属性。）如果 value 是在另个 frame 中定义的数组，那么以上代码就会返回 false。
</code></pre><p>所以解决办法是什么呢?<br>答: <code>Object.prototype.toString.call(value)</code></p>
<p>用这货来检测引用类型.</p>
<h2 id="执行环境和作用域"><a href="#执行环境和作用域" class="headerlink" title="执行环境和作用域"></a>执行环境和作用域</h2><p>全局环境就是window对象所以的全局变量和函数都是作为window对象的属性和方法创建的.(执行幻境中所有的代码执行完之后,环境就会被销毁,环境内的变量和函数定义也会被销毁)每个函数都有自己的执行环境, 函数在执行时, 函数的环境就会被推入一个环境栈中,然后创建变量对象的 作用域链 , 其作用是保证执行环境对变量和函数的有序访问.执行完之后再弹出.</p>
<p>在函数中,作用域链的最前端是arguments对象,然后逐级向外读取变量,直到全局,全局环境的变量对象始终是作用域链的最后一个对象.</p>
<h3 id="函数声明方式"><a href="#函数声明方式" class="headerlink" title="函数声明方式"></a>函数声明方式</h3><p>通常使用以下两种方式:</p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><pre><code>function fname(arg0, arg1, arg2 ){
    //...
}
</code></pre><p>函数声明的重要特征是: 函数声明提升, 在执行代码之前会先读取函数声明. 即便把函数声明放在执行代码的后面也如此.</p>
<h4 id="函数表达式-匿名函数"><a href="#函数表达式-匿名函数" class="headerlink" title="函数表达式(匿名函数)"></a>函数表达式(匿名函数)</h4><pre><code>var fname=function(arg0, arg1, arg2 ){
    //...
}
</code></pre><p><b>注意:</b></p>
<pre><code>if(condition){
    function sayHi(){ //不能再if语句能使用函数声明!
    alert(1);
    }
} else{
    function sayhi(){
        alert(2);
    }
}
</code></pre><p><b>只能这样:</b></p>
<pre><code>if(condition){
    sayHi = function(){ //函数表达式没有提升作用
        alert(1);
    }
} else{
    sayhi = function(){
        alert(2);
    }
}
</code></pre><p>匿名函数常常当成值来使用. 但是不是它的唯一作用.</p>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>这是常见的递归函数</p>
<pre><code>function recursive(i){
    if(i&lt;=1){
     return i;
    } else {
    //常见的思路是这里写函数名,但是万一本身这个函数名需要更改,就得改动两处
    //return i*recurive(i-1);
    //所以我们用agruments.callee来替代
     return i*arguments.callee;
    }
}
</code></pre><p>在看一个例子</p>
<pre><code>function factorial(num){
    if (num &lt;= 1){
        return 1;
    } else {
        return num * factorial(num-1); //注意 : 报错是因为这里用了固定的函数名!!!
        // return num * arguments.callee(num-1); //应该这样写
    }
}
var anotherFactorial = factorial;   //函数别名
factorial = null;   //去除名字
    alert(factorial(4));  //error!
alert(anotherFactorial(4)); //如果不改动factorial(num-1),那就会报错
</code></pre><p>所以函数名只是一个地址</p>
<h3 id="闭包和匿名函数"><a href="#闭包和匿名函数" class="headerlink" title="闭包和匿名函数"></a>闭包和匿名函数</h3><p><b>闭包, 是有权访问另一个函数作用域中的变量的函数(注意闭包是函数).常见的闭包创建方式, 在一个函数的内部创建另一个函数.</b></p>
<p>当函数第一次被调用时,会创建一个执行环境以及相应的作用域链并把作用域链赋给一个特殊的内部属性<b>[[scope]]</b>,然后使用this arguments和其他参数来初始化活动对象(即变量),但在作用域链中外部函数的活动对象逐级增加.</p>
<p>例如:</p>
<pre><code>function compare(v1, v2){
    if(v1 &lt; v2){
        return -1;
    } else if(v1 &gt; v2){
        return 1;
    } else{
        return 0;
    }
}
var result = compare(5 ,10);
</code></pre><p>compare内会创建this , arguments ,v1 , v2 的活动对象.全局执行环节的变量对象 this result compare处于第二位.</p>
<p>作用域链本质上是一个执行变量对象的指针列表,它只引用但不实际包含变量对象.一般来说,函数执行完之后, 局部活动对象就会被销毁, 内存中只保留全局作用域.</p>
<p><b>但是闭包不一样.</b><br>比如说,下面这个例子,我们一看以为值是My Object,但是并非如此.</p>
<pre><code>var name = &quot;The Window&quot;;
var object = {
name : &quot;My Object&quot;,
getNameFunc : function(){
  return function(){
    return this.name;
    };
  }
};
alert(object.getNameFunc()())  //The Window
</code></pre><p>思考:为什么读取到的是<code>The Window</code>?</p>
<p><b>本人至今还没有非常清晰的理解.各位看官求指导.</b></p>
<p>如果要达到期待的效果:</p>
<pre><code>var name = &quot;The Window&quot;;
var object = {
name : &quot;My Object&quot;,
getNameFunc : function(){
  var that = this;     //this = object,缓存这个想要访问的环境即可
  return function(){
    return that.name;
  };
}
};
 alert(object.getNameFunc()()); //My Object
</code></pre><h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><p>典型的闭包:</p>
<pre><code> function f1(){
    var n=999;
    function f2(){
        alert(n); // 999
    }
}
</code></pre><p>作用域链这种配置机制出现一个副作用,闭包只能取得包含函数中任何变量的最后一个值. 因为闭包(是一个函数), 保存的是整个对象,而不是某个特殊的对象.</p>
<p><b>例子1:</b></p>
<pre><code>function cf(){
          var result = new Array();
          for(var i = 0; i&lt;10 ; i++){
               result[i]=function(){
                    return i;
               }
          }
          return result;
     }
     var fns=cf();
     for(var i=0 ; i&lt;10;i++){
          document.write(fns[i]()+&apos;&lt;br&gt;&apos;);//10个10
     }
</code></pre><p><b>例子2:</b></p>
<pre><code>function cf(){
          var result = new Array();
          for(var i = 0; i&lt;10 ; i++){
               result[i]=function(num){
                    return function(){
                         return num;
                     }
               }//这里没有i
          }
          return result;
     }
     var fns=cf();
     for(var i=0 ; i&lt;10;i++){
          document.write(fns[i]()+&apos;&lt;br&gt;&apos;);
     }
</code></pre><p><b>例子3:</b></p>
<pre><code>function cf(){
          var result = new Array();
          for(var i = 0; i&lt;10 ; i++){
               result[i]=function(num){
                    return function(){
                         return num;
                     }
               }(i)
          }
          return result;
     }
     var fns=cf();
     for(var i=0 ; i&lt;10;i++){
          document.write(fns[i]()+&apos;&lt;br&gt;&apos;);
     }
</code></pre><p>This对象<br>     this对象是基于函数执行环境绑定的, 全局环境中, this==window, 函数为某个对象的方法时且被调用时, this为当前对象.<br>     但是匿名函数的指向环境具有全局性 ,通常指向window. 由于闭包的写法不一样, 可能不太明显</p>
<pre><code>var name = &quot;The Window&quot;;
       var object = {
           name : &quot;My Object&quot;,
           getName: function(){
               return this.name;
           }
       };
       alert(object.getName());     //&quot;My Object&quot;
       alert((object.getName)());   //&quot;My Object&quot;
       alert(object.getName)          //这里会输出函数的所有代码.
       alert((object.getName=object.getName)());  // 所以这里实际上就是将匿名函数放在了全局环境中.因此指向window.
       //注意以下写法
      var x=10;
      alert(x=x);     //10
</code></pre><h3 id="闭包与内存泄露"><a href="#闭包与内存泄露" class="headerlink" title="闭包与内存泄露"></a>闭包与内存泄露</h3><p>以下代码容易发生无意识内存泄露:</p>
<pre><code>function fn(){
    var el = document.getElementById(&apos;el&apos;);
    el.onclick=function(){
        this.style.color=&quot;red&quot;;
    }
}
</code></pre><p>这段代码获取一个DOM元素并为其设置字体颜色,但它已经发生了内存泄露,为什么?因为<code>el</code>的引用放在了匿名函数中.这在函数内部和本地对象(el)创建了一个循环引用.</p>
<p>改进方法:</p>
<pre><code>function fn(){
    document.getElementById(&apos;el&apos;).onclick=function(){
        this.style.color=&quot;red&quot;;
    }
}
</code></pre>
					<div class="post-share">
	<ul class="share-list">
		<li><a class="icon icon-weibo" href="javascript:share.weibo();"><span>weibo</span></a></li>
		<li>
      <a class="icon icon-wechat" onmouseenter="share.wechat(this)"  onmouseleave="share.wechatHide()">
        <div class="wechat-qrcode" id="qrcodeBox">
          <img width="140" height="140" class="wechat-qrcode-img" id="wechatQrcodeImg">
          <em class="wechat-tri"></em>
        </div>
        <span>wechat</span>
      </a>
    </li>
		<li><a class="icon icon-qzone" href="javascript:share.qzone();"><span>qzone</span></a></li>
	</ul>
</div>
					<!-- 评论 -->
					<div class="post-comments" id="Jcmt">
	<h3 class="post-comments-tit">访客评论</h3>
	<div id="vcomments"></div>
	<script>

		var checkEle =function(id){return !!document.getElementById(id)} ,
			hideCmt = checkEle('JnoCmt')||checkEle('resume') ;
		if (hideCmt) {
			Jcmt.style.display = 'none';
		}else{
			new Valine({
			    el: '#vcomments',
			    appId: 'XPJzs0FfufkFfuBjbJraqhbo-gzGzoHsz',
			    appKey: 'QoS0zL4Y2xTDviitGOPkvCGv',
			    notify:false,
			    verify:false,
			    avatar:'mm',
			    placeholder: '感谢您的留言, 请勿灌水和广告.'
			})
		}
	</script>
</div>
				</div>
			</div>		</div>
		<div class="footer">
  <p class="left">&copy; 测试狗 ,
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">
      本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
  </p>
	<p class="right">Base on Github & Hexo</p>
</div>
<div class="count" style="display: none;">
  <script type="text/javascript" src="https://s5.cnzz.com/z_stat.php?id=1276809529&web_id=1276809529"></script>
</div>
	</div>
</div>

</body>
</html>