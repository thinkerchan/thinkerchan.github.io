<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta name="google-site-verification" content="eGNFdt2ztR4hEzEBjDkGQUWo0r_iPHpw1hoLqy-UUb0" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1" />
  <meta name="renderer" content="webkit">
  
  <title>再看GET和POST | ThinkerChan</title>
  <meta name="description" content="GET请求是什么红皮书里描述:  GET 是最常见的请求类型，最常用于向服务器查询某些信息。必要时，可以将查询字符串参数追加到 URL 的末尾，以便将信息发送给服务器。对 XHR 而言，位于传入 open()方法的 URL 末尾的查询字符串必须经过正确的编码才行。   GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET">
<meta name="keywords" content="web前端,JavaScript,CSS,HTML,安全,乱七八糟">
<meta property="og:type" content="article">
<meta property="og:title" content="再看GET和POST">
<meta property="og:url" content="http://thinkerchan.com/2015/06/15/post-get/index.html">
<meta property="og:site_name" content="ThinkerChan">
<meta property="og:description" content="GET请求是什么红皮书里描述:  GET 是最常见的请求类型，最常用于向服务器查询某些信息。必要时，可以将查询字符串参数追加到 URL 的末尾，以便将信息发送给服务器。对 XHR 而言，位于传入 open()方法的 URL 末尾的查询字符串必须经过正确的编码才行。   GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2016-01-07T02:03:58.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="再看GET和POST">
<meta name="twitter:description" content="GET请求是什么红皮书里描述:  GET 是最常见的请求类型，最常用于向服务器查询某些信息。必要时，可以将查询字符串参数追加到 URL 的末尾，以便将信息发送给服务器。对 XHR 而言，位于传入 open()方法的 URL 末尾的查询字符串必须经过正确的编码才行。   GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET">
<meta name="twitter:creator" content="@thinkerchan">
<meta property="fb:admins" content="thinkerchan">
  
  <link rel="alternate" href="/atom.xml" title="ThinkerChan" type="application/rss+xml">
  

  <link rel="stylesheet" href="/css/style.css" >
  <link rel="shortcut icon" href="/images/favicon.png"/>
  <script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='https://unpkg.com/valine/dist/Valine.min.js'></script>
  <script data-main="/js/build" src="/js/require.js"></script>
  <!--[if lt IE 7]>
  <style>
    .section{
      width: 780px;
    }
    .post-content img{
      width: 100%;
    }
    .jupe pre{
      width: 100%;
    }
  </style>
  <![endif]-->
</head>
<body>

<div class="section-wrap section-main">
	<div class="section">
		<div class="header">
	<h1 class="logo">
		<a href="/">ThinkerChan</a>
	</h1>
	<p class="social-links hide">
		<a href="http://weibo.com/thinkerchank/" target="_blank">Weibo</a>
		/
		<a href="https://www.zhihu.com/people/fattychan/activities" target="_blank">Zhihu</a>
		/
		<a href="https://github.com/thinkerchan" target="_blank">Github</a>
	</p>
</div>
		<div class="main">
						<div class="jupe main-body">
				<div class="post-content">
					<h1 class="post-title">再看GET和POST</h1>
					<div class="post-meta">
						<span class="post-time">2015.06.15</span>
						<div class="post-cats">
							<a class="post-cats-item-link" href="/categories/HTTP/">HTTP</a>
						</div>
					</div>
					<div class="post-toc">
						<div class="toc-title">TOC</div>
						<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#GET请求"><span class="toc-number">1.</span> <span class="toc-text">GET请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#是什么"><span class="toc-number">1.1.</span> <span class="toc-text">是什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#POST请求"><span class="toc-number">2.</span> <span class="toc-text">POST请求</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#是什么-1"><span class="toc-number">2.1.</span> <span class="toc-text">是什么</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#我们所理解的区别"><span class="toc-number">3.</span> <span class="toc-text">我们所理解的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#涨姿势"><span class="toc-number">4.</span> <span class="toc-text">涨姿势</span></a></li></ol>
					</div>
					<h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>红皮书里描述:</p>
<blockquote>
<p>GET 是最常见的请求类型，最常用于向服务器查询某些信息。必要时，可以将查询字符串参数追加<br>到 URL 的末尾，以便将信息发送给服务器。对 XHR 而言，位于传入 open()方法的 URL 末尾的查询字<br>符串必须经过正确的编码才行。</p>
</blockquote>
<ul>
<li>GET 请求可被缓存</li>
<li>GET 请求保留在浏览器历史记录中</li>
<li>GET 请求可被收藏为书签</li>
<li>GET 请求不应在处理敏感数据时使用</li>
<li>GET 请求有长度限制</li>
<li>GET 请求只应当用于取回数据</li>
</ul>
<h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><blockquote>
<p>通常用于向服务器发送应该被保存的数据。 POST 请求应该<br>把数据作为请求的主体提交，而 GET 请求传统上不是这样。 POST 请求的主体可以包含非常多的数据，<br>而且格式不限。</p>
</blockquote>
<ul>
<li>POST 请求不会被缓存</li>
<li>POST 请求不会保留在浏览器历史记录中</li>
<li>POST 不能被收藏为书签</li>
<li>POST 请求对数据长度没有要求</li>
</ul>
<h2 id="我们所理解的区别"><a href="#我们所理解的区别" class="headerlink" title="我们所理解的区别"></a>我们所理解的区别</h2><blockquote>
<p>表格来源:<a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="noopener">W3school</a></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">对比</th>
<th style="text-align:center">Get</th>
<th style="text-align:center">Post</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">后退按钮/刷新</td>
<td style="text-align:center">无害</td>
<td style="text-align:center">重新提交数据</td>
</tr>
<tr>
<td style="text-align:center">书签</td>
<td style="text-align:center">可收藏</td>
<td style="text-align:center">不可收藏</td>
</tr>
<tr>
<td style="text-align:center">缓存</td>
<td style="text-align:center">可缓存</td>
<td style="text-align:center">不可缓存</td>
</tr>
<tr>
<td style="text-align:center">后端获取</td>
<td style="text-align:center">Request.QueryString获取</td>
<td style="text-align:center">Request.Form获取</td>
</tr>
<tr>
<td style="text-align:center">编码类型</td>
<td style="text-align:center">application/x-www-form-urlencoded</td>
<td style="text-align:center">application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td>
</tr>
<tr>
<td style="text-align:center">数据长度限制</td>
<td style="text-align:center">“通常2048个字符”<b style="color:red;">有误</b></td>
<td style="text-align:center">无限制</td>
</tr>
<tr>
<td style="text-align:center">数据类型</td>
<td style="text-align:center">ASCII字符</td>
<td style="text-align:center">无限制</td>
</tr>
<tr>
<td style="text-align:center">安全性</td>
<td style="text-align:center">不安全</td>
<td style="text-align:center">比Get安全</td>
</tr>
<tr>
<td style="text-align:center">传送差异</td>
<td style="text-align:center">method=’get’, action属性无效</td>
<td style="text-align:center">action=”test.asp?a=a”和action=”test.asp”是不一样的</td>
</tr>
<tr>
<td style="text-align:center">数据存放</td>
<td style="text-align:center">URL</td>
<td style="text-align:center">HTTP主体</td>
</tr>
<tr>
<td style="text-align:center">可见性</td>
<td style="text-align:center">可见</td>
<td style="text-align:center">不可见</td>
</tr>
</tbody>
</table>
<h2 id="涨姿势"><a href="#涨姿势" class="headerlink" title="涨姿势"></a>涨姿势</h2><p><a href="http://pakchoi.me/" target="_blank" rel="noopener">裁员</a>随手赏了我一个涨姿势的<a href="http://aijuans.iteye.com/blog/1562027" target="_blank" rel="noopener">机会</a>, 刷新了我对这部分知识的理解.= =||| 为了偷懒,我直接贴出作者部分的原文.</p>
<p>GET和POST与数据如何传递没有关系</p>
<p>GET和POST是由HTTP协议定义的。在HTTP协议中，Method和Data（URL， Body， Header）是正交的两个概念，也就是说，使用哪个Method与应用层的数据如何传输是没有相互关系的。</p>
<pre><code>HTTP没有要求，如果Method是POST数据就要放在BODY中。
 也没有要求，如果Method是GET，数据（参数）就一定要放在URL中而不能放在BODY中。
</code></pre><p>那么，网上流传甚广的这个说法是从何而来的呢？我在HTML标准中，找到了相似的描述。这和网上流传的说法一致。但是这只是HTML标准对HTTP协议的用法的约定。怎么能当成GET和POST的区别呢？</p>
<p>而且，现代的Web Server都是支持GET中包含BODY这样的请求。虽然这种请求不可能从浏览器发出，但是现在的Web Server又不是只给浏览器用，已经完全地超出了HTML服务器的范畴了。</p>
<pre><code>HTTP协议对GET和POST都没有对长度的限制
</code></pre><p>HTTP协议明确地指出了，HTTP头和Body都没有长度的要求。而对于URL长度上的限制，有两方面的原因造成：</p>
<ol>
<li><p>浏览器。据说早期的浏览器会对URL长度做限制。据说IE对URL长度会限制在2048个字符内（流传很广，而且无数同事都表示认同）。但我自己试了一下，我构造了90K的URL通过IE9访问live.com，是正常的。网上的东西，哪怕是Wikipedia上的，也不能信。</p>
</li>
<li><p>服务器。URL长了，对服务器处理也是一种负担。原本一个会话就没有多少数据，现在如果有人恶意地构造几个几M大小的URL，并不停地访问你的服务器。服务器的最大并发数显然会下降。另一种攻击方式是，把告诉服务器Content-Length是一个很大的数，然后只给服务器发一点儿数据，嘿嘿，服务器你就傻等着去吧。哪怕你有超时设置，这种故意的次次访问超时也能让服务器吃不了兜着走。有鉴于此，多数服务器出于安全啦、稳定啦方面的考虑，会给URL长度加限制。但是这个限制是针对所有HTTP请求的，与GET、POST没有关系。</p>
</li>
</ol>
<ul>
<li>感谢原作者<a href="http://aijuans.iteye.com/blog/1562027" target="_blank" rel="noopener">aijuans</a></li>
</ul>

					<div class="post-share">
	<ul class="share-list">
		<li><a class="icon icon-weibo" href="javascript:share.weibo();"><span>weibo</span></a></li>
		<li>
      <a class="icon icon-wechat" onmouseenter="share.wechat(this)"  onmouseleave="share.wechatHide()">
        <div class="wechat-qrcode" id="qrcodeBox">
          <img width="140" height="140" class="wechat-qrcode-img" id="wechatQrcodeImg">
          <em class="wechat-tri"></em>
        </div>
        <span>wechat</span>
      </a>
    </li>
		<li><a class="icon icon-qzone" href="javascript:share.qzone();"><span>qzone</span></a></li>
	</ul>
</div>
					<!-- 评论 -->
					<div class="post-comments" id="Jcmt">
	<h3 class="post-comments-tit">访客评论</h3>
	<div id="vcomments"></div>
	<script>
		if (document.getElementById('JnoCmt')==null) {
			new Valine({
			    el: '#vcomments',
			    appId: 'XPJzs0FfufkFfuBjbJraqhbo-gzGzoHsz',
			    appKey: 'QoS0zL4Y2xTDviitGOPkvCGv',
			    notify:false,
			    verify:false,
			    avatar:'mm',
			    placeholder: '评论组件采用了Valine, 感谢您的留言, 请勿灌水和广告.'
			})
		}else{
			Jcmt.style.display = 'none';
		}
	</script>
</div>
				</div>
			</div>		</div>
		<div class="footer">
  <p class="left">&copy; Thinker Chan ,
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">
      本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
  </p>
	<p class="right">Hosted by <a href="https://pages.coding.me">Coding Pages</a> , Theme by <a href="http://yujiangshui.com/" target="_blank">于江水</a> .</p>
</div>
	</div>
</div>

</body>
</html>