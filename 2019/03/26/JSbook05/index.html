<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <link rel="dns-prefetch" href="https://thinkerchan.com">
  
  <title>JS红皮书读书笔记-05-引用类型 | 测试狗</title>
  <meta name="author" content="测试狗">
  
  <meta name="description" content="老陈">
  
  
  <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">

  <meta property="og:title" content="JS红皮书读书笔记-05-引用类型"/>
  <meta property="og:site_name" content="测试狗"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="alternate" href="/atom.xml" title="测试狗" type="application/atom+xml">

  <link rel="preload" as="style" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  <link rel="icon" class="js-site-favicon" type="image/svg+xml" href="https://github.githubassets.com/favicons/favicon.svg">
  <link href="https://unpkg.com" rel="dns-prefetch" />
  <link href="https://busuanzi.ibruce.info" rel="dns-prefetch" />
  <link href="https://cdn1.lncld.net" rel="dns-prefetch" />
  
  <link href="https://xpjzs0ff.api.lncld.net" rel="dns-prefetch" />
  
</head>

<body>
  <div class="container">
    <div class="left-col" style="background-image:url('https://tva1.sinaimg.cn/large/007S8ZIlgy1ggdmi6yapmj30dw0zk0wm.jpg')">
      <div class="intrude-less">
        <header id="header" class="inner">
          <a href="/">
            <div class="profilepic"><img src='https://tva1.sinaimg.cn/large/007S8ZIlly1giq5t0agwnj30bf0b4jrk.jpg'></div>
          </a>
          <div class="author-name"><a href="/">测试狗</a></div>
          <p class="aboutme">老陈</p>
          <nav id="main-nav">
            <ul class="main">
              
              <li>
                
                  <a href="/archives">归档</a>
                
              </li>
              
              <li>
                
                  <a href="/categories">专题</a>
                
              </li>
              
              <li>
                
                  <a href="/friendlinks">友链</a>
                
              </li>
              
              <li>
                
                  <a href="/life">关于</a>
                
              </li>
              
              <li>
                
                  <a href="/search">搜索</a>
                
              </li>
              
            </ul>
          </nav>
          <nav id="sub-nav">
            <div class="social">
              
              <a class="twitter" href="https://twitter.com/thinkerchan" title="Twitter">Twitter</a>
              
              
              
              <a class="github" href="https://github.com/thinkerchan" title="Github">Github</a>
              
              
              <a class="yuque" href="https://yuque.com/testdog" title="语雀">语雀</a>
              

              
              <a class="rss" href="/atom.xml" title="RSS">RSS</a>
              
            </div>
          </nav>
        </header>
      </div>
    </div>
    <div class="mid-col">
      <div class="mid-col-container">
        <div id="content" class="inner">
          <article class="post">

  
    <div class="meta">
      
<div class="date">

<time datetime="2019-03-26T06:46:00.000Z"
      
      data-updated="true"
       itemprop="datePublished">
  2019-03-26
</time>





</div>

    </div>
  
  <h1 class="title" itemprop="name">JS红皮书读书笔记-05-引用类型</h1>
  <div class="entry-content" itemprop="articleBody">
    
    <div class="post-toc">
      <div class="toc-title">TOC</div>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Object"><span class="toc-number">1.</span> <span class="toc-text">Object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Array"><span class="toc-number">2.</span> <span class="toc-text">Array</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#检测数组"><span class="toc-number">2.1.</span> <span class="toc-text">检测数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#转换方法"><span class="toc-number">2.2.</span> <span class="toc-text">转换方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈方法"><span class="toc-number">2.3.</span> <span class="toc-text">栈方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#队列方法"><span class="toc-number">2.4.</span> <span class="toc-text">队列方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重排序方法"><span class="toc-number">2.5.</span> <span class="toc-text">重排序方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作方法"><span class="toc-number">2.6.</span> <span class="toc-text">操作方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#位置方法"><span class="toc-number">2.7.</span> <span class="toc-text">位置方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代方法"><span class="toc-number">2.8.</span> <span class="toc-text">迭代方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#归并方法"><span class="toc-number">2.9.</span> <span class="toc-text">归并方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Date"><span class="toc-number">3.</span> <span class="toc-text">Date</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RegExp"><span class="toc-number">4.</span> <span class="toc-text">RegExp</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function"><span class="toc-number">5.</span> <span class="toc-text">Function</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#没有重载"><span class="toc-number">5.1.</span> <span class="toc-text">没有重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数声明和函数表达式"><span class="toc-number">5.2.</span> <span class="toc-text">函数声明和函数表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#作为值的函数"><span class="toc-number">5.3.</span> <span class="toc-text">作为值的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数内部熟悉"><span class="toc-number">5.4.</span> <span class="toc-text">函数内部熟悉</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数属性和方法"><span class="toc-number">5.5.</span> <span class="toc-text">函数属性和方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本包装类型"><span class="toc-number">6.</span> <span class="toc-text">基本包装类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Boolean"><span class="toc-number">6.1.</span> <span class="toc-text">Boolean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Number"><span class="toc-number">6.2.</span> <span class="toc-text">Number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String"><span class="toc-number">6.3.</span> <span class="toc-text">String</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单体内置对象"><span class="toc-number">7.</span> <span class="toc-text">单体内置对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Global"><span class="toc-number">7.1.</span> <span class="toc-text">Global</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math"><span class="toc-number">7.2.</span> <span class="toc-text">Math</span></a></li></ol></li></ol>
    </div>
    
    <h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p>创建Object对象的方法:</p>
<ul>
<li>new Object</li>
<li>对象字面量(不会调用Object构造函数)</li>
</ul>
<p>其他知识点:</p>
<ul>
<li>通常用点运算符访问对象的熟悉</li>
<li>如非必要, 避免[“prop”]访问对象熟悉</li>
<li>如果函数需要大量传参, 可以用对象作为参数</li>
</ul>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p>创建方式:</p>
<ul>
<li>new Array, 也可以省略new关键字i<ul>
<li>var arr = new Array(10); arr.length==10</li>
<li>var arr = new Array(‘a’,’b’); arr == [‘a’,’b’]  </li>
</ul>
</li>
<li>var arr = [], 不会调用Array构造函数<ul>
<li>var values = [1,2,]; 不要有空项, 不同浏览器识别不一致</li>
</ul>
</li>
<li>length不是只读的, 可以手动修改<ul>
<li>可以利用这个属性代替arr.push的操作</li>
</ul>
</li>
</ul>
<p>知识点:</p>
<h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><ul>
<li>instanceof</li>
<li>Arrary.isArray( )</li>
<li>constructor属性(不过不建议用这个, 可以被修改)</li>
<li>obj.toString.call(arr), 为什么不用自身的toString要用对象的toString方法来检测, 我们看示例:<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(&#123;&#125;).toString();	<span class="comment">//'[object Object]'</span></span><br><span class="line">([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]).toString();	<span class="comment">//'1,2,3'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><p>上面的示例也涉及到一个数组的转换方法, 我这里再列出来(不过这些都是所有对象都有的方法):</p>
<ul>
<li>toLocaleString(); 数组实例调用这个方法,其中的每一项也会调用</li>
<li>toString();同上</li>
<li>valueOf()</li>
</ul>
<p>数组特有:</p>
<ul>
<li>join, 解释略</li>
</ul>
<h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><p>栈是一种后进先出的数据结构，也就是最新添加的项最早被移除。而栈中项的插入（叫做推入）和移除（叫做弹出），只发生在一个位置栈的顶部。对应方法为: push和pop, 请看示例:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>); <span class="comment">// 推入两项</span></span><br><span class="line">alert(count);  <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">count = colors.push(<span class="string">"black"</span>); <span class="comment">// 推入另一项</span></span><br><span class="line">alert(count); <span class="comment">//3</span></span><br><span class="line"><span class="keyword">var</span> item = colors.pop();  <span class="comment">// 取得最后一项</span></span><br><span class="line">alert(item);  <span class="comment">//"black" </span></span><br><span class="line">alert(colors.length); <span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><p>栈数据结构的访问规则是 LIFO（后进先出），而队列数据结构的访问规则是 FIFO（First-In-First-Out， 先进先出）。队列在列表的未端添加项，从列表的前端移除项。由于 push()是向数组未端添加项的方法， 因此要模拟队列只需一个从数组前端取得项的方法。实现这一操作的数组方法就是 shift()，它能够移除数组中的第一个项并返回该项，同时将数组长度减 1。结合使用 shift()和 push()方法，可以像使用队列一样使用数组。</p>
<p>看示例:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>);  <span class="comment">//推入两项</span></span><br><span class="line">alert(count); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">count = colors.push(<span class="string">"black"</span>); <span class="comment">//推入另一项</span></span><br><span class="line">alert(count);  <span class="comment">//3</span></span><br><span class="line"><span class="keyword">var</span> item = colors.shift();  <span class="comment">//取得笫一项</span></span><br><span class="line">alert(item);  <span class="comment">//"red" </span></span><br><span class="line">alert(colors.length); <span class="comment">//2</span></span><br></pre></td></tr></table></figure></p>
<p>另外还有一个unshift方法 , 和shift方法功能相反</p>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><p>数组中已经存在两个可以直接用来重排序的方法：reverse()和 sort(), 两个方法都会修改原数组。<br>sort方法会调用数组中的每一项的toString方法,得到其中的字符串之后, 在做排序对比.</p>
<p>我们来看一个示例:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.sort();</span><br><span class="line">alert(values);  <span class="comment">//0,1,10,15,5, 这里并没有按我们想要的来排序</span></span><br></pre></td></tr></table></figure></p>
<p>我们给sort加一个比较函数作为参数:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>]; </span><br><span class="line">values.sort(compare); </span><br><span class="line">alert(values);  <span class="comment">// 15,10,5,1,0</span></span><br></pre></td></tr></table></figure></p>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><ul>
<li>concat, 返回被修改的副本</li>
<li>slice(start,end), 返回被删除的数组,  一般用于克隆数组(浅复制) .通常用[].slice.call(arrayLike)来转换成数组</li>
<li>splice(start [, deleteCount, insretItem1, insretItem2, ….] )  // 返回被删除的数组: <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">x.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="string">'x'</span>)<span class="comment">//[2]</span></span><br><span class="line">alert(x) <span class="comment">//[1,'x',3,4,5,6]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><ul>
<li>indexOf()</li>
<li>lastIndexOf()</li>
</ul>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><ul>
<li>every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回 true，则返回 true。</li>
<li>filter()：顾名思义, 过滤所需要的数组元素, 对数组中的每一项运行给定函数，返回该函数会返回 true 的项组成的数组。</li>
<li>some()：对数组中的每一项运行给定函数，如果该函数对任一项返回 true，则返回 true。</li>
<li>forEach()：对数组中的每一项运行给定函数。<strong>这个方法没有返回值</strong>。</li>
<li>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。<br>以上5种方法都不会修改数组中的包含的值。</li>
</ul>
<p><code>every</code>,<code>some</code>比较类似:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> everyResult = numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">alert(everyResult); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someResult = numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">alert(someResult);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>我们看一个map的示例:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> mapResult = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>)</span>&#123; </span><br><span class="line">	<span class="comment">// 所以map的回调函数有三个参数, 数组项, 索引, 数组本身</span></span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(mapResult); <span class="comment">//[2,4,6,8,10,8,6,4,2]</span></span><br></pre></td></tr></table></figure></p>
<p>我们在看一个面试题:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map(<span class="built_in">parseInt</span>);<span class="comment">//?</span></span><br></pre></td></tr></table></figure></p>
<p>你可能一下子想不出答案, 那我直接告诉你好了, 答案是: [1,NaN,NaN]</p>
<p>如果你不明白, 可以看下面的解析, 否则直接跳过<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cb</span>(<span class="params">item,index,arr</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> item+<span class="string">'-'</span>+index;	<span class="comment">//注意map回调方法里面要有返回值</span></span><br><span class="line">&#125;</span><br><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map(cb);	<span class="comment">//["1-0", "2-1", "3-2"];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们换一种写法帮助理解</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_parseInt</span>(<span class="params">string, radix</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">parseInt</span>(string,radix) <span class="comment">// parseInt(string,radix), 这个方法本身是有返回值的</span></span><br><span class="line">&#125;</span><br><span class="line">[<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>].map(_parseInt); <span class="comment">//[1,NaN,NaN]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//所以看得出item,和index传到了parseInt对应的参数string, radix中, 而string中的数字必须小于radix, 否则转换十进制失败, 即NaN</span></span><br></pre></td></tr></table></figure></p>
<h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><ul>
<li>reduce</li>
<li>reduceRight</li>
</ul>
<p>解析: 略</p>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>只讲一个奇技淫巧, 求某个月有多少天:<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getDays = <span class="function"><span class="keyword">function</span>(<span class="params">m</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>((<span class="keyword">new</span> <span class="built_in">Date</span>).getFullYear(),m,<span class="number">0</span>).getDate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><p>请查看<a href="https://thinkerchan.com/2016/01/05/regex/">正则表达式教程</a></p>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法。由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定。</p>
<p>三种使用方式:<br><strong>函数声明</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> <strong>函数表达式</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">num1, num2</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;	<span class="comment">//这个分号别漏了, 养成习惯</span></span><br></pre></td></tr></table></figure></p>
<p> <strong>构造函数(不推荐)</strong>:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>);</span><br></pre></td></tr></table></figure></p>
<p>从技术角度讲，这是一个函数表达式。但是，我们不推荐读者使用这种方法定义函数，因为这种语法会导致解析两次代码（第一次是解析常规 ECMAScript 代码，第二次是解析传入构造函数中的字符串），从而影响性能。不过，这种语法对于理解“函数是对象，函数名是指针＂的概念倒是非常直观的。</p>
<h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>ES函数中, 是没有重载的,如果你非得声明多个一样的函数, 那么最后声明的那个函数会覆盖之前的声明.</p>
<h3 id="函数声明和函数表达式"><a href="#函数声明和函数表达式" class="headerlink" title="函数声明和函数表达式"></a>函数声明和函数表达式</h3><p>函数声明和函数表达式虽然功能是一致的, 但是解析器对这两种方式的优先级并不一致. 解析器会率先读取<strong>函数声明</strong>,  并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。</p>
<p>看示例:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">// 会正常执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>略</p>
<h3 id="函数内部熟悉"><a href="#函数内部熟悉" class="headerlink" title="函数内部熟悉"></a>函数内部熟悉</h3><p>在函数内部，有两个特殊的对象：<code>arguments</code> 和 <code>this</code>。其中，<code>arguments</code> 在第 3 章曾经介绍过， 它是一个类数组对象，包含若传入函数中的所有参数。虽然 <code>arguments</code> 的主要用途是保存函数参数， 但这个对象还有一个名叫 <code>callee</code> 的属性，该属性是一个指针，指向拥有这个 <code>arguments</code>对象的函数。</p>
<p>请看下面这个非常经典的阶乘函数:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * factorial(num<span class="number">-1</span>)	;<span class="comment">//看这里, 如果外部的factorial被人改变的话, 此处的factorial也需要同时改变</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>于是我们可以:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num<span class="number">-1</span>)	;<span class="comment">//降低耦合, 严格模式会报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>this</strong>: 函数上下文对象, 当前执行环境对象.<br><strong>caller</strong>: 表示当前函数被<strong>谁</strong>调用, ES5下也有arguments.caller,值为undefined, 它的存在主要用于区别函数的caller</p>
<p>ps: 严格模式下, <strong>函数.caller</strong>不能赋值, <strong>arguments.caller</strong>访问报错</p>
<h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><p>属性:  前面通过caller讲了一个, 接下来还有<strong>length</strong>和<strong>prototype</strong>:<br>length: 你可能比较少见函数的length熟悉, 它表示函数的形参长度.<br>prototype: 我们下一章重点讲这个</p>
<p>方法:  每个函数都包含两个非继承而来的方法, 这两个方法的功能类似, 区别在于第二个参数的格式不同而已<br>call(contextObj [,arg1,arg2…])<br>apply(contextObj, arr): arr可以是数组示例, 也可以是arguments对象</p>
<p>那么这两个方法是用来干啥? <strong>主要</strong>是用来改变指向的(但它们的<strong>基本</strong>功能还是用于改变传参方式):<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor();	<span class="comment">//red</span></span><br><span class="line">sayColor.call(<span class="keyword">this</span>);	<span class="comment">//red</span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>);	<span class="comment">//red</span></span><br><span class="line">sayColor.call(o);	<span class="comment">//blue</span></span><br></pre></td></tr></table></figure></p>
<p>你要是不好理解, 可以这么想象:</p>
<blockquote>
<p>函数fn打了个电话(call), 等会我要到你(环境对象)那里去玩哦, 顺便给你带点东西(参数), 既然玩完了, 那自然fn任务也完成了(说明fn会被执行完毕).</p>
</blockquote>
<p>使用 call()（或 apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系(例如不需要o.sayColor的存在)。可提高代码重用性。</p>
<p>此外还有另一个方法: <strong>bind</strong>, 这个方法和call,apply的功能是类似的:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">color</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objectSayColor = sayColor.bind(o); </span><br><span class="line">objectSayColor();  <span class="comment">//blue</span></span><br></pre></td></tr></table></figure></p>
<p>另外还有:</p>
<ul>
<li>toLocaleString</li>
<li>toString</li>
<li>valueOf</li>
</ul>
<p>详解略</p>
<h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>为了便于操作基本类型值，ECMAScript 还提供了 3 个特殊的引用类型：Boolean、Number 和<br>String。这些类型与本章介绍的其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。     实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>这个例子中的变量 s1 包含一个字符串，字符串当然是基本类型值。而下一行调用了  s1 的<br>substring()方法，并将返回的结果保存在了 s2 中。我们知道，基本类型值不是对象，因而从逻辑上讲它们不应该有方法（但是它们确实有方法）</p>
<p>当第二行代码访问 s1 时，访问过程处于一种读取模式，也就是要从内存中读取这个字符串的值。而在读取模式中访问字符串时，后台都会自动完成下列处理。</p>
<ul>
<li>创建 String 类型的一个实例</li>
<li>在实例上调用指定的方法</li>
<li>销毁这个实例</li>
</ul>
<p>可以将以上三个步骤想象成是执行了下列 ECMAScript 代码。<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"some text"</span>); </span><br><span class="line"><span class="keyword">var</span> s2 = s1.substring(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<p>经过此番处理，基本的字符串值就变得跟对象一样了。而且，上面这三个步骤也分别适用于 Boolean<br>和 Number 类型对应的布尔值和数字值。</p>
<p><strong>引用类型</strong>与<strong>基本包装类型</strong>的主要<strong>区别就是对象的生存期</strong>。使用 new 操作符创建的引用类型的实例， 在执行流离开当前作用域之前都一直保存在内存中。</p>
<p>而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味若我们不能在运行时为基本类型值添加属性和方法。</p>
<p>我们来看这个示例:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">"some text"</span>; </span><br><span class="line">s1.color = <span class="string">"red"</span>;</span><br><span class="line">alert(s1.color);  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<p>在此，第二行代码试图为字符串 s1 添加一个 color 属性。但是，当第三行代码再次访问 s1 时， 其 color 属性不见了。问题的原因就是第二行创建的 String 对象在执行第三行代码时已经被销毁了。第三行代码又创建自已的 String 对象，而该对象没有 color 属性。</p>
<p>当然，可以显式地调用 Boolean、Number 和 String 来创建基本包装类型的对象。不过，<strong>如非必要, 请不要这做</strong>，因为这种做法很容易让人分不清自已是在处理基本类型还是引用类型的值。</p>
<p><strong>基本类型</strong>和<strong>基本包装类型</strong>区别在于new产生的对象, 还能继续拥有属性和方法.</p>
<p>Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。例如：(同理传入number和boolean一样)<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">"some text"</span>); </span><br><span class="line">alert(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>);	<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><p>只有一个建议: 不要用它的基本包装类型</p>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h3><p>略</p>
<h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>有下列的一些方法:</p>
<ul>
<li>继承的方法:<ul>
<li>valueOf</li>
<li>toLocaleString</li>
<li>toString</li>
</ul>
</li>
<li>字符方法:<ul>
<li>charAt</li>
<li>charCodeAt</li>
<li>String.fromCharCode, 此为静态方法. 与charCodeAt功能相反</li>
</ul>
</li>
<li>字符串操作方法:<ul>
<li>concat</li>
<li>slice</li>
<li>substr</li>
<li>substring</li>
<li>localeCompare, 略</li>
</ul>
</li>
<li>字符串位置方法:<ul>
<li>indexOf</li>
<li>lastIndexOf</li>
</ul>
</li>
<li>去除空格:<ul>
<li>trim, 返回副本</li>
</ul>
</li>
<li>格式:<ul>
<li>toLocaleUpperCase</li>
<li>toLocaleLowerCase</li>
<li>toUpperCase</li>
<li>toLowerCase</li>
</ul>
</li>
<li>字符串模式匹配方法:<ul>
<li>match, text.match(pattern)作用和pattern.exec(text) 相同</li>
<li>search</li>
<li>replace, 常用语替换HTML字符串模板, 转义HTML符号</li>
<li>split, 转数组</li>
</ul>
</li>
<li>HTML方法: 实现标签的嵌套:<tag>string</tag><ul>
<li>anchor</li>
<li>big</li>
<li>bold</li>
<li>fixed</li>
<li>fontcolor</li>
<li>fontsize</li>
<li>italics</li>
<li>link</li>
<li>small</li>
<li>strike</li>
<li>sup</li>
<li>sub</li>
</ul>
</li>
</ul>
<h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><p>由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在程序执行之前就已经存在了。</p>
<h3 id="Global"><a href="#Global" class="headerlink" title="Global"></a>Global</h3><p>在浏览器中即window</p>
<pre><code>- URI编码
    - encodeURI
    - encodeURIComponent
    - decodeURI
    - decodeURIComponent
- Eval: 在 eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在 eval()执行的时候创建。严格模式下不能赋值, 也不能访问到eval里面创建的函数或者变量
- global对象的属性: 略
</code></pre><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><ul>
<li>Math的属性: 略</li>
<li>Math.max和Math.min<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>); </span><br><span class="line">alert(max);  <span class="comment">//54</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> min = <span class="built_in">Math</span>.min(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>); </span><br><span class="line">alert(min);  <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要求一个数组的最大值要怎么办呢?</span></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,values);	<span class="comment">//8, 前面函数方法那里, 讲了call/apply, 这里就是apply的基本功能</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>PS: 基于这个, 我们可以出一个题目, 有多少种方法求数组的最大值?(自行思考)</p>
<ul>
<li>舍入方法<ul>
<li>Math.ceil, 向上取舍</li>
<li>Math.floor, 向下取舍</li>
<li>Math.round, 四舍五入</li>
</ul>
</li>
<li>Math.random: 最常用的方法之一</li>
<li>其他方法: 看图<br><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1g6ue87hcj312k09ejs9.jpg" alt="Math其他方法"></li>
</ul>
</blockquote>

  </div>

</article>


  <nav id="pagenavi">
    
    <a href="/2019/03/26/JSbook06/" class="prev">上一篇：JS红皮书读书笔记-06-面向对象</a>
    
    
    <a href="/2019/03/23/JSbook04/" class="next">下一篇：JS红皮书读书笔记-04-变量、作用域和内存问题</a>
    
  </nav>

        </div>
        
        
          <div class="post-comments" id="Jcmt">
            <h1 class="post-comments-title">访客评论</h1>
            <div id="Jcomment"></div>
          </div>
        
      </div>
      <footer id="footer" class="inner">
        © 2021 - 测试狗 -
        <span id="busuanzi_container_site_pv">PV <span id="busuanzi_value_site_pv"></span></span>
        <p>Powered by <a href="https://hexo.io/">Hexo</a> & <a href="https://github.com/thinkerchan/hexo-theme-greyshade">GreyShade</a></p>
      </footer>
    </div>
  </div>
  
  <script>
    let mod ={
      timePrefix:'t-',
      expire:1000*60*60,
      load:function(libName,libUrl,cb){
        let aval = (new Date).getTime() - localStorage.getItem(this.timePrefix+libName) < this.expire;
        let libStr = localStorage.getItem(libName)
        if (aval && libStr) {
          this.parseAndInsert(libStr)
          cb && cb(libStr);
        }else{
          this.ajax(libUrl,(str)=>{
            localStorage.setItem(libName, str)
            localStorage.setItem(this.timePrefix+libName, (new Date).getTime())
            this.parseAndInsert(str)
            cb && cb(str);
          })
        }
      },
      parseAndInsert(rawStr) {
        let script = document.createElement('script')
        script.innerHTML = rawStr
        document.body.appendChild(script)
      },
      ajax:function(url,cb){
        let xhr = new XMLHttpRequest;
        xhr.open('get', url, true)
        xhr.send();
        xhr.onreadystatechange = function () {
          if (xhr.readyState == 4 && xhr.status == 200) {
            cb && cb(xhr.responseText)
          }else{
            // console.log(xhr.readyState,xhr.status);
          }
        }
      },
      genCmt(){
        window.Valine && new Valine({
          el: '#Jcomment',
          appId: 'XPJzs0FfufkFfuBjbJraqhbo-gzGzoHsz',
          appKey: 'QoS0zL4Y2xTDviitGOPkvCGv',
          notify: true,
          verify: false,
          avatar: 'mm',
          pageSize: '10',
          placeholder: 'Valine+Leancloud提供评论'
        })
      }
    }

    mod.load('lib-av', 'https://cdn.jsdelivr.net/npm/leancloud-storage@3.0.1/dist/av-min.js', () => {
      mod.load('lib-cmt', 'https://unpkg.com/valine@1.4.14/dist/Valine.min.js',()=>{
        let t = setTimeout(() => {
          mod.genCmt()
          clearTimeout(t)
          t = null;
        }, 100);
      })
    })
  </script>
  
  <script async defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
  <script async defer src="https://s5.cnzz.com/z_stat.php?id=1276809529&web_id=1276809529"></script>
  
</body>
</html>