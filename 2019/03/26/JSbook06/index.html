<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=Edge">
  <meta name="google-site-verification" content="eGNFdt2ztR4hEzEBjDkGQUWo0r_iPHpw1hoLqy-UUb0" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1" />
  <meta name="renderer" content="webkit">
  
  <title>JS红皮书读书笔记-06-面向对象 | 测试狗</title>
  <meta name="description" content="理解对象第五讲里面讲了对象声明的两种方式:   使用Object构造函数 对象字面量  属性类型ES5描述对象属性(property)的特征, 称为特性(attribute), 定义特性是为了实现js引擎用的, 所以在JS中不能直接访问它们(特性). 为了表示特性是内部值, 规范把它们放在两个方括号之中. ES5有两种属性: 1. 数据属性: 数据属性包含一个数据值的位置。在这个位置可以读取和写入">
<meta name="keywords" content="测试狗,前端,计算广告,产品经理">
<meta property="og:type" content="article">
<meta property="og:title" content="JS红皮书读书笔记-06-面向对象">
<meta property="og:url" content="https://thinkerchan.github.io/2019/03/26/JSbook06/index.html">
<meta property="og:site_name" content="测试狗">
<meta property="og:description" content="理解对象第五讲里面讲了对象声明的两种方式:   使用Object构造函数 对象字面量  属性类型ES5描述对象属性(property)的特征, 称为特性(attribute), 定义特性是为了实现js引擎用的, 所以在JS中不能直接访问它们(特性). 为了表示特性是内部值, 规范把它们放在两个方括号之中. ES5有两种属性: 1. 数据属性: 数据属性包含一个数据值的位置。在这个位置可以读取和写入">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://ws3.sinaimg.cn/large/006tKfTcgy1g1gdt138bpj30cw070mx5.jpg">
<meta property="og:image" content="https://ws4.sinaimg.cn/large/006tKfTcgy1g1gkye1wc6j30s80bqaaj.jpg">
<meta property="og:updated_time" content="2019-03-26T15:17:47.020Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JS红皮书读书笔记-06-面向对象">
<meta name="twitter:description" content="理解对象第五讲里面讲了对象声明的两种方式:   使用Object构造函数 对象字面量  属性类型ES5描述对象属性(property)的特征, 称为特性(attribute), 定义特性是为了实现js引擎用的, 所以在JS中不能直接访问它们(特性). 为了表示特性是内部值, 规范把它们放在两个方括号之中. ES5有两种属性: 1. 数据属性: 数据属性包含一个数据值的位置。在这个位置可以读取和写入">
<meta name="twitter:image" content="https://ws3.sinaimg.cn/large/006tKfTcgy1g1gdt138bpj30cw070mx5.jpg">
<meta name="twitter:creator" content="@thinkerchan">
<meta property="fb:admins" content="thinkerchan">
  
  <link rel="alternate" href="/atom.xml" title="测试狗" type="application/rss+xml">
  

  <link rel="stylesheet" href="/css/style.css" >
  <link rel="shortcut icon" href="/images/favicon.png"/>
  <script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src='https://unpkg.com/valine@1.3.4/dist/Valine.min.js'></script>
  <script data-main="/js/build" src="/js/require.js"></script>
  <!--[if lt IE 7]>
  <style>
    .section{
      width: 780px;
    }
    .post-content img{
      width: 100%;
    }
    .jupe pre{
      width: 100%;
    }
  </style>
  <![endif]-->
</head>
<body id="normal" >

<div class="section-wrap section-main">
	<div class="section">
		<div class="header">
	<h1 class="logo">
		<a href="/">测试狗</a>
	</h1>
	<p class="social-links hide">
		<!-- <a href="http://weibo.com/thinkerchank/" target="_blank">Weibo</a> -->
		/
		<!-- <a href="https://www.zhihu.com/people/fattychan/activities" target="_blank">Zhihu</a> -->
		/
		<!-- <a href="https://github.com/thinkerchan" target="_blank">Github</a> -->
	</p>
</div>
		<div class="main">
						<div class="jupe main-body">
				<div class="post-content">
					<h1 class="post-title">JS红皮书读书笔记-06-面向对象</h1>
					<div class="post-meta">
						<span class="post-time">2019.03.26</span>
						<div class="post-cats">
							<a class="post-cats-item-link" href="/categories/Javascript/">Javascript</a>
						</div>
					</div>
					<div class="post-toc">
						<div class="toc-title">TOC</div>
						<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#理解对象"><span class="toc-number">1.</span> <span class="toc-text">理解对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#属性类型"><span class="toc-number">1.1.</span> <span class="toc-text">属性类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定义多个属性"><span class="toc-number">1.2.</span> <span class="toc-text">定义多个属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#读取属性的特性"><span class="toc-number">1.3.</span> <span class="toc-text">读取属性的特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建对象"><span class="toc-number">2.</span> <span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#工厂模式"><span class="toc-number">2.1.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数模式"><span class="toc-number">2.2.</span> <span class="toc-text">构造函数模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型模式"><span class="toc-number">2.3.</span> <span class="toc-text">原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数-原型模式"><span class="toc-number">2.4.</span> <span class="toc-text">构造函数+原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态原型模式"><span class="toc-number">2.5.</span> <span class="toc-text">动态原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#寄生构造函数"><span class="toc-number">2.6.</span> <span class="toc-text">寄生构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#稳妥构造函数"><span class="toc-number">2.7.</span> <span class="toc-text">稳妥构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#继承"><span class="toc-number">3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原型链"><span class="toc-number">3.1.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#借用构造函数"><span class="toc-number">3.2.</span> <span class="toc-text">借用构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组合继承"><span class="toc-number">3.3.</span> <span class="toc-text">组合继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型式继承"><span class="toc-number">3.4.</span> <span class="toc-text">原型式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#寄生式继承"><span class="toc-number">3.5.</span> <span class="toc-text">寄生式继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#寄生组合继承"><span class="toc-number">3.6.</span> <span class="toc-text">寄生组合继承</span></a></li></ol></li></ol>
					</div>
					<h2 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h2><p>第五讲里面讲了对象声明的两种方式: </p>
<ul>
<li>使用Object构造函数</li>
<li>对象字面量</li>
</ul>
<h3 id="属性类型"><a href="#属性类型" class="headerlink" title="属性类型"></a>属性类型</h3><p>ES5描述对象<strong>属性</strong>(property)的特征, 称为<strong>特性</strong>(attribute), 定义特性是为了实现js引擎用的, 所以在JS中不能直接访问它们(<strong>特性</strong>). 为了表示<strong>特性</strong>是内部值, 规范把它们放在两个方括号之中.</p>
<p>ES5有两种属性:</p>
<p><strong>1. 数据属性</strong>:</p>
<p>数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有 4 个描述其行为的特性。</p>
<ul>
<li>[[Configurable]]: 表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。默认值: true</li>
<li>[[Enumerable]]: 可枚举, 即能否for-in循环出这个属性, 默认值: true</li>
<li>[[Writable]]: 是否能改属性的值, 默认值:true</li>
<li>[[Value]]: 默认值: undefined</li>
</ul>
<p>为了帮助理解, 我们来看一个例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">va person = &#123;&#125;; </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">  writable: <span class="literal">false</span>, </span><br><span class="line">  value: <span class="string">"Nicholas"</span>,</span><br><span class="line">  configurable: <span class="literal">false</span>,  <span class="comment">//禁止删除</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这个配置只能用一次,否则会报错</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    writable: <span class="literal">true</span>, <span class="comment">// Cannot redefine property:</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">alert(person.name); <span class="comment">//"Nicholas" </span></span><br><span class="line">person.name = <span class="string">"Greg"</span>; <span class="comment">//非严格模式下赋值被忽略, 严格模式下报错</span></span><br><span class="line">alert(person.name);  <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name; <span class="comment">//严格模式下报错</span></span><br><span class="line">alert(person.name);  <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>
<p>如果<strong>运行Object.defineProperty方法时</strong>, 不明确指定的话, configurable, enumerable, writable的值都会变成<strong>false</strong>(要记住原本他们都是true).</p>
<blockquote>
<p>注意: 笔者写本文的时候(2019年), 亲自写示例测试, 书上的这部分话已经不可信.</p>
</blockquote>
<p><strong> 2. 访问器属性</strong></p>
<p>访问器属性不包含数据值；它们包含一对儿 getter 和 setter 函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用 getter 函数，这个函数负责返回有效的值；在写入访问器属性时，会调用<br>setter 函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下 4 个特性:</p>
<ul>
<li>[[Configurable]]:同数据属性</li>
<li>[[Enumerable]]: 同数据属性</li>
<li>[[Get]]: 读取属性时候调用的函数, 默认undefined </li>
<li>[[Set]]: 写入属性时候调用的函数, 默认undefined </li>
</ul>
<p>要修改访问器属性的特性, 同样是用Object.defineProperty方法</p>
<p>我们看这个例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(demo, <span class="string">'name'</span>, &#123;</span><br><span class="line">  configurable:<span class="literal">true</span>,</span><br><span class="line">  enumerable:<span class="literal">true</span>,</span><br><span class="line">  get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我读取了属性'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  set:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'我设置了属性'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="定义多个属性"><a href="#定义多个属性" class="headerlink" title="定义多个属性"></a>定义多个属性</h3><p>定义多个属性可以用Object.defineProperties方法, 用法和Object.defineProperty类似, 只不过第二个参数为复合对象</p>
<h3 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h3><p>用Object.getOwnPropertyDescriptor读取属性的特性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  _year: &#123;</span><br><span class="line">    value: <span class="number">2004</span></span><br><span class="line">  &#125;,</span><br><span class="line">  edition: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  year: &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123; </span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._year = newValue;</span><br><span class="line">        <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"_year"</span>); </span><br><span class="line">alert(descriptor.value); <span class="comment">//2004 </span></span><br><span class="line">alert(descriptor.configurable); <span class="comment">//false</span></span><br><span class="line">alert(<span class="keyword">typeof</span> descriptor.get); <span class="comment">//"undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"year"</span>); </span><br><span class="line">alert(descriptor.value);  <span class="comment">//undefined </span></span><br><span class="line">alert(descriptor.enumerable); <span class="comment">//false</span></span><br><span class="line">alert(<span class="keyword">typeof</span> descriptor.get); <span class="comment">//"function"</span></span><br></pre></td></tr></table></figure>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>为了解决多次生成对象的问题, 形成了以下常见的接种封装模式</p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name; </span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>); </span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>
<p>工厂模式解决了生成多个类似对象的问题, 但是还没有解决对象属于什么”类”的问题</p>
<h3 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age; </span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>
<p>我们通常把构造函数的函数名首字母大写, 这样它看起来想一个”类”, 区别于工厂模式, 构造函数模式有三个不同点:</p>
<ul>
<li>没有显示地创建对象</li>
<li>直接将数学和方法赋给this</li>
<li>没有return</li>
</ul>
<p>创建一个实例的方式变成了 new Person, 背后产生了以下几个步骤:</p>
<ul>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；</li>
<li>执行构造函数中的代码（为这个新对象添加属性）；</li>
<li>返回新对象</li>
</ul>
<hr>
<p><strong>构造函数的优点:</strong></p>
<p>构造函数的好处在于, 它可以作为一种自定义的”类”, 也容易识别实例是否为某一种类型:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(person1.constructor == Person); <span class="comment">//true</span></span><br><span class="line">alert(person2.constructor == Person); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>注意, 创建Person的实例的时候必须用new关键字, 否则创建的示例会挂载到window上.</p>
<hr>
<p><strong>构造函数的缺点:</strong></p>
<p>还是用上一个例子, 但是我们稍作修改:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age; </span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'alert(this.name)'</span>); <span class="comment">//为了方便理解我们使用new Function</span></span><br><span class="line">  <span class="comment">//这样每次创建Person实例的时候, sayName都是重复创建具有一样功能的方法(即资源浪费)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'k'</span>,<span class="number">18</span>,<span class="string">'fe'</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'x'</span>,<span class="number">19</span>,<span class="string">'bd'</span>);</span><br><span class="line">p1.sayName == p2.sayName; <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<hr>
<p>前面我知道了函数名其实就是一个指针, 那么我们可以稍微改造一下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age; </span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'k'</span>,<span class="number">18</span>,<span class="string">'fe'</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person(<span class="string">'x'</span>,<span class="number">19</span>,<span class="string">'bd'</span>);</span><br><span class="line">p1.sayName == p2.sayName; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>这样, 看起来也没什么问题了. 不过sayName作为一个全局函数, 只能给Person的示例调用, 好像又对不起它作为全局函数的称号, 如果要定义很多个方法, 那就需要很多个全局函数, 这样看起来又不像”封装好”的样子.</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>为了解决构造函数模式的问题, 诞生了原型模式, 第五章我们提到了Function的每个实例都有两个属性, 一个是<code>length</code>, 另一个是<code>prototype</code>, 我们现在来着重讲这个<code>prototype</code>. <code>prototype</code>其实是一个指针, 指向一个<code>对象</code>, 这个对象用于<strong>存储所有实例共享的属性和方法</strong>.</p>
<p>我们先看一张图:</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1g1gdt138bpj30cw070mx5.jpg" alt="demo.prototype"></p>
<p>可以看到我随便创造的一个空函数demo, 它的prototype指向了一个对象, 这个对象包含了<code>constructor</code>和<code>__proto__</code>两个属性, 而<br><code>constructor</code>又指回了demo本身, <code>__proto__</code>指向的是Object, 实际上这个Object, 就是我们常常看到的 new Object里面的那个Object构造函数, 这侧面反映了几个事实:</p>
<ul>
<li>所有<strong>对象</strong>都是Object的实例(这个讲原型链的时候会继续深入讲解)</li>
<li>一个<strong>对象</strong>可以通过<code>__proto__</code>访问<strong>生成这个对象的构造函数</strong> 的 <strong>原型</strong></li>
<li>原型(prototype)的<code>constructor</code>属性,指向的是构造函数本身</li>
</ul>
<hr>
<p>我们再看这个例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>; </span><br><span class="line">Person.prototype.age = <span class="number">29</span>; </span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>; </span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line">person1.sayName();  <span class="comment">//"Nicholas"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person2.sayName();  <span class="comment">//"Nicholas" </span></span><br><span class="line">alert(person1.sayName == person2.sayName); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>实际上它的原理如下:</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcgy1g1gkye1wc6j30s80bqaaj.jpg" alt="原理图"></p>
<p>图中实例的<code>[[prototype]]</code>, 其实就是<code>__proto__</code>;</p>
<p>除了用这个属性确定对象实例和原型的关系, 还可以通过下列方式查看:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Person.prototype.isPrototypeOf(person1) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person1) == Person.prototype <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>前面给出的例子, 构造函数都是一个空函数, 不存在任何的属性和方法. 基于上一个代码示例, 我们尝试通过实例重写原型的属性.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(person1.name);  <span class="comment">// "Nicholas"</span></span><br><span class="line">person1.name = <span class="string">"kkk"</span>;   <span class="comment">//注意我这里只是改了实例的属性, 并没有改构造函数</span></span><br><span class="line">alert(person1.name);  <span class="comment">//"kkk"</span></span><br><span class="line">alert(person2.name);  <span class="comment">// "Nicholas"</span></span><br></pre></td></tr></table></figure>
<p>可以看出, 通过实例去改变原型, 是没办法在原型中改变对应的属性或者方法.</p>
<p>从上面的代码能<strong>反映</strong>出, 对象实例查找某一个属性(或者方法), 是先查找构造函数中的同名属性 , 如果找到则停止, 否则继续在原型中查找同名属性.</p>
<blockquote>
<p>解释: 上面的代码是显式地person1.name = “kkk”. 假如构造函数中存在this.name=”kkk”, 那么person1.name的值毫无疑问就是”kkk”;</p>
</blockquote>
<p>由于构造函数和原型的这种特性, 我们要查找一个对象实例的属性究竟<strong>来自自身</strong>还是<strong>来自原型</strong>, 需要用hasOwnProperty方法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">alert(person1.hasOwnProperty(<span class="string">'name'</span>));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<hr>
<p><code>in</code>:<br>通常我们会在for-in(当然ES5可以用Object.keys)中看到in操作符, 用于遍历一个对象的所有课枚举属性, 然而单独使用in操作符的时候, 是用于检测某个对象的某个属性(或方法)是否存在于原型链中. 只要原型中存在需要查找的属性, 假设这个属性为<code>name</code>, 那么不管构造函数是否存在<code>name</code>, in操作符依然能查找出来.</p>
<p>为了查找<strong>只存在原型上的属性(或方法)</strong>, 我们可以将in和hasOwnProperty写成一个函数用于检测: </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span>(<span class="params">object, name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !object.hasOwnProperty(name) &amp;&amp; (name <span class="keyword">in</span> object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><code>简写原型</code>:</p>
<p>前面的代码可以看到, 每添加一个属性, 就要多书写Person.prototype一次, 实际上们可以这样:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>:Person, //注意这里要手动绑定构造函数,因为此时的原型相当于一个新领养的小孩, 要重新让他认爹. 虽然我们大多数情况下用不到<span class="keyword">constructor</span>属性, 但是建议养成这个习惯</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p><code>原型的动态</code>:</p>
<p>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上反映出来 即使是先创建了实例后修改原型也照样如此。</p>
<p>请看例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(); </span><br><span class="line">Person.prototype.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="string">"hi"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayHi(); <span class="comment">//"hi"（没有问题！）</span></span><br></pre></td></tr></table></figure>
<p>如果生成实例之后用字面量的形式修改了原型对象, 那么就会报错:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123; </span><br><span class="line">  <span class="keyword">constructor</span>: Person, </span><br><span class="line">  name : "Nicholas", </span><br><span class="line">  age : 29,</span><br><span class="line">  job : "Software Engineer", </span><br><span class="line">  sayName : function () &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">friend.sayName(); <span class="comment">//error. 因为friend是原本那个原型衍生而来的</span></span><br></pre></td></tr></table></figure>
<hr>
<p>原生对象的原型: Array, Object, Function同样可以通过上述方式修改原型对象, 不过除非必要, 不建议修改.</p>
<hr>
<p>原型模式的缺点:<br>所有属性和方法都写在原型, 看上去实现了共享. 但是如果原型对象中的属性是引用类型的话, 实例对改属性的修改, 也会立刻反映到所有实例上.</p>
<p>看例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123; </span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  name : "Nicholas",</span><br><span class="line">  age : 29,</span><br><span class="line">  job : "Software Engineer",</span><br><span class="line">  friends : ["Shelby","Court"],</span><br><span class="line">  sayName : function () &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line">alert(person1.friends); <span class="comment">//"Shelby,Court,Van" </span></span><br><span class="line">alert(person2.friends);  <span class="comment">//"Shelby,Court,Van" </span></span><br><span class="line">alert(person1.friends === person2.friends); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数-原型模式"><a href="#构造函数-原型模式" class="headerlink" title="构造函数+原型模式"></a>构造函数+原型模式</h3><p>仅仅只用构造函数, 那么在生成对象方法的时候会造成资源浪费. 如果只是用原型模式的话, 那么会产生属性为引用类型时候的弊端. 所以我们可以把这两张方式结合起来:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>,<span class="string">"Court"</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123; </span><br><span class="line">  <span class="keyword">constructor</span>: Person,</span><br><span class="line">  sayName : function () &#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>); <span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>); </span><br><span class="line"></span><br><span class="line">alert(person1.friends); <span class="comment">//"Shelby,Count,Van"</span></span><br><span class="line">alert(person2.friends); <span class="comment">//"Shelby,Count"</span></span><br></pre></td></tr></table></figure>
<p>这样, 组合模式基本解决所有的需求.</p>
<h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>组合模式的优化:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>,<span class="string">"Court"</span>],</span><br><span class="line">  <span class="comment">// 看起来更像是一个'类'</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">      alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寄生构造函数"><a href="#寄生构造函数" class="headerlink" title="寄生构造函数"></a>寄生构造函数</h3><p>假如你有这么一个这样的需求: 批量生产某一种数据类型, 比如数组实例, 但是这个数组实例又有一个<code>toPipedString</code>方法, 那你可以考虑用寄生构造函数.</p>
<p>它和工厂模式长得很像(实际上就是一样的, 该有的缺点都有):</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_Array</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    values.push.apply(values, <span class="built_in">arguments</span>);</span><br><span class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> _Array(<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>);</span><br><span class="line">a.toPipedString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = _Array(<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">4</span>);<span class="comment">// 这里没有用new , 返回的结果依旧一样(就是工厂模式)</span></span><br><span class="line">b.toPipedString();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上面的_Array构造函数, 并没有使用到this, 而且它还有显式的return, 也就是说new了也是白new. 虽然书上给出了这个寄生构造函数模式, 但笔者认为实在没有必要使用这种方式.</p>
</blockquote>
<h3 id="稳妥构造函数"><a href="#稳妥构造函数" class="headerlink" title="稳妥构造函数"></a>稳妥构造函数</h3><p>就是寄生构造函数模式下, 只暴露方法, 不允许通过对象实例直接访问对象的属性值</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>JS只有实现继承, 并且主要依靠原型链实现的.</p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>前面我们讲了原型, 至于原型链. 实际就是用父类的实例, 作为子类的原型对象(即用父类实例重写子类原型对象), 这样父类拥有的属性和方法, 子类实例自然也能访问到.</p>
<p>原型链需要注意:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承了 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意以下操作一点要在继承完之后才能执行, 并且不能用字面量添加方法, 否则会导致继承失效.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加新方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//重写超类型中的方法</span></span><br><span class="line">SubType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType(); </span><br><span class="line">alert(instance.getSuperValue());  <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>除了以上要注意的地方, 原型链继承还有两个问题:</p>
<ul>
<li>第一个问题就是, 当父类的实例包含了引用类型属性时, 子类的原型对象就同样包含了这个引用类型的属性.<br>我们来看示例:</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123; &#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(); </span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>); </span><br><span class="line">alert(instance1.colors);  <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(); </span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green,black", 已经发生修改</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第二个问题: 不能向父类传参.</li>
</ul>
<h3 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h3><p>为了解决原型链继承问题, 我们可以借用父类构造函数, 而不是将父类实力重写子类原型对象 , 通常这种方式叫做经典继承或者伪造继承.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = name || <span class="string">'testdog'</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>,name);  <span class="comment">//想起call和apply的作用吗?</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(); </span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>); </span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(); </span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> subType(<span class="string">'kkk'</span>)</span><br><span class="line">instance.name;  <span class="comment">//'kkk'</span></span><br></pre></td></tr></table></figure>
<p>不过这样的话, 就子类实例无法用instanceof来检查是否是也是父类的实例了.</p>
<p>当然, 不可能把所有属性和方法都放在父类构造函数中, 肯定还有写在父类原型对象的情况. 所以只用call/apply借用父类构造函数实现继承, 也是不够的.</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>顾名思义, 原型链+构造函数组合而成.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//继承属性</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); </span><br><span class="line">SubType.prototype.constructor = SubType; </span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>); </span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>); </span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black" </span></span><br><span class="line">instance1.sayName(); <span class="comment">//"Nicholas";</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>); </span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green" </span></span><br><span class="line">instance2.sayName(); <span class="comment">//"Greg";</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure>
<p>注意:  创建一个子类实例, SuperType其实是运行了两次的 , 一次在于原型链继承, 另一次在于借用以覆盖引用类型属性共享的问题.</p>
<h3 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h3><p>如果只是基于现有的对象实现继承, 那可不比兴师动众写那么多函数:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> k = &#123;</span><br><span class="line">  name:<span class="string">'k'</span>,</span><br><span class="line">  age:<span class="number">18</span>,</span><br><span class="line">  friends:[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">var</span> object = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">  F.prototype = o;  <span class="comment">//浅复制, </span></span><br><span class="line">  reutrn o;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> obj = object(k);</span><br><span class="line">obj.friends.push(<span class="string">'d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = object(k);</span><br><span class="line">obj2.friends; <span class="comment">//['a','b','c','d'];</span></span><br></pre></td></tr></table></figure>
<p>ES5规范化了这种继承方式, 于是有了Object.create方法, 用法同上, 但是它可以多一个参数.这个参数的格式和Object.defineProperties的第二个参数格式一致.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123; </span><br><span class="line">  name: &#123;</span><br><span class="line">    value: <span class="string">"Greg"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(anotherPerson.name); <span class="comment">//"Greg"</span></span><br></pre></td></tr></table></figure>
<h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><p>其实是原型式继承的基础上再包装一层, 用于添加需要的方法, 类似于前面讲的寄生构造函数模式或者工厂模式.</p>
<h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><p>前面讲了组合继承, 它还存在一个两次调用父类的问题. 既然组合类型是通过借用父类函数实现属性继承, 通过原型链实现方法的继承. 那么我们可以在原型链这里动一次手脚.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = <span class="built_in">Object</span>.create(superType.prototype);</span><br><span class="line">  prototype.constructor = subType; </span><br><span class="line">  subType.prototype = prototype; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123; </span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本章完</p>

					<div class="post-share">
	<ul class="share-list">
		<li><a class="icon icon-weibo" href="javascript:share.weibo();"><span>weibo</span></a></li>
		<li>
      <a class="icon icon-wechat" onmouseenter="share.wechat(this)"  onmouseleave="share.wechatHide()">
        <div class="wechat-qrcode" id="qrcodeBox">
          <img width="140" height="140" class="wechat-qrcode-img" id="wechatQrcodeImg">
          <em class="wechat-tri"></em>
        </div>
        <span>wechat</span>
      </a>
    </li>
		<li><a class="icon icon-qzone" href="javascript:share.qzone();"><span>qzone</span></a></li>
	</ul>
</div>
					<!-- 评论 -->
					<div class="post-comments" id="Jcmt">
	<h3 class="post-comments-tit">访客评论</h3>
	<div id="vcomments"></div>
	<script>

		var checkEle =function(id){return !!document.getElementById(id)} ,
			hideCmt = checkEle('JnoCmt')||checkEle('resume') ;
		if (hideCmt) {
			Jcmt.style.display = 'none';
		}else{
			new Valine({
			    el: '#vcomments',
			    appId: 'XPJzs0FfufkFfuBjbJraqhbo-gzGzoHsz',
			    appKey: 'QoS0zL4Y2xTDviitGOPkvCGv',
			    notify:false,
			    verify:false,
			    avatar:'mm',
			    placeholder: '感谢您的留言, 请勿灌水和广告.'
			})
		}
	</script>
</div>
				</div>
			</div>		</div>
		<div class="footer">
  <p class="left">&copy; Thinker Chan ,
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span id="busuanzi_container_site_pv">
      本站总访问量<span id="busuanzi_value_site_pv"></span>次
    </span>
  </p>
	<p class="right">Hosted by <a href="https://pages.coding.me">Coding Pages</a>
  </p>
</div>
<div class="count" style="display: none;">
  <script type="text/javascript" src="https://s5.cnzz.com/z_stat.php?id=1276809529&web_id=1276809529"></script>
</div>
	</div>
</div>

</body>
</html>